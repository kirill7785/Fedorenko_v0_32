// Цель : сделать обвязку для ICCG солвера для тестирования ICCG и сравнения его с алгоритмом Р.П.Федоренко.
// Цель найти ошибку в cgdavis и наконец заставить работать солвер для поправки давления в программе DavisTest.



// Fedorenko2.cpp: определяет точку входа для консольного приложения.
// Первая реализация многосеточного метода.
// Это первоначальный вариант многосеточного метода 1961 года. 
// 
// Fedorenko 1: 27 и 28 июня 2012 года. уравнение с постоянными коэффициентами 
// и для случая равномерной по обоим направлениям сетки с шагом 1.0. Граничные условия только Дирихле. и можно задавать
// отличное от нуля значение Дирихле только на левой границе. В версии Fedorenko1 например в методе прогонк могут быть ошибки нужно сверять с Fedorenko2.
//
// Fesorenko 2 : 29-30(июня)-1(июля) (1 июля до 15 часов) 2012 года. случай переменного коэффициента диффузии (теплопроводность или псевдовремя динамическая вязкость) а
// также случай равномерной сетки с порстоянными шагами h1 и h2. Равномерная сетка генерируется автоматически внутри области.
// Условие Дирихле пока осталось как в версии Fedorenko 1. Также реализованы многие необходимые процедуры для решения уравнений
// Навье-Стокса в терминах вихрь-функция тока : (реализация монотонной аппроксимации Самарского на пятиточечном шаблоне, граничное
// условие Тома для вихря на твёрдой стенке, расчёт компонент скорости по функции тока). В общем сделаны некоторые функции для 
// реализации алгоритма решения уравнений Навье-Стокса в терминах вихрь-функция тока, но сам алгоритм пока не введён в эксплуатацию.

// В версии Fedorenko 3 : 1 июля (после 15 часов) 2 июля 2012. 
// A.  Планируется подстегнуть модуль линейной алгебры my_linalg.c из самой свежей версии AliceFlow_v0_07 и дополнить программу Fedorenko 3 методами Крыловского типа,
// в частности ICCG солвером для эллиптических уравнений. Первая цель такого добавления это сравнение алгоритма Федоренко с методом ICCG и другими Крыловскими методами.
// B. наконец ввод в эксплуатацию экономичного метода решения системы уравнений Навье-Стокса в терминах вихрь-функция тока. (2 июля 2012 года)
// C. реализация алгоритмов LU-SGS - метод приближённой факторизации, SIP (Стоуна), MSI (Д.Андерсон, Дж. Таннехилл, Р.Плетчер), метод неполной факторизации Булеева.
// D. Написание статьи посвящённой сравнению реализованных методов на ряде тестовых задач.
// E. Аппроксимация обобщённого уравнения конвекции-диффузии по препринту Федюшкина А.И. на 9 точечном шаблоне.
// F. Реализация алгоритмов решения СЛАУ для 9 точечного шаблона.
// G. OpenMP распараллеливание, но обязательно сохранять серийную версию. В общем нужно стремиться к алгоритмам которые по характеристикам сходимости повторяют серийные алгоритмы.
// H. Алгоритм Зверева. (реализован 6 июля 2012 года.)
// На каждый из 7 пунктов запланировано потратить два дня и того две недели до отпуска который начинается 16 июля 2012 года. 

// Возможные причины нереалистичности картины течения, а также расходимости по видимому кроются в недостаточно подробной сетке. А именно нужно переходить к полностью неравномерной сетке.
// Сетка должна иметь сгущения к твёрдым стенкам. С другой стороны лучшая сетка как раз равномерная, т.к. неравномерность сетки может вызвать появление всяческих нефизичных максимумов.

// В версии Fedorenko5 нужно добавить граничные условия всех трёх видов.
// Граничные условия имеют первостепенное значение.
// gamma*diff(Ф,n)=kappa*(Фinf-Ф)+qset - Общий вид граничного условия.
// Параметры : gamma, kappa, Фinf, qset.

// Внимание ! Формулы для аппроксимации вихря вблизи границы пригодны лишь для равномерной сетки,
// Поэтому пусть ближайшие три точки к каждой стенке покрыты равномерной сеткой, два ближайших к стенке шага сетки должны быть равны,
// остальные же узлы могут неравномерно отстоять друг от друга.

// 28 августа 2013. Версия Fedorenko19_3. Добавление модели кремниевого ПТШ. startMESFET(). Онлайн расчёт в режиме реального времени. Здесь будет находится ядро солвера,
// возможно его можно будет подключить к графической части через технологию dll.
// Также нужно исправить ошибки содержащиеся в схемах аппроксимации и присутствующие в версии Fedorenko19_2.
// my_splain_interpol_func_table2 не работает при M<>N


// Ввести в задачу Блазиуса с вебрирующей пластиной вибрационное число Ренольдса.
// Помимо симметричных вибраций попробовать аccиметричные. Простой гармонический закон синуса есть симметричные вибрации.

#include "stdafx.h"

#define Real double //double // модель вещественного числа
#define MY_FLOAT 1 // используем арифметику двойной точности если 0.

/*
25 августа 2015 года.
Когда bening_condition = true; это означает что мы на границе
с подложкой ничем не ограничиваем ни потенциал ни его первую производную.
Это очень правильно т.к. в подложке и потенциал и напряжённость должны определяться
именно системой уравнений а не человеком.
*/
const bool bening_condition = true;


// Одна строка матрицы СЛАУ.
// полностью включая граничные узлы.
// только для пятиузловой связи.
typedef struct TMATRNODE {
	Real ap; // диагональный коэффициент.
	Real aw, ae, as, an; // соседние коэффициенты.
	// Коэффициент ann нужен именно для постановки граничного условия на вторую производную.
	Real ann; // Вторая производная от потенциала равна нулю.
} MATRNODE;

//#include <tgmath.h> // макросы математических функций для рвазных типов
#include <math.h>
const double M_PI = 3.14159265;
#include <stdlib.h>
#include <iostream> // для _finite
#include "amg1r5.c" // алгебраический многосеточный метод.
#include <ctime> // для замера времени выполнения.
#include <omp.h> // ускорение времени выполнения
#include <Windows.h>
//#include "basefunction.cpp" // minf
//#include "my_linalg.c" // реализация функций линейной алгебры (заимствовано из AliceFlow_v0_07.cpp).



#define STANDART 0
#define SEIDEL 1
#define LR 2
#define SORDIRICHLET 3
#define ZVER 4 // Алгоритм Зверева В.Г.
#define CGalg 5 // метод сопряжённых градиентов.
#define BiCGStabalg 6 // алгоритм Ван Дер Ворста.
#define ICCGalg 7 // метод сопряжённых градиентов предобусловленный неполным разложением Холецкого.
#define GMRESalg 8 // GMRES
#define AVGR 1
#define AVGRP 2
#define TOMA 0 // аппроксимация Тома
#define WOODS 1 // аппроксимация Вудса
#define JENSEN 2 // Аппроксимация Йенсена
#define EXPLICIT 0 // полностью явная схема аппроксимации.
#define BURAGO 1 // явна только конвективная часть, диффузионная полностью неявна поэтому нужно использовать только условия Куранта.
#define IMPLICIT 2 // полностью неявная схема.
#define PATANKAR 0
#define SAMARSKII 1

// Перечень задач
#define STUDENT 0
#define DAVIS 1 // Тест Девиса
#define CHOHRAVLSKY 2 // Печь Чохральского
#define BLASIUS 3 // Задача Блазиуса
#define RALEYBENAR 4 // Задача Релея Бенара
#define STUDENTA 5 // задача термоконцентрационной конвекции при подогреве сбоку.
#define RALEYBENAR_SYMMETRY 6 // Задача Релея Бенара с границами симметрии на левой и правой стенке для вихря.


#define DIMENSIONLESS 0 // безразмерные уравнения
#define DIMENSIONAL 1 // размерные уравнения

// Параметры закона изменения поперечной скорости пластинки:
// vel_normal=amplitude0*sin(Omega*time);
#define amplitude0 0.0//0.01 // безразмерная амплитуда вибраций используемая, например, в задаче Блазиуса.
#define Omega (2.0*3.141) // безразмерная частота вибраций


#define bnonlinear false // если true то мы имеем нелинейные свойства материалов.


#define VX 1
#define VY 2


const int hash_table_size=1000;
struct Entry {
	bool bvisit; // заполнена ли ячейка данными хранящимися в val.
	Real val; // Значение функции, это как раз те данные которые мы храним.
};

Entry hash_table[hash_table_size];

int hash(Real keyEmag) {
	if (keyEmag<1.2) {
		return 0;
	}
	else {
		// hash_table_size=1000;
		// ln(1.0e8V/cm)==log(1.0e8V/cm)=18.42068074;
		// ln(1e11)=25.32843602;
		// ln(1e14)V/cm=32.23619130;
		// ln(1.1)=0.0953101;
		int ir= (int)(((log(keyEmag)-0.0953101f)/(32.23619130f-0.0953101f))*(hash_table_size-1));
		if (ir>hash_table_size-1) {
			printf("ahtung: Emag=%e > 1.0e14V/cm in hash table",keyEmag);
			getchar();
			ir=hash_table_size-1;
		}
		return ir;
	}
}

int hashAlGaNGaN(Real keyEmag) {
	if (keyEmag<1.2) {
		return 0;
	}
	else {
		// hash_table_size=1000;
		// ln(1.0e8V/cm)==log(1.0e8V/cm)=18.42068074;
		// ln(1e11)=25.32843602;
		// ln(1e14)V/cm=32.23619130;
		// ln(1.1)=0.0953101;
		// ln(1e6)=13.8155;
		int ir = (int)(((log(keyEmag) - 0.0953101f) / (14.0f - 0.0953101f))*(hash_table_size - 1));
		if (ir>hash_table_size - 1) {
			printf("ahtung: Emag=%e > 1.0e14V/cm in hash table", keyEmag);
			getchar();
			ir = hash_table_size - 1;
		}
		return ir;
	}
}

void inithashtable() {
	for (int i=0; i<hash_table_size; i++) hash_table[i].bvisit=false;
} // inithashtable()

// Внимание важное замечание:
// Параметр K2 всюду неизменен на протяжении всего процесса расчёта.
// Используется для ускорения вычислений, хранит в хэш таблице частичную зависимость дрейфовой скорости
// кремния от напряжённости электрического поля.
Real SiliconDriftVel(Real keyEmag, Real K2) {
	
	Real ret;
	if (keyEmag<1.0e-3) {
		ret=1.0;
		// очень маленькая напряжённость,
		// дрейфовая скорость пропорциональна напряженности поля с коэффиентом пропорциональности в виде подвижности.
	}
	else {
		int ikey=hash(keyEmag);
	    if (hash_table[ikey].bvisit==false) {
		    // вычисление :
            ret=hash_table[ikey].val=exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*keyEmag)))));
		    hash_table[ikey].bvisit=true;
	    }
	    else {
		    ret=hash_table[ikey].val;
	    }
	}
	return ret;
}



// передаваемый параметр отвечающий за алгоритм.
const int CongruateGradient=0; // метод сопряжённых градиентов.
const int BiCGStab=1; // алгоритм Ван дер Ворста

void isfinite_vec(int n, Real* xtest, char* sname) {
	for (int i=0; i<n; i++) {
		if (_finite(xtest[i])==0) {
			printf(" problem infinity in vector %s in position %d. size vector=%d\n",sname,i,n);
			getchar();
		}
	}
}

void isfinite_veci(int n, int* xtest, char* sname) {
	for (int i=0; i<n; i++) {
		if (_finite(xtest[i])==0) {
			printf(" problem infinity in vector %s in position %d. size vector=%d\n",sname,i,n);
			getchar();
		}
	}
}

// Граничное условие в граничном узле.
typedef struct TBONCONPOINT {
	// gamma*diff(Ф,n)=kappa*(Фinf-Ф)+qset - Общий вид граничного условия.
    // Параметры : gamma, kappa, Фinf, qset.
	// Задавая эти четыре вещественных числа можно смоделировать любое граничное условие.
	Real gamma, kappa, FI_inf, qset; 
	// некоторые условия не укладываются в эту схему.
	// например условие ток равен нулю.
	// поэтому специально для этого условия введём ещё пару коэффициентов.
	Real ap, ai; // коэффициент матрицы в граничном и ближайшем к граничному узле.
	// Если ap<0.0 то мы используем первый набор коэффициентов gamma, kappa, FI_inf, qset.
	// Но если ap >0.0 то мы используем второй набор коэффициентов, т.е. ap и ai.
} BONCONPOINT;

// Граничное условие на границе расчётной области.
typedef struct TBONCONDOMAIN {
	BONCONPOINT* left; // левая граница
	BONCONPOINT* right; // правая граница
	BONCONPOINT* top; // верхняя граница
	BONCONPOINT* bottom; // нижняя граница
} BONCONDOMAIN;



//Расчётная область для прибора 25мкм на 0.4мкм



Real lengthx = 1.0;// 0.03;// 0.03;// 1.0; // 36.735E-4; //102.0408e-4;//0.42;//1.0;//0.42  102.0408e-4; // длина области по оси x
Real lengthy = 1.0;// 0.03;// 0.03;// 1.0; // 7.3469E-4;//1.6326528e-4;//0.1;//1.0//0.1  1.2244896e-4; // высота области по оси y



#define q 5 // отношние шага грубой сетки к шагу подробной сетки.
//#define M (q*10-1) // количество линий сетки по горизонтали
//#define N (q*2-1) // количество линий сетки по вертикали
//#define M (q*15-1) // количество линий сетки по горизонтал
//#define N (q*4-1) // количество линий сетки по вертикали
//#define M (q*20-1) // количество линий сетки по горизонтали
//#define N (q*5-1) // количество линий сетки по вертикали
int M=(q*10-1); // количество линий сетки по горизонтали
int N=(q*10-1); // количество линий сетки по вертикали


// Вспомогательные данные для операции проецирования 
// с подробной сетки на грубую.
typedef struct TRESTRICT_AVG_S {
	// Только для q==5 и idist==2.
	Real Vol[5][5];
	Real SumVol;
	int ix[5][5];
	int iy[5][5];
} RESTRICT_AVG_S;


Real minf(Real ra, Real rb) {
	Real rmin=ra;
	if (rb<ra) rmin=rb;
	return rmin;
} // minf

Real maxf(Real ra, Real rb) {
	Real rmax=ra;
	if (rb>ra) rmax=rb;
	return rmax;
} // maxf


// экспорт полевой величины u в программу tecplot 360.
// полное тестирование производных.
void exporttecplottestgrad(Real** u, Real** ux, Real** uy, Real** uf, Real** uxf, Real** uyf,  Real** skv, Real* x, Real* y, int m, int n) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y unumerical uxnumerical uynumerical uanalittical uxanalittical uyanalittical skv\n");
		fprintf(fp,"zone\n");
		fprintf(fp,"I=%d, J=%d, K=1, F=POINT\n",m+2,n+2);
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   fprintf(fp,"%e %e %e %e %e %e %e %e %e\n",x[i],y[j],u[i][j],ux[i][j],uy[i][j],uf[i][j],uxf[i][j],uyf[i][j],skv[i][j]);
		fclose(fp);

		 WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT",SW_NORMAL);
	}

	getchar();

} // exporttecplottestgrad

// экспорт полевой величины u в программу tecplot 360.
void exporttecplot(Real** u, Real* x, Real* y, int m, int n) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y u\n");
		fprintf(fp,"zone\n");
		fprintf(fp,"I=%d, J=%d, K=1, F=POINT\n",m+2,n+2);
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   fprintf(fp,"%e %e %e\n",x[i],y[j],u[i][j]);
		fclose(fp);

		 WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT",SW_NORMAL);
	}

	getchar();

} // exporttecplot


// экспорт 3D полевой величины u в программу tecplot 360.
void exporttecplot3D(Real*** &u, Real* &x, Real* &y, Real* &z, int m, int n, int l) {
	FILE* fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s(&fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y z u\n");
		fprintf(fp, "zone\n");
		fprintf(fp, "I=%d, J=%d, K=%d, F=POINT\n", m + 2, n + 2, l + 2);
		for (int k = 0; k < l+2; k++) for (int j = 0; j < n + 2; j++) for (int i = 0; i < m + 2; i++)   fprintf(fp, "%e %e %e %e\n", x[i], y[j], z[k], u[i][j][k]);
		fclose(fp);

		WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT", SW_NORMAL);
	}

	//getchar();

} // exporttecplot3D


// экспорт 3D полевой величины u в программу tecplot 360.
void exporttecplot3D_fft(Real***& u, Real*& x, Real*& y, Real*& z, int m, int n, int l) {
	FILE* fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s(&fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y z u\n");
		fprintf(fp, "zone\n");
		fprintf(fp, "I=%d, J=%d, K=%d, F=POINT\n", m - 1, n -1, l + 2);
		for (int k = 0; k < l + 2; k++) for (int j = 1; j < n ; j++) for (int i = 1; i < m; i++)   fprintf(fp, "%e %e %e %e\n", x[i], y[j], z[k], u[i][j][k]);
		fclose(fp);

		WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT", SW_NORMAL);
	}

	//getchar();

} // exporttecplot3D_fft

// экспорт полевой величины u в программу tecplot 360.
void exporttecplot(Real** u, Real** etalon, Real* x, Real* y, int m, int n) {
	FILE* fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s(&fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y u etalon\n");
		fprintf(fp, "zone\n");
		fprintf(fp, "I=%d, J=%d, K=1, F=POINT\n", m + 2, n + 2);
		for (int j = 0; j < n + 2; j++) for (int i = 0; i < m + 2; i++)   fprintf(fp, "%e %e %e %e\n", x[i], y[j], u[i][j], etalon[i][j]);
		fclose(fp);

		WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT", SW_NORMAL);
	}

	getchar();

} // exporttecplot

// экспорт полевой величины u в программу tecplot 360.
// При решении уравнения конвекции - диффузии также сохраняется скорость (Vx, Vy).
void exporttecplot2(Real** u, Real** Vx, Real** Vy, Real* x, Real* y, int m, int n) {
	FILE* fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s(&fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y u vx vy mag_vel\n");
		fprintf(fp, "zone\n");
		fprintf(fp, "I=%d, J=%d, K=1, F=POINT\n", m + 2, n + 2);
		for (int j = 0; j < n + 2; j++) for (int i = 0; i < m + 2; i++)   fprintf(fp, "%e %e %e %e %e %e\n", x[i], y[j], u[i][j], Vx[i][j], Vy[i][j], sqrt(Vx[i][j]* Vx[i][j]+ Vy[i][j] * Vy[i][j]));
		fclose(fp);

		WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT", SW_NORMAL);
	}

	getchar();

} // exporttecplot2


// экспорт полевой величины u в программу tecplot 360.
void exporttecplotM(MATRNODE** &A, Real* x, Real* y, int m, int n) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y ap ae aw an as\n");
		fprintf(fp,"zone\n");
		fprintf(fp,"I=%d, J=%d, K=1, F=POINT\n",m+2,n+2);
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   fprintf(fp,"%e %e %e %e %e %e %e\n",x[i],y[j],A[i][j].ap,A[i][j].ae,A[i][j].aw,A[i][j].an,A[i][j].as);
		fclose(fp);

		 WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT",SW_NORMAL);
	}

	getchar();

} // exporttecplot

// экспорт полевой величины u в программу tecplot 360.
void exporttecplotx(Real** u, Real* x, Real* y, int m, int n) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y u\n");
		fprintf(fp,"zone\n");
		fprintf(fp,"I=%d, J=%d, K=1, F=POINT\n",m+1,n+2);
		for (int j=0; j<n+2; j++) for (int i=0; i<m+1; i++)   fprintf(fp,"%e %e %e\n",0.5*(x[i]+x[i+1]),y[j],u[i][j]);
		fclose(fp);

		 WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT",SW_NORMAL);
	}

	getchar();

} // exporttecplotx

// экспорт полевой величины u в программу tecplot 360.
void exporttecploty(Real** u, Real* x, Real* y, int m, int n) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y u\n");
		fprintf(fp,"zone\n");
		fprintf(fp,"I=%d, J=%d, K=1, F=POINT\n",m+2,n+1);
		for (int j=0; j<n+1; j++) for (int i=0; i<m+2; i++)   fprintf(fp,"%e %e %e\n",x[i],0.5*(y[j]+y[j+1]),u[i][j]);
		fclose(fp);

		 WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT",SW_NORMAL);
	}

	getchar();

} // exporttecploty


// экспорт полевой величины u в программу tecplot 360.
void exporttecplotMESFET(Real** u,Real** ex, Real** ey, Real** emag, Real** neg, Real** x_vel, Real** y_vel, Real** vel_mag, Real** curent_x, Real** curent_y, Real** curent_mag, Real* x, Real* y, int m, int n) {

	// Здесь будет осуществлён перевод из безразмерного представления
	// в общепринятое размерное.

	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x,cm y,cm potencial,V ex,V/cm ey,V/cm emag,V/cm electron_concentration,cm!-3  x-vel,cm/s y-vel,cm/s vel-mag,cm/s curent_x,A/cm^2 curent_y,A/cm^2 curent_mag,A/cm^2\n");
		fprintf(fp,"zone\n");
		fprintf(fp,"I=%d, J=%d, K=1, F=POINT\n",m+2,n+2);
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)  
		//	fprintf(fp,"%e %e %e %e %e %e %e %e %e %e %e %e %e\n",mscal*x[i],mscal*y[j], mpotencial*u[i][j],memag*ex[i][j], memag*ey[i][j], memag*emag[i][j], mni*neg[i][j],mvel*x_vel[i][j],mvel*y_vel[i][j],mvel*vel_mag[i][j],mcurrent*curent_x[i][j],mcurrent*curent_y[i][j], mcurrent*curent_mag[i][j]);
		    fprintf(fp,"%e %e %e %e %e %e %e %e %e %e %e %e %e\n",x[i],y[j], u[i][j],ex[i][j], ey[i][j], emag[i][j], neg[i][j], x_vel[i][j], y_vel[i][j], vel_mag[i][j], curent_x[i][j], curent_y[i][j], curent_mag[i][j]);
		fclose(fp);

		// WinExec("C:\\Program Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT",SW_NORMAL);
	}

	//getchar();

} // exporttecplotMESFET

// экспорт полевой величины u в программу tecplot 360.
void exporttecplotMESFET2(Real** u,Real** ex, Real** ey, Real** emag, Real** neg, Real** x_vel, Real** y_vel, Real** vel_mag, Real** curent_x, Real** curent_y, Real** curent_mag, Real* x, Real* y, int m, int n) {

	// Здесь будет осуществлён перевод из безразмерного представления
	// в общепринятое размерное.

	FILE *fp;
	errno_t err;
	// создание файла для записи.
	//if ((err = fopen_s( &fp, "./v1/fedorenko1.PLT", "w")) != 0) {
	if ((err = fopen_s(&fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp,"TITLE = \" Easy Drift Diffusion Model\" \n");
		fprintf(fp, "VARIABLES = x_cm, y_cm, potencial_V, ex_V/cm, ey_V/cm, emag_V/cm, electron_concentration_cm^-3,  x-vel_cm/s, y-vel_cm/s, vel-mag_cm/s, curent_x_A/cm^2, curent_y_A/cm^2, curent_mag_A/cm^2\n");
		fprintf(fp,"ZONE T=\"Rampant\", N=%d, E=%d, ET=QUADRILATERAL, F=FEBLOCK \n\n",(M+2)*(N+2),(M+1)*(N+1));
		
		int ic=0;
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",x[i]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",y[j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ", u[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ", ex[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",  ey[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",  emag[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   neg[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   x_vel[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   y_vel[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

        for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   vel_mag[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

         for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   curent_x[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		 for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   curent_y[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		 for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   curent_mag[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+1; j++) for (int i=0; i<m+1; i++) {
			fprintf(fp,"%d %d %d %d\n", (i+1)+j*(M+2), (i+2)+j*(M+2), (i+2)+(j+1)*(M+2), (i+1)+(j+1)*(M+2));
		}
				
		fclose(fp);

		// WinExec("C:\\Program Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT",SW_NORMAL)
		WinExec("C:\\Program\ Files\\Tecplot\\Tecplot\ 360\ EX\ 2014\ R1\\bin\\tec360.exe fedorenko1.PLT", SW_NORMAL);
	}

	//getchar();

} // exporttecplotMESFET2

// экспорт полевой величины u в программу tecplot 360.
void exporttecplotMESFET3(Real** u, Real** ex, Real** ey, Real** emag, Real** neg,
						  Real** x_vel, Real** y_vel, Real** vel_mag,
						  Real** curent_x, Real** curent_y, Real** curent_mag, 
						  Real* x, Real* y, int m, int n,
						  int maxnode, int maxelm, Real* xexport, Real *yexport,
						  int **nvtx_export, Real *uexport) {

	// Здесь будет осуществлён перевод из безразмерного представления
	// в общепринятое размерное.

	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "fedorenko1apendix.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {
		

		fprintf(fp,"TITLE = \" Easy Drift Diffusion Model\" \n");
		fprintf(fp, "VARIABLES = x_cm!, y_cm!, potencial_V!\n");
		fprintf(fp,"ZONE T=\"Rampant2\", N=%d, E=%d, ET=QUADRILATERAL, F=FEBLOCK \n\n",maxnode,maxelm);
		// xexport
		for (int i=0; i<maxnode; i++)  {
			fprintf(fp,"%e ",xexport[i]);
		
				if (i%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); 

		// yexport
		for (int i=0; i<maxnode; i++)  {
			fprintf(fp,"%e ",yexport[i]);
		
				if (i%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n");

		// uexport
		for (int i=0; i<maxnode; i++)  {
			fprintf(fp,"%e ",uexport[i]);
		
				if (i%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n");

		for (int i=0; i<maxelm; i++) {
			fprintf(fp,"%d %d %d %d \n",nvtx_export[0][i],nvtx_export[1][i],nvtx_export[2][i],nvtx_export[3][i]);
		}
				
		fclose(fp);

		// WinExec("C:\\Program Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT",SW_NORMAL);
	}

	//getchar();

} // exporttecplotMESFET3

// экспорт полевой величины u в программу tecplot 360.
void exporttecplotMESFET4(Real** u, Real** nu, Real energy_source, Real** kvasiFieldMag, Real taue, Real** ex, Real** ey, Real** emag, Real** neg, Real** x_vel, Real** y_vel, Real** vel_mag, Real** curent_x, Real** curent_y, Real** curent_mag, Real* x, Real* y, int m, int n) {

	// Здесь будет осуществлён перевод из безразмерного представления
	// в общепринятое размерное.

	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp,"TITLE = \" Easy Drift Diffusion Model\" \n");
		fprintf(fp, "VARIABLES = x_cm, y_cm, potencial_V, nu_Joule/cm3, energy_e_Joule, Te_K, kvasiField_V/cm, ex_V/cm, ey_V/cm, emag_V/cm, electron_concentration_cm^-3,  x-vel_cm/s, y-vel_cm/s, vel-mag_cm/s, curent_x_A/cm^2, curent_y_A/cm^2, curent_mag_A/cm^2\n");
		fprintf(fp,"ZONE T=\"Rampant\", N=%d, E=%d, ET=QUADRILATERAL, F=FEBLOCK \n\n",(M+2)*(N+2),(M+1)*(N+1));
		
		int ic=0;
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",x[i]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",y[j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		// электрический потенциал.
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ", u[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ", nu[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;


		// энергия электронного газа
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			if (fabs(neg[i][j])>1e-3) {
			    fprintf(fp,"%e ", energy_source+nu[i][j]/neg[i][j]);
			}
			else {
				// если нет свободных электронов то энергия равна энергии решетки.
                fprintf(fp,"%e ", energy_source);
			}
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		// температура электронного газа.
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			if (fabs(neg[i][j])>1e-3) {
			    fprintf(fp,"%e ", 2.0*(energy_source+nu[i][j]/neg[i][j])/(3.0*1.38066e-23));
			}
			else {
				// если нет свободных электронов то энергия равна энергии решетки.
				fprintf(fp,"%e ", 2.0*(energy_source)/(3.0*1.38066e-23));
			}
			ic++;
			if (ic%10==0) {
				fprintf(fp,"\n");
			}
		}
		fprintf(fp,"\n"); ic=0;

		
		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ", kvasiFieldMag[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ", ex[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",  ey[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",  emag[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   neg[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   x_vel[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   y_vel[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

        for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   vel_mag[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

         for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   curent_x[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		 for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   curent_y[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		 for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
			fprintf(fp,"%e ",   curent_mag[i][j]);
			ic++;
				if (ic%10==0) {
					fprintf(fp,"\n");
				}
		}
		fprintf(fp,"\n"); ic=0;

		for (int j=0; j<n+1; j++) for (int i=0; i<m+1; i++) {
			fprintf(fp,"%d %d %d %d\n", (i+1)+j*(M+2), (i+2)+j*(M+2), (i+2)+(j+1)*(M+2), (i+1)+(j+1)*(M+2));
		}
				
		fclose(fp);

		// WinExec("C:\\Program Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT",SW_NORMAL);
		 WinExec("C:\\Program\ Files\\Tecplot\\Tecplot\ 360\ EX\ 2014\ R1\\bin\\tec360.exe fedorenko1.PLT", SW_NORMAL);
	}

	//getchar();

} // exporttecplotMESFET4

// экспорт результата решения уравнений Нвье-Стокса
// в переменных вихрь-функция тока 
//  в программу tecplot 360.
void exporttecplotNSRoacheFedushkin(Real** curl, Real** stream_function, 
	                                Real** temperature,
	                                Real** u, Real** v, 
				                    Real* x, Real* y, int m, int n) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y curl stream_function temperature u v vel-mag\n");
		fprintf(fp,"zone\n");
		fprintf(fp,"I=%d, J=%d, K=1, F=POINT\n",m+2,n+2);
		for (int j=0; j<n+2; j++) {
			for (int i=0; i<m+2; i++) {
				fprintf(fp,"%e %e %e %e %e %e %e %e\n", x[i], y[j], curl[i][j], stream_function[i][j], temperature[i][j], u[i][j], v[i][j], sqrt(u[i][j]*u[i][j]+v[i][j]*v[i][j]));
			}
		}
		fclose(fp);
	}

	//getchar();

} // exporttecplotNSRoacheFedushkin

// экспорт результата решения уравнений Нвье-Стокса
// в переменных вихрь-функция тока 
//  в программу tecplot 360.
void exporttecplotJul(Real** curl, Real** stream_function, 
	                                Real** temperature, Real** concentration,
	                                Real** u, Real** v, 
				                    Real* x, Real* y, int m, int n) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y curl stream_function temperature concentration u v\n");
		fprintf(fp,"zone\n");
		fprintf(fp,"I=%d, J=%d, K=1, F=POINT\n",m+2,n+2);
		for (int j=0; j<n+2; j++) {
			for (int i=0; i<m+2; i++) {
				fprintf(fp,"%e %e %e %e %e %e %e %e\n", x[i], y[j], curl[i][j], stream_function[i][j], temperature[i][j], concentration[i][j], u[i][j], v[i][j]);
			}
		}
		fclose(fp);
	}

	//getchar();

} // exporttecplotJul

// Информация об установлении осреднённого вибрационного течения.
void exportmonitorpoint(Real u, Real v, Real curl, Real sf, Real temp, Real x, Real y, bool btitle) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "average_statistic.txt", "a")) != 0) {
		printf("Create File Error\n");
	}
	else {
		if (btitle) {
           fprintf(fp,"statistic Averaged over the vibrational in point x=%f, y=%f\n",x,y);
           fprintf(fp,"magnityde, x-vel, y-vel, curl, sf, temperature\n");
		}
		else {
		   fprintf(fp,"%e %e %e %e %e %e\n",sqrt(v*v+u*u),u,v,curl,sf,temp);
		}
		fclose(fp);
	}
} // exportmonitorpoint



// Информация об установлении осреднённого вибрационного течения.
// Симоненко Зиньковская.
void exportmonitorpointSZ(Real u, Real v, Real curl, Real sf, Real temp, Real x, Real y, bool btitle) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "Simonenko_Zinkovskaq_convergence_statistic.txt", "a")) != 0) {
		printf("Create File Error\n");
	}
	else {
		if (btitle) {
           fprintf(fp,"Simonenko Zinkovskaq statistic Averaged over the vibrational in point x=%f, y=%f\n",x,y);
           fprintf(fp,"magnityde, x-vel, y-vel, curl, sf, temperature\n");
		}
		else {
		   fprintf(fp,"%e %e %e %e %e %e\n",sqrt(v*v+u*u),u,v,curl,sf,temp);
		}
		fclose(fp);
	}
} // exportmonitorpointSZ








// структура данных для
  // формирования разреженной матрицы
  // в формате CRS для метода Сопряжённых Градиентов
  struct TmyNonZeroElemMatrix
  {
     // нужно хранить индексы
     // i,j определяющие местоположение
     // элемента в массиве
     int i;
     int j;
     // значение ненулевого элемента
     Real aij;
     // специальный ключ для упорядочивания
     // по строкам
     int key;
	 bool bNei; // признак начала однородного условия Неймана.
	 bool bugol;

  }; // TmyNonZeroElemMatrix

  // возвращает минимальное из двух целых чисел.
int imin(int ia, int ib) {
	if (ia<ib) {
		return ia;
	}
	else
	{
		return ib;
	}
}


// Для применения метода сопряжённых градиентов
// с использованием технологии
// хранения разреженной матрицы CRS
// потребуется реализация алгоритма быстрой сортировки

// Запрограммировано с использованием
// Брайан Керниган и Дени Ритчи "The C Programminfg Language".
// Swap : Обмен местами list[i] и list[j]
void Swap(TmyNonZeroElemMatrix* list,
                          int i,
                          int j)

{

   TmyNonZeroElemMatrix temp;

   // Если стек переполнен и отладчик остановился здесь на
   // строке begin, значит скрее всего быстрая сортировка Хоара
   // вызвала переполнение стека вложеннных вызовов.
   // Выход заменить её пирамидальной сортировкой.

   // cgange list[i] <-> list [j]

   // temp = list[i];
   temp.i=list[i].i;
   temp.j=list[i].j;
   temp.aij=list[i].aij;
   temp.key=list[i].key;
   // list[i] = list[j];
   list[i].i=list[j].i;
   list[i].j=list[j].j;
   list[i].aij=list[j].aij;
   list[i].key=list[j].key;
   // list[j] = temp;
   list[j].i=temp.i;
   list[j].j=temp.j;
   list[j].aij=temp.aij;
   list[j].key=temp.key;

} // Swap

// Вот алгоритм PivotList
// он возвращает точку деления элементов массива на две части.
// Запрограммировано с использованием книжки ДЖ. Макконел
// Анализ алгоритмов стр. 106.
int PivotList(TmyNonZeroElemMatrix* list,
                              int first,
                              int last) 
{
	int PivotValue;
	int PivotPoint; // возвращаемая позиция точки разделения
	int index;// счётчик цикла for

   // list обрабатываемый список
   // first номер первого элемента
   // last номер последнего элемента

   PivotValue = list[first].key;
   PivotPoint = first;

   for (index=(first+1); index<=last; index++)
   {
      if (list[index].key < PivotValue) 
	  {
         PivotPoint = PivotPoint + 1;
         Swap(list, PivotPoint, index);
	  }
   }

   Swap(list, first, PivotPoint);

   return PivotPoint;

} // PivotList

// Быстрая сортировка Хоара.
// Это рекурсивный алгоритм который эффективен по быстродействию
// но возможно не эффективен по памяти.
// Быстрая сортировка применяется здесь для упорядочивания достаточно больших
// массивов данных.
// Запрограммировано с использованием Дж. Макконел Анализ алгоритмов стр. 106.
void QuickSort(TmyNonZeroElemMatrix* list,
                              int first,
                              int last)
{
	int Pivot;

   // list упорядочиваемый список элементов
   // first номер первого элемента в сортируемой части списка
   // last номер последнего элемента в сортируемой части списка

   if (first < last) 
   {
      Pivot = PivotList(list, first, last);
      QuickSort(list, first, Pivot-1);
      QuickSort(list, Pivot+1, last);
   }

} // QuickSort

// Пирамидальная сортировка

// Переформировать пирамиду
void FixHeap(TmyNonZeroElemMatrix* list,
                          int root,
                          TmyNonZeroElemMatrix m,
                          int bound)
{
	int vacant;
	int largerChild;

   // list сортируемый список пирамида
   // root номер корня пирамиды
   // m ключевое значение вставляемое в пирамиду
   // bound правая граница (номер) в пирамиде
   vacant=root;
   while (2*vacant <= bound) 
   {
      largerChild=2*vacant;

      // поиск наибольшего из двух непосредственных потомков
      if ((largerChild<bound) && (list[largerChild+1].key>list[largerChild].key)) 
	  {
         largerChild=largerChild + 1;
      }

      // находится ли ключ выше текущего потомка ?
      if (m.key > list[largerChild].key) 
      {
         // да, цикл завершается
         break;
	  }
      else
	  {
         // нет, большего непосредственного потомка
         // следует поднять
         list[vacant].i=list[largerChild].i;
         list[vacant].j=list[largerChild].j;
         list[vacant].aij=list[largerChild].aij;
         list[vacant].key=list[largerChild].key;
         vacant=largerChild;
	  }
   }
   list[vacant].i=m.i;
   list[vacant].j=m.j;
   list[vacant].aij=m.aij;
   list[vacant].key=m.key;
} // FixHeap

// Пирамидальная сортировка оптимальна как
// по памяти, так и по быстродействию, к тому же её алгоритм
// очень интересен.
// Ограничение состоит в том, что нумерация массива должна начинаться с 1.
void HeapSort(TmyNonZeroElemMatrix *list, int n)
{

	int i; // счётчик
	TmyNonZeroElemMatrix maxelm; // элемент с наибольшим значением ключа

    // конструирование пирамиды
    for ( i=(n/2); i>=1; i--)
	{
       FixHeap(list, i, list[i], n);
	}
    for (i=n; i>=2; i--)
	{
       // скопировать корень пирамиды в список
       // переформировать пирамиду
       maxelm.i=list[1].i;
       maxelm.j=list[1].j;
       maxelm.aij=list[1].aij;
       maxelm.key=list[1].key;
       FixHeap(list, 1, list[i], i-1);
       list[i].i=maxelm.i;
       list[i].j=maxelm.j;
       list[i].aij=maxelm.aij;
       list[i].key=maxelm.key;
	}
} // HeapSort

// скалярное произведение двух векторов
Real Scal(int isize, Real *dV1,
                       Real *dV2)
{

   Real ds=0.0; // инициализация
   for ( int i=0; i<=(isize-1); i++)
   {
      ds+=  dV1[i]*dV2[i];
   }
   return ds;
} // Scal

// умножение матрицы на вектор
// используя формат хранения CRS
// Это эффективная процедура учитывающая разреженность матрицы СЛАУ.
// Запрограммировано с использованием
// 1. http://www.netlib.org/linalg/html_templates  "Survey of Sparse Matrix Storage Formats"
// 2. Р. Тьюарсон "Разреженные матрицы".
// Массивы передаются по ссылке дабы избежать переполнения стека.
void MatrixCRSByVector(int isize, // размерность вектора или квадратной матрицы
                                Real *val,  // ненулевые элементы матрицы
                                int *col_ind, // соответствующие им номера столбцов
                                int *row_ptr, // для определения начала следующей строки
                                Real *dV, // заданный вектор на который производится умножение
                                Real *dx)  // результат умножения заносится в dx.
{

   int i,j; // счётчики цикла for

   for (i=0; i<=(isize-1); i++)
   {
      dx[i]=0.0;

      for (j=row_ptr[i]; j<=(row_ptr[i+1]-1); j++) 
	  {
         dx[i]+= val[j]*dV[col_ind[j]];
	  }

   }

} // MatrixCRSByVector

// умножение транспонированной матрицы на вектор
// используя формат хранения CRS
// Это эффективная процедура учитывающая разреженность матрицы СЛАУ.
// Запрограммировано с использованием
// 1. http://www.netlib.org/linalg/html_templates  "Survey of Sparse Matrix Storage Formats"
// 2. Р. Тьюарсон "Разреженные матрицы".
void MatrixTransposeCRSByVector(int isize, // размерность вектора или квадратной матрицы
                                Real *val,  // ненулевые элементы матрицы
                                int  *col_ind, // соответствующие им номера столбцов
                                int *row_ptr, // для определения начала следующей строки
                                Real *dV, // заданный вектор на который производится умножение
                                Real *dx)  // результат умножения заносится в dx.
{

	int i,j; // счётчики цикла for

   for (i=0; i<=(isize-1); i++) dx[i]=0.0; // обнуление

   for (j=0; j<=(isize-1); j++)
   {

      for (i=row_ptr[j]; i<=(row_ptr[j+1]-1); i++)
	  {
         dx[col_ind[i]] += val[i]*dV[j];
	  }

   }

}  // MatrixTransposeCRSByVector

// норма вектора
// как корень квадратный из суммы квадратов
Real NormaV(int isize, Real *dV)
{
	int i; // счётчик цикла
	Real dnorma, dsum;

   // инициализация переменных
   dsum=0.0;
   for (i=0; i<=(isize-1); i++)
   {
      dsum+= dV[i]*dV[i];
   }
   dnorma=sqrt(dsum); // норма вектора
   return dnorma;
} // NormaV

/*
// возвращает максимальное из двух вещественых чисел.
Real maxf(Real da, Real db) {
	if (da>db) {
		return da;
	}
	else
	{
		return db;
	}
}
*/

// норма вектора
// как максимальное значение среди модулей компонент вектора
// кубическая норма.
Real NormaSupV(int isize,
                       Real *dV)
{
	int i; // счётчик цикла
	Real  dmax; // будущее значение нормы вектора

   // инициализация переменных
   dmax=-1.0; // отрицательное число
   for (i=0; i<=(isize-1); i++)
   {
      dmax= maxf(dmax, fabs(dV[i]));
   }
    // норма вектора
   return dmax;
} // NormaSupV

// норма вектора
// сумма модулей компонент вектора
// октаэдрическая норма.
Real NormaSup2V(int isize, Real *dV)
{
	int i; // счётчик цикла
	Real dsum; // будущее значение нормы вектора
   // инициализация переменных
   dsum=0.0; // обнуление сумматора
   for (i=0; i<=(isize-1); i++)
   {
      dsum+= fabs(dV[i]);
   }
    // норма вектора
   return dsum;
} // NormaSup2V

// Метод Сопряжённых градиентов
// Хестенса и Штифеля 1952 год.
// см. например, диссертацию Н.Г. Бураго  стр. 88.
// или Г.И. Марчук методы вычислительной математики
// здесь применена технология CRS хранения и обработки разреженной матрицы.
// Этот алгоритм подходит не только для SPD - Symmetric and Positively Defined матриц.
// SPD - Самосопряжённые и положительно определённые матрицы.
// В зависимости от значения передаваемого параметра bGaussTransform
// в нём примененяется или не применяется трансформация Гаусса.
// Трансформация Гаусса состоит в домножении СЛАУ на транспонированную матрицу слева,
// что позволяет из любой СЛАУ получить СЛАУ с положительно определённой самосопряжённой матрицей.
// Однако трансформация Гаусса сильно портит число обусловленности матрицы (спектр матрицы) возводя его в квадрат.
void SoprGradCRS(int isize, // размер квадратной матрицы
                          Real *val, // матрица СЛАУ
                          int *col_ind, // соответствующие ненулевым элементам номера столбцов
                          int *row_ptr, // информация о началах строк
                          Real *dV,  // вектор правой части
                          Real *dX0, // вектор начального приближения
                          Real *dres, // вектор результата
						  Real *residual_history, // история изменеия невязок
                          bool bconsole_message, // выводить ли значения невязки на консоль
                          int kend, // ограничение на максимальное количество итераций
                          bool bGaussTransform, // выполнять ли трансформацию Гаусса
                          Real epsilon,
						  int ibasenorma) // точность вычисления
{

	int i,k; // счётчики
	Real dar, dbr, dnz, dscalgg;

   // выделение памяти
   // под динамические массивы
   Real *dx=new Real[isize];  // искомое решение системы
   Real *dax=new Real[isize]; // результаты умножения
   Real *dap=new Real[isize]; // матрицы на вектор
   Real *dg=new Real[isize]; // вектор градиента
   Real *dp=new Real[isize]; // вектор сопряжённого направления поиска
   // для трансформации Гаусса
   Real *dbuf=new Real[isize]; // временное хранилище при выполнении трансформации Гаусса

   // начальное приближение
   // X0 ==
   // под вектором dX0 понимается вектор поля температур к примеру.
   for (i=0; i<=(isize-1); i++) dx[i]=dX0[i];

   // Первоначально без применения трансформации Гаусса.
   MatrixCRSByVector(isize, val, col_ind, row_ptr, dx, dax); // результат занесён в dax
   for (i=0; i<=(isize-1); i++) dg[i]= dV[i] - dax[i];  // начальная невязка

   if ( bGaussTransform) 
   {
      // Если трансформация Гаусса всё-же требуется.
      for (i=0; i<=(isize-1); i++) dbuf[i]= dg[i];  // временная копия начальной невязки
      MatrixTransposeCRSByVector(isize, val, col_ind, row_ptr, dbuf, dg); // результат занесён в dg:=At*dbuf;
   }

   if (Scal(isize, dg, dg) > 1.0e-30) 
   {
      for (i=0; i<=(isize-1); i++) dp[i]=dg[i]; // p0:=g0;
      k=0; // номер итерации
      dnz=1.0e+30; // начальное значение невязки (инициализация)
      while ((k < kend) && (dnz > epsilon)) 
	  {
         if ( bGaussTransform) 
		 {
            // выполняется трансформация Гаусса.
            MatrixCRSByVector(isize, val, col_ind, row_ptr, dp, dbuf); // результат занесён в dbuft1
            MatrixTransposeCRSByVector(isize, val, col_ind, row_ptr, dbuf, dap); // результат At*A*dp занесён в dap
		 }
         else
		 {
            // Трансформация Гаусса не выполняется.
            MatrixCRSByVector(isize, val, col_ind, row_ptr, dp, dap); // результат A*dp занесён в dap
		 }
         dscalgg= Scal(isize, dg, dg);
         dar =  dscalgg / Scal( isize, dap, dp);
         for (i=0; i<=(isize-1); i++)
		 {
            dx[i] = dx[i] + dar*dp[i];
            dg[i] = dg[i] - dar*dap[i];
		 }
         // здесь реализованы все три нормы
         // вообще говоря они все эквивалентны
         switch (ibasenorma)
		 {
            case 1 : dnz=NormaV(isize, dg); break; // евклидова
            case 2 : dnz=NormaSupV(isize, dg); break; // кубическая норма
            case 3 : dnz=NormaSup2V(isize, dg); break; // октаэдрическая норма
	     }
         
         if (bconsole_message) 
		 {
            // печать значения невязки на консоль
			residual_history[k]=dnz;
	     }
         dbr = Scal(isize, dg, dg) / dscalgg;
         for (i=0; i<=(isize-1); i++)
		 {
            dp[i] = dg[i] + dbr*dp[i];
         }
         k++; // переход к следующей итерации
         // если процесс расходится его надо остановить
         if (dnz > 1.0e+17) 
		 {
            // восстановление начального приближения
            for (i=0; i<=(isize-1); i++) dx[i]=dX0[i];
            //MainMemo.Lines.Add('вычислительный процесс расходится ');
            //Application.MessageBox('divergence SoprGrad solver ','',MB_OK);
			printf("divergence SoprGrad solver. Please, press any key to continue\n");
			getchar();
            break; // и останов процесса
		 }
	  }
      // возвращение результата
      for (i=0; i<=(isize-1); i++) dres[i]=dx[i];
   }
    else
   {
      // возвращает начальное приближение
      for (i=0; i<=(isize-1); i++) dres[i]=dX0[i];
   }

   // освобождение памяти выделенной под динамические массивы
   delete dx; // уточняемая величина в результате итерационного процесса
   delete dax; delete dap; // результаты умножения матрицы на вектор
   delete dg; delete dp; // векторы градиента и сопряжённого направления поиска.
   delete dbuf;

}  // SoprGradCRS






// Для генерации матрицы СЛАУ требуется в случае реализации
// на динамических массивах переупорядочивание элементов:
// сортировка. Здесь будет реализована быстрая сортировка.
// Брайан Керниган и Денис Ритчи "The C programminfg language".
// swap: Обмен местами v[i] и v[j]
void swapCSIR(int* &v, Real* &dr, int i, int j)
{
        int tempi;
		Real tempr;

		// change v[i] <-> v[j]
		tempi = v[i];
		v[i] = v[j];
		v[j] = tempi;
		// change dr[i] <-> dr[j]
		tempr = dr[i];
		dr[i] = dr[j];
		dr[j] = tempr;

} // swap

// Вот алгоритм PivotList
int PivotListCSIR(int* &jptr, Real* &altr, int first, int last) {
	// list==jptr and altr обрабатываемый список
	// first номер первого элемента
	// last номер последнего элемента

	int PivotValue = jptr[first];
	int PivotPoint = first;

	for (int index=(first+1); index<=last; index++) {
		if (jptr[index]<PivotValue) {
			PivotPoint++;
			swapCSIR(jptr, altr, PivotPoint, index);
		}
	}

	swapCSIR(jptr, altr, first, PivotPoint);

	return PivotPoint;
} // PivotList


// Быстрая сортировка Хоара.
// Запрограммировано с использованием ДЖ. Макконелл Анализ алгоритмов
// стр. 106.
void QuickSortCSIR(int* &jptr, Real* &altr, int first, int last) {
	// list упорядочиваемый список элементов
	// first номер первого элемента в сортируемой части списка
	// last номер последнего элемента в сортируемой части списка

	int pivot;

	if (first < last) {
        pivot = PivotListCSIR(jptr, altr, first, last);
        QuickSortCSIR(jptr, altr, first, pivot-1);
		QuickSortCSIR(jptr, altr, pivot+1, last);
	}
} // QuickSortCSIR

// Неполное разложение Холецкого
// для положительно определённой симметричной
// матрицы А размером nxn.
// n - размерность матрицы СЛАУ
// Матрица val изменяется и в ней возвращается
// неполное разложение Холецкого IC(0):
// val == U верхняя треугольная матрица
// A = transpose(U)*U=L*transpose(L);
// L=transpose(U);
// пример:
// A = 
// 9.0   0.0   0.0   3.0   1.0   0.0   1.0    
// 0.0   11.0   2.0   1.0   0.0   0.0   2.0    
// 0.0   2.0   10.0   2.0   0.0   0.0   0.0    
// 3.0   1.0   2.0   9.0   1.0   0.0   0.0    
// 1.0   0.0   0.0   1.0   12.0   0.0   1.0    
// 0.0   0.0   0.0   0.0   0.0   8.0   0.0    
// 1.0   2.0   0.0   0.0   1.0   0.0   8.0 
//формат CSIR_ITL (верхний треугольник хранится построчно).
// val : 9.0 3.0 1.0 1.0 11.0 2.0 1.0 2.0 10.0 2.0 9.0 1.0 12.0 1.0 8.0 8.0 
// indx: 0 3 4 6 1 2 3 6 2 3 3 4 4 6 5 6 
// pntr: 0 4 8 10 12 14 15 16 
//--------------------------------------------
// Результат факторизации без заполнения:
// изменённый массив val (indx и pntr остались без изменений):
// val (factorization)= 
// 3.0
// 1.0
// 0.3333333333333333
// 0.3333333333333333
// 3.3166247903554
// 0.6030226891555273
// 0.30151134457776363
// 0.6030226891555273
// 3.1622776601683795
// 0.6324555320336759
// 2.932575659723036
// 0.34099716973523675
// 3.4472773213410837
// 0.2578524458667825
// 2.8284271247461903
// 2.7310738989293286
//-------------------------------------------
void IC0Factor_ITL(Real* val, int* indx, int* pntr, int n)
{
  int d, g, h, i, j, k;
  Real z;

  for (k = 0; k < n - 1; k++) {
    d = pntr[k];
    z = val[d] = sqrt(val[d]);

    for (i = d + 1; i < pntr[k+1]; i++)
      val[i] /= z;

    for (i = d + 1; i < pntr[k+1]; i++) {
      z = val[i];
      h = indx[i];
      g = i;

      for (j = pntr[h] ; j < pntr[h+1]; j++)
        for ( ; g < pntr[k+1] && indx[g+1] <= indx[j]; g++)
          if (indx[g] == indx[j])
             val[j] -= z * val[g];
    }
  }
  d = pntr[n-1];
  val[d] = sqrt(val[d]);
} // IC0Factor_ITL


// Модифицированное неполное разложение Холецкого.
void IC0FactorModify_ITL(Real* val, int* indx, int* pntr, int n)
{
  int d, g, h, i, j, k;
  Real z, accumulate_fill_in;

  for (k = 0; k < n - 1; k++) {
    d = pntr[k];
	if (val[d]<=0.0) {
		printf("negative diagonal element in IC0FactorModify_ITL : string==%d elem==%d %e\n",k,d,val[d]);
		getchar();
	}
    z = val[d] = sqrt(val[d]);

    for (i = d + 1; i < pntr[k+1]; i++)
      val[i] /= z;

    for (i = d + 1; i < pntr[k+1]; i++) {
      z = val[i];
      h = indx[i];
      g = i;

      accumulate_fill_in = 0.0;

      for (j = pntr[h] ; j < pntr[h+1]; j++)
        for ( ; g < pntr[k+1] && indx[g+1] <= indx[j]; g++)
          if (indx[g] == indx[j]) // номера столбцов равны
             val[j] -= z * val[g];
	  else //index does not match accumulate the fill-in value
		  accumulate_fill_in += z * val[g];

	  val[pntr[h]] -= accumulate_fill_in;

    }
  }
  d = pntr[n-1];
  val[d] = sqrt(val[d]);
} // IC0FactorModify_ITL

// умножение симметричной положительно определённой  матрицы на вектор 
// используется формат хранения CSIR. В силу симметрии хранятся только поддиагональные элементы altr. 
// Разреженная SPD матрица A (adiag, altr, jptr, iptr) квадратная размером nxn.
// Число уравнений равно числу неизвестных и равно n.
// пример:
// A = 
// 9.0   0.0   0.0   3.0   1.0   0.0   1.0    
// 0.0   11.0   2.0   1.0   0.0   0.0   2.0    
// 0.0   2.0   10.0   2.0   0.0   0.0   0.0    
// 3.0   1.0   2.0   9.0   1.0   0.0   0.0    
// 1.0   0.0   0.0   1.0   12.0   0.0   1.0    
// 0.0   0.0   0.0   0.0   0.0   8.0   0.0    
// 1.0   2.0   0.0   0.0   1.0   0.0   8.0 
// ------------------------------------------
// формат CSIR:
// adiag: 9.0 11.0 10.0 9.0 12.0 8.0 8.0
// altr: 2.0 3.0 1.0 2.0 1.0 1.0 1.0 2.0 1.0
// jptr: 1 0 1 2 0 3 0 1 4
// iptr: 0 0 0 1 4 6 6 9
//-------------------------------------------
void  SPDMatrixCSIRByVector(Real* adiag, Real* altr, int* jptr, int* iptr, Real* V, Real* &tmp, int n)
{
	
	// вектор tmp индексируется начиная с нуля так же как и вектор V
	if (tmp == NULL)
	{
		printf("in SPDMatrixCSIRByVector tmp==NULL\n");
		getchar();
		tmp =new Real[n];
		if (tmp==NULL) {
			printf("malloc: out of memory for vector tmp in SPDMatrixCSIRByVector\n"); // нехватка памяти
		    getchar();
		   // exit(0); // завершение программы
		}
	}
	
	
    int i,j; // Счётчики цикла
    

	//omp_set_num_threads(inumcore);

    //#pragma omp parallel for shared(tmp, V, adiag) private(i) schedule (guided)
	for (i=0; i<n; i++) tmp[i]=V[i]*adiag[i];

    // Последовательная секция
	/*
	for (i=0; i<n; i++) {
	    for (j = iptr[i]; j<iptr[i+1]; j++)
		{
		    tmp[i] += V[jptr[j]]*altr[j];
		    tmp[jptr[j]] += V[i]*altr[j];
		}
	}
	*/
	
	// Часть первая из двух.
	//#pragma omp parallel for shared(tmp, V, altr, iptr, jptr,n) private(i,j) schedule (guided)
    for (i=0; i<n; i++) {
	    for (j = iptr[i]; j<iptr[i+1]; j++)
		{
		    tmp[i] += V[jptr[j]]*altr[j];
		}
	}

	// Вторая часть не поддаётся распараллеливанию
    for (i=0; i<n; i++) {
		

		// эта часть не поддаётся распараллеливанию.
        //#pragma omp parallel for shared(tmp, V, altr, i, iptr, jptr) private(j)
	    for (j = iptr[i]; j<iptr[i+1]; j++)
		{
			tmp[jptr[j]] += V[i]*altr[j];
			
		}
	}
	
} // SPDMatrixCSIRByVector


// Прямой ход по разреженной нижнетреугольной матрице L.
// симметричная положительно определённая матрица
// СЛАУ A представлена неполным разложением Холецкого 
// A~=L*transpose(L); L - нижняя треугольная матрица.
// L - хранится в следующем виде:
// 1. val - диагональные и поддиагональные элементы L.
// в столбцовом порядке. 
// 3. indx - соотвествующие номера строк для val, 
// 4. pntr - информация о начале следующего столбца.
// f - вектор правой части размером nodes.
// возвращает вектор z=inverse(L)*f;
// Вектор f портится.
// пример (CSIR - формат):
//  L = 
//  9.0   0.0   0.0   0.0   0.0   0.0   0.0   
//  0.0   11.0   0.0   0.0   0.0   0.0   0.0   
//  0.0   2.0   10.0   0.0   0.0   0.0   0.0   
//  3.0   1.0   2.0   9.0   0.0   0.0   0.0   
//  1.0   0.0   0.0   1.0   12.0   0.0   0.0   
//  0.0   0.0   0.0   0.0   0.0   8.0   0.0   
//  1.0   2.0   0.0   0.0   1.0   0.0   8.0   
// ------------------------------------------
// val: 9.0 3.0 1.0 1.0 11.0 2.0 1.0 2.0 10.0 2.0 9.0 1.0 12.0 1.0 8.0 8.0
// indx: 0 3 4 6 1 2 3 6 2 3 3 4 4 6 5 6
// pntr: 0 4 8 10 12 14 15 16
//-------------------------------------------
void inverseL_ITL(Real* f, Real* val, int* indx, int* pntr, Real* &z, int n) {
	
	// Real **fbuf;
	// набор векторов fbuf нужен только в параллельной версии, в серийной версии можно просто передавать NULL.
	// количество векторов в fbuf равно количеству потоков.

    if (z == NULL)
	{
		Real *z=new Real[n];
		if (z==NULL) {
			printf("malloc: out of memory for vector z in inverse(L)*f \n"); // нехватка памяти
		    getchar();
		    //exit(0); // завершение программы
		}
	}

	//bool bserial=true;

	//if (bserial) {
		// однопоточное исполнение.

	    int i,j;
	    for (i=0; i<n; i++) {
            z[i]=f[i]/val[pntr[i]];
		    // обработка i-го столбца
		    // эта часть не поддаётся распараллеливанию.
            // из за зависимостей по данным для f.
		    for (j=pntr[i]+1; j<pntr[i+1]; j++) {
			    f[indx[j]]-=z[i]*val[j];
		    }
		
	    }
		/*

	}
	else {
		// параллельное исполнение.
		// параллельный код требует правильного разрешения зависимостей по данным.

		// Нам понадобиться 
		// n=omp_get_num_threads(); 
		// дополнительных векторов.

		int nt=0;
#pragma omp parallel shared(nt)
		{
			// число нитей.
			nt=omp_get_num_threads();
		}

		int i,j;

		for (i=0; i<nt; i++) {
			for (j=0; j<n; j++) {
				fbuf[i][j]=0.0; // инициализация.
			}
		}

#pragma omp for  shared(n, z, val, f, fbuf, pntr, indx, fbuf) 
		for (i=0; i<n; i++) {
		   // Проблема в том что здесь используется f[i] а оно может быть обновлённым, что здесь не учитывается !!!
            z[i]=f[i]/val[pntr[i]];
		    // обработка i-го столбца
		    // эта часть не поддаётся распараллеливанию.
            // из за зависимостей по данным для f.
		    for (j=pntr[i]+1; j<pntr[i+1]; j++) {
			    fbuf[omp_get_thread_num()][indx[j]]-=z[i]*val[j];
		    }
		
	    }

	}
	*/
}//inverseL_ITL

// Обратный ход по разреженной верхнетреугольной матрице U.
// симметричная положительно определённая матрица
// СЛАУ A представлена неполным разложением Холецкого 
// A~=L*transpose(L); L - нижняя треугольная матрица.
// U=transpose(L); - верхняя треугольная матрица.
// U - хранится в следующем виде:
// 1. val - диагональные и наддиагональные элементы U (в строковом формате).
// 2. indx - соотвествующие номера столбцов, 
// 3. pntr - информация о начале следующей строки для val.
// f - вектор правой части размером nodes.
// возвращает вектор z=inverse(U)*f;
// Вектор f портится.
// пример (CSIR_ITL - формат):
//  U=transpose(L) = 
//  9.0   0.0   0.0   3.0   1.0   0.0   1.0   
//  0.0   11.0   2.0   1.0   0.0   0.0   2.0   
//  0.0   0.0   10.0   2.0   0.0   0.0   0.0   
//  0.0   0.0   0.0   9.0   1.0   0.0   0.0   
//  0.0   0.0   0.0   0.0   12.0   0.0   1.0   
//  0.0   0.0   0.0   0.0   0.0   8.0   0.0   
//  0.0   0.0   0.0   0.0   0.0   0.0   8.0 
// ------------------------------------------
// val: 9.0 3.0 1.0 1.0 11.0 2.0 1.0 2.0 10.0 2.0 9.0 1.0 12.0 1.0 8.0 8.0
// indx: 0 3 4 6 1 2 3 6 2 3 3 4 4 6 5 6
// pntr: 0 4 8 10 12 14 15 16
//-------------------------------------------
void inverseU_ITL(Real* f, Real* val, int* indx, int* pntr, Real* &z, int n) {

    if (z == NULL)
	{
		z = new Real[n];
		if (z==NULL) {
			printf("malloc: out of memory for vector z in inverse(U)*f \n"); // нехватка памяти
		    getchar();
		    //exit(0); // завершение программы
		}
	}

	int i,j;

	for (i=(n-1); i>=0; i--) {
        
		// Обработка i-ой строки:
		// эта часть не поддаётся распараллеливанию.
		//#pragma omp parallel for shared(f, indx, z, val, i, pntr) private(j)
		for (j=pntr[i]+1; j<pntr[i+1]; j++) {
			f[i]-=z[indx[j]]*val[j];
		}
		// делим на диагональный элемент:
        z[i]=f[i]/val[pntr[i]];
		
	}
	
}//inverseU_ITL


// Метод Сопряжённых градиентов
// Хестенса и Штифеля 1952 год.
// см. например, диссертацию Н.Г. Бураго  стр. 88.
// или Г.И. Марчук методы вычислительной математики
// здесь применена технология CSIR хранения и обработки разреженной матрицы.
// Этот алгоритм подходит только для SPD - Symmetric and Positively Defined матриц.
// SPD - Самосопряжённые и положительно определённые матрицы.
void SoprGradCSIR(int isize, // размер квадратной матрицы
	Real* adiag, Real* altr, int* jptr, int* iptr, // Матрица СЛАУ в CSIR формате.
	Real* val1, int* col_ind, int* row_ptr,
	Real* dV,  // вектор правой части
	Real* dX0, // вектор начального приближения
	Real* dres, // вектор результата
	Real* residual_history, // история изменеия невязок
	bool bconsole_message, // выводить ли значения невязки на консоль
	int kend, // ограничение на максимальное количество итераций
	Real epsilon,
	int ibasenorma) // точность вычисления
{

	int i, k; // счётчики
	Real dar, dbr, dnz, dscalgg;

	// выделение памяти
	// под динамические массивы
	Real* dx = new Real[isize];  // искомое решение системы
	Real* dax = new Real[isize]; // результаты умножения
	Real* dap = new Real[isize]; // матрицы на вектор
	Real* dg = new Real[isize]; // вектор градиента
	Real* dp = new Real[isize]; // вектор сопряжённого направления поиска
	// для трансформации Гаусса
	Real* dbuf = new Real[isize]; // временное хранилище при выполнении трансформации Гаусса

	// начальное приближение
	// X0 ==
	// под вектором dX0 понимается вектор поля температур к примеру.
	for (i = 0; i <= (isize - 1); i++) dx[i] = dX0[i];

	// Первоначально без применения трансформации Гаусса.
	MatrixCRSByVector(isize, val1, col_ind, row_ptr, dx, dax); // результат занесён в dax
	//SPDMatrixCSIRByVector(adiag, altr, jptr, iptr, dx, dax, isize); // результат занесён в dax
	for (i = 0; i <= (isize - 1); i++) dg[i] = dV[i] - dax[i];  // начальная невязка


	if (Scal(isize, dg, dg) > 1.0e-30)
	{
		for (i = 0; i <= (isize - 1); i++) dp[i] = dg[i]; // p0:=g0;
		k = 0; // номер итерации
		dnz = 1.0e+30; // начальное значение невязки (инициализация)
		while ((k < kend) && (dnz > epsilon))
		{

			// Трансформация Гаусса не выполняется.
			MatrixCRSByVector(isize, val1, col_ind, row_ptr, dp, dap); // результат A*dp занесён в dap
			//SPDMatrixCSIRByVector(adiag, altr, jptr, iptr, dp, dap, isize); // результат занесён в dax

			dscalgg = Scal(isize, dg, dg);
			dar = dscalgg / Scal(isize, dap, dp);
			for (i = 0; i <= (isize - 1); i++)
			{
				dx[i] = dx[i] + dar * dp[i];
				dg[i] = dg[i] - dar * dap[i];
			}
			// здесь реализованы все три нормы
			// вообще говоря они все эквивалентны
			switch (ibasenorma)
			{
			case 1: dnz = NormaV(isize, dg); break; // евклидова
			case 2: dnz = NormaSupV(isize, dg); break; // кубическая норма
			case 3: dnz = NormaSup2V(isize, dg); break; // октаэдрическая норма
			}

			if (bconsole_message)
			{
				// печать значения невязки на консоль
				residual_history[k] = dnz;
			}
			dbr = Scal(isize, dg, dg) / dscalgg;
			for (i = 0; i <= (isize - 1); i++)
			{
				dp[i] = dg[i] + dbr * dp[i];
			}
			k++; // переход к следующей итерации
			// если процесс расходится его надо остановить
			if (dnz > 1.0e+17)
			{
				// восстановление начального приближения
				for (i = 0; i <= (isize - 1); i++) dx[i] = dX0[i];
				//MainMemo.Lines.Add('вычислительный процесс расходится ');
				//Application.MessageBox('divergence SoprGrad solver ','',MB_OK);
				printf("divergence SoprGrad solver. Please, press any key to continue\n");
				getchar();
				break; // и останов процесса
			}
		}
		// возвращение результата
		for (i = 0; i <= (isize - 1); i++) dres[i] = dx[i];
	}
	else
	{
		//std::cout << "ne bjlo vjchislenii\n";
		//getchar();
		// возвращает начальное приближение
		for (i = 0; i <= (isize - 1); i++) dres[i] = dX0[i];
	}

	// освобождение памяти выделенной под динамические массивы
	delete dx; // уточняемая величина в результате итерационного процесса
	delete dax; delete dap; // результаты умножения матрицы на вектор
	delete dg; delete dp; // векторы градиента и сопряжённого направления поиска.
	delete dbuf;

}  // SoprGradCRS


/* Метод сопряжённых градиентов Хестенса и Штифеля [1952]
*  Входные параметры:
*  M - разреженная матрица СЛАУ в формате SIMPLESPARSE,
*  dV - вектор правой части, 
*  x - начальное приближение к решению или NULL.
*  n - размерность СЛАУ An*n.
*
*  Разреженная матрица M квадратная размером nxn.
*  Число уравнений равно числу неизвестных и равно n.
*  Матрица M предполагается положительно определённой и 
*  симметричной (диагональное преобладание присутствует).
*  Хранятся только ненулевые элементы. 
*  Количество итераций ограничено 1000, т.к. предполагается,
*  что если решение не сошлось за 1000 итераций то оно и не сойдётся.
*  Точность выхода по невязке задаётся в глобальной константе:
*  dterminfatedTResudual.
*  В качестве предобуславливателя работает неполное разложение Холецкого:
*  K^(-1)==transpose(L)^(-1)*L^(-1); // обращённый предобуславливатель.
* 
*  Удалось частично распараллелить, так что 4 ядерный процессор загружен на 54%
*  К сожалению, некоторые операции не поддаются распараллеливанию.
*
*  Внимание. для того чтобы включить предобуславливатель нужно раскоментировать 
* коментарии с маркером М.
*/
void ICCG(Real *adiag, Real *altr, int *jptr, int *iptr,
	      Real* val1, int* col_ind1, int* row_ptr1,
	      Real* val2, int* col_ind2, int* row_ptr2,
		  Real *val, int *indx, int *pntr,
		  Real *dV, Real* &x, int n, bool bprintmessage, int maxiter, Real eps,
		  Real *residual_history)
{

	// если bdistwall==true то решается СЛАУ для нахождения кратчайшего расстояния до стенки.

	Real dsize=(Real)(1.0*n); // вещественная длина вектора

	int k=0;
	int i; // счётчик
	Real *ap=new Real[n], *vcopy=new Real[n], *f=new Real[n];
	Real *z=new Real[n], *p=new Real[n];
    Real a, b, res, dbuf;
	

	Real dold, dnew;

	// неполное разложение Холецкого:
	// Возвращает левый нижний треугольный сомножитель.
	if (bprintmessage) {
		printf("Incoplete Cholesky decomposition beginig...:\n");
	}
	IC0Factor_ITL(val, indx, pntr, n);
	//IC0FactorModify_ITL(val, indx, pntr, n);

	//IC0FactorModify_ITL(val2, col_ind2, row_ptr2, n);
	//isfinite_vec(pntr[n], val, "IC0FactorModify_ITL : val :");
	if (bprintmessage) {
		printf("Incoplete Cholesky decomposition finish...:\n");//*/
	}
	getchar();

	// шаг 1.1
	//X0==
	if (x==NULL) {
        x=new Real[n];
		for(i=0;i<n;i++) x[i] = 0.0;
	}

	// пороговое значение невязки
	Real e = eps;
	
	// шаг 1.2
    // вычисление z - невязки начального приближения
	//SPDMatrixCSIRByVector(adiag, altr, jptr, iptr, x, ap, n);
	MatrixCRSByVector(n, val1, col_ind1, row_ptr1, x, ap); // результат занесён в ap
	for (i=0; i<n; i++) z[i]=dV[i]-ap[i];
	for (i=0; i<n; i++) vcopy[i]=z[i]; 
    inverseL_ITL(vcopy, val, indx, pntr, f, n);
	//inverseL_ITL(vcopy, val2, col_ind2, row_ptr2, f, n);
    for (i=0; i<n; i++) vcopy[i]=f[i];  
	inverseU_ITL(vcopy, val, indx, pntr, f, n);
	//inverseU_ITL(vcopy, val2, col_ind2, row_ptr2, f, n);
    dnew=Scal(n,z,f);
	//dnew=sqrt(dnew)/dsize; // среднеквадратическая эту трогат нельзя она завязана на вычислительный процесс.

	
	// терминаьная невязка всегда на точность аппроксимации меньше стартовой невязки.
	//if (e*dnew<e) e*=dnew;
	//Real me=sqrt(dnew)/dsize;
	//if (e*me<e) e*=me;
	//dterminfatedTResudual=e;
	
	
	printf("dnew=%1.4f\n",fabs(dnew));
	getchar();
	if (fabs(dnew) > e) {
	//if (fabs(me) > e) {

		// шаг 1.3
	   for (i=0; i<n; i++)	p[i]=f[i];
	   res=1000.;
	   while ((fabs(res)>e) && (k<maxiter)) {
		   // шаг 2.1
		  //SPDMatrixCSIRByVector(adiag, altr, jptr, iptr, p, ap, n);
		 MatrixCRSByVector(n, val1, col_ind1, row_ptr1, p, ap); // результат занесён в ap

		  // шаг 2.2
		  a=dnew/Scal(n,p,ap);// шаговый множитель
		  // шаг 2.3 и 2.4
          //#pragma omp parallel for shared(x,z,p,ap,a,n) private(i) schedule (guided)
		  for (i=0; i<n; i++) {
		      x[i]+=a*p[i]; // очередное приближение 
              z[i]-=a*ap[i];// невязка k+1-го приближения
		  }
          //#pragma omp parallel for shared(vcopy,z,n) private(i) schedule (guided)
          for (i=0; i<n; i++) vcopy[i]=z[i];  
          inverseL_ITL(vcopy, val, indx, pntr, f, n);
		  //inverseL_ITL(vcopy, val2, col_ind2, row_ptr2, f, n);
          //#pragma omp parallel for shared(vcopy,f,n) private(i) schedule (guided)
          for (i=0; i<n; i++) vcopy[i]=f[i]; 
	      inverseU_ITL(vcopy, val, indx, pntr, f, n);
		  //inverseU_ITL(vcopy, val2, col_ind2, row_ptr2, f, n);
		  // шаг 2.5
          dold=dnew;
		  dnew=Scal(n,z,f);

		  residual_history[k]=sqrt(n*dnew);

		  res=dnew; // исходный код.
		  //res=sqrt(dnew)/dsize;
		  if (bprintmessage) {
			  if (k%10==0) {
				  printf("iter residual\n");
			  }
		      printf(" %d %e\n", k, res);
			  getchar();
		  }
		  // шаг 3.1
		  b=dnew/dold;
		  // шаг 3.2

          //#pragma omp parallel for shared(p,f,b,n) private(i,dbuf) schedule (guided)
		  for (i=0; i<n; i++) {
			 dbuf=p[i];
		     p[i]=f[i]+b*dbuf; // новое направление минимизации
		  }
          // шаг 3.3
		  k++;
	   } // while

	   for (int i=k; i<maxiter; i++) residual_history[i]=0.0;

	   // В этот файл пишется статистика об успешности решения СЛАУ:
       //fprintf(fp_statistic_convergence, " ICCG finish residual=%e \n",res);
       //fprintf(fp_statistic_convergence,"%e ",res); // нет смысла печатать конечную невязку так как она задана пользователем

	   // Освобождение памяти
        delete ap; delete vcopy;
		delete z; delete p; delete f;  
	}
	else {
		// Освобождение памяти
		//printf("ICCG inform: residual of the initial approximation is too small...\n");
		
		//fprintf(fp_statistic_convergence, " ICCG no solve start residual < %e \n",e);
		//fprintf(fp_statistic_convergence,"%e ",e); // нет смысла печатать конечную невязку так как она задана пользователем
		delete ap; delete vcopy;
		delete z; delete p; delete f;		
	}

}
	

// Метод Ван Дер Ворста Bi-CGStabCRS
// работает для возможно несимметричных вещественных матриц.
// Несимметричная матрица СЛАУ передаётся в CRS формате
// A (val, col_ind, row_ptr).
// Метод является комбинацией методов BiCG и GMRES(1). 
void Bi_CGStabCRS(int n, Real *val, int* col_ind, int* row_ptr, Real *dV, Real* &dX0, Real* &dxret, int maxit,
				  Real dterminfatedTResudual, int ibasenorma, Real *residual_history)
{

	// dxret - возвращаемое решение !!!

	int iflag=1, icount=0;
	Real delta0, deltai;
	Real bet, roi;
	Real roim1=1.0, al=1.0, wi=1.0;
	Real *ri, *roc, *s, *t, *vi, *pi, *dx, *dax;
	Real epsilon=dterminfatedTResudual;  // точность вычисления
    //printf("%e\n",epsilon); // контрольное значение невязки по которой осуществляется выход из итерационного процесса.
    //getchar();
	int i;

	ri=new Real[n]; roc=new Real[n]; s=new Real[n]; t=new Real[n];
	vi=new Real[n]; pi=new Real[n]; dx=new Real[n]; dax=new Real[n];

	for (i=0; i<n; i++) {
		s[i]=0.0;
		t[i]=0.0;
		vi[i]=0.0;
		pi[i]=0.0;
	}

    // начальное приближение
    // X0 ==
    // под X0 понимается вектор поля температур к примеру.
    if (dX0==NULL) {
	   dX0=new Real[n];
	   for (i=0; i<n; i++) {
		   dx[i]=0.0;
		   dX0[i]=0.0;
	   }
    }
    else {
	   for (i=0; i<n; i++) dx[i]=dX0[i];
    }

    MatrixCRSByVector(n,val,col_ind,row_ptr,dx,dax); // результат занесён в  dax
	for (i=0; i<n; i++) {
		ri[i]=dV[i]-dax[i];
		roc[i]=ri[i];
	}
	 switch (ibasenorma)
	{
            case 1 : delta0=NormaV(n, ri); break; // евклидова
            case 2 : delta0=NormaSupV(n, ri); break; // кубическая норма
            case 3 : delta0=NormaSup2V(n, ri); break; // октаэдрическая норма
	 }
	// Если решение сразу хорошее то не считать:
	if (fabs(delta0)<epsilon) iflag=0; 

	while ( iflag != 0 && icount < maxit) {

		icount++;

		roi=Scal(n,roc,ri);
		bet=(roi/roim1)*(al/wi);
		//intel//#pragma omp parallel for shared(n,pi,ri,vi,wi,bet) private(i) schedule (guided)
		for (i=0; i<n; i++) {
			pi[i]=ri[i]+(pi[i]-vi[i]*wi)*bet;
		}
	
		MatrixCRSByVector(n,val,col_ind,row_ptr,pi,vi);
		al=roi/Scal(n,roc,vi);
		//intel//#pragma omp parallel for shared(n,s,ri,vi,al) private(i) schedule (guided)
        for (i=0; i<n; i++) {
			s[i]=ri[i]-al*vi[i];
		}
		
        MatrixCRSByVector(n,val,col_ind,row_ptr,s,t);
		wi=Scal(n,t,s)/Scal(n,t,t);
		//intel//#pragma omp parallel for shared(n,dx,al,pi,wi,s,ri,t) private(i) schedule (guided)
		for (i=0; i<n; i++) {
			dx[i]+=al*pi[i]+wi*s[i];
			ri[i]=s[i]-wi*t[i];
		}
		// здесь реализованы все три нормы
         // вообще говоря они все эквивалентны
         switch (ibasenorma)
		 {
            case 1 : deltai=NormaV(n, ri); break; // евклидова
            case 2 : deltai=NormaSupV(n, ri); break; // кубическая норма
            case 3 : deltai=NormaSup2V(n, ri); break; // октаэдрическая норма
	     }
		// печать невязки на консоль
        //if ((icount % 10) == 0)  printf("iter  residual\n");
        //printf("%d %e \n",icount,deltai);
		 residual_history[icount-1]=deltai;
        // информация о сходимости печатается в файл log.txt связанный с маркером файла fp_log.
        //fprintf(fp_log,"%d %e \n",icount,deltai);
        //if ((icount % 100)== 0) getchar();

		if (deltai <epsilon) iflag=0; // конец вычисления
		else roim1=roi;
	}

    // освобождение памяти
	delete ri; delete roc; delete s; delete t;
	delete vi; delete pi; delete dax;

	for (i=0; i<n; i++) {
		dX0[i]=dx[i];
		dxret[i]=dx[i];
	}

	delete dx; 


} // Bi_CGStabCRS


// 13 сентября 2017 года.
  //*****************************************************************
  // Iterative template routine -- GMRES
  //
  // GMRES solves the unsymmetric linear system Ax = b using the 
  // Generalized Minimum Residual method
  //
  // GMRES follows the algorithm described on p. 20 of the 
  // SIAM Templates book.
  //
  // The return value indicates convergence within max_iter (input)
  // iterations (0), or no convergence within max_iter iterations (1).
  //
  // Upon successful return, output arguments have the following values:
  //  
  //    dxret  --  approximate solution to Ax = b
  //    maxit  --  the number of iterations performed before the
  //               tolerance was reached
  //      dterminfatedTResudual  --  the residual after the final iteration
  //  
  //*****************************************************************


void Update(Real* &x, int k, int n, Real** &h, Real* &s, Real** &v)
{
	//Vector y(s);
	Real* y = new Real[k+1];
	for (int i_1 = 0; i_1 <= k; i_1++) y[i_1] = s[i_1];

	// Backsolve:  
	for (int i = k; i >= 0; i--) {
		y[i] /= h[i][i];
		for (int j = i - 1; j >= 0; j--)
			y[j] -= h[j][i] * y[i];
	}

	for (int j = 0; j <= k; j++) {
		for (int j_1 = 0; j_1 < n; j_1++) {
			x[j_1] += v[j][j_1] * y[j];
		}
	}
		

	delete[] y;
	y = NULL;
}

void GeneratePlaneRotation(Real &dx, Real &dy, Real &cs, Real &sn)
{
	if (fabs(dy) < 1.0e-30) {
		cs = 1.0;
		sn = 0.0;
	}
	else if (fabs(dy) > fabs(dx)) {
		Real temp = dx / dy;
		sn = 1.0 / sqrt(1.0 + temp*temp);
		cs = temp * sn;
	}
	else {
		Real temp = dy / dx;
		cs = 1.0 / sqrt(1.0 + temp*temp);
		sn = temp * cs;
	}
}


void ApplyPlaneRotation(Real &dx, Real &dy, Real &cs, Real &sn)
{
	Real temp = cs * dx + sn * dy;
	dy = -sn * dx + cs * dy;
	dx = temp;
}


int  gmres(int n, Real *val, int* col_ind, int* row_ptr, Real *dV, Real* &dX0, Real* &dxret, int maxit,
	Real dterminfatedTResudual, int ibasenorma, Real *residual_history, int &m) {

	Real resid;
	int i, j = 1, k;
	//Vector s(m + 1), cs(m + 1), sn(m + 1), w;
	Real* w=new Real[n];
	Real* s = new Real[m + 2];
	Real* cs = new Real[m + 2];
	Real* sn = new Real[m + 2];

	Real *dx = new Real[n];

	// начальное приближение
	// X0 ==
	// под X0 понимается вектор поля температур к примеру.
	if (dX0 == NULL) {
		dX0 = new Real[n];
		for (i = 0; i<n; i++) {
			dx[i] = 0.0;
			dX0[i] = 0.0;
		}
	}
	else {
		for (i = 0; i<n; i++) dx[i] = dX0[i];
	}

	//Real normb = norm(M.solve(b));
	Real normb = 0.0;
	// здесь реализованы все три нормы
	// вообще говоря они все эквивалентны
	switch (ibasenorma)
	{
	case 1: normb = NormaV(n, dV); break; // евклидова
	case 2: normb = NormaSupV(n, dV); break; // кубическая норма
	case 3: normb = NormaSup2V(n, dV); break; // октаэдрическая норма
	}
	
	//Vector r = M.solve(dV - A * x);
	Real *r = new Real[n];
	MatrixCRSByVector(n, val, col_ind, row_ptr, dx, r);
	for (i = 0; i < n; i++) r[i] = dV[i] - r[i];

	//Real beta = norm(r);
	Real beta = 0.0;
	switch (ibasenorma)
	{
	case 1: beta = NormaV(n, r); break; // евклидова
	case 2: beta = NormaSupV(n, r); break; // кубическая норма
	case 3: beta = NormaSup2V(n, r); break; // октаэдрическая норма
	}

	if (fabs(normb) < 1.0e-30)
		normb = 1;

	Real norm_r = 0.0;
	switch (ibasenorma)
	{
	case 1: norm_r = NormaV(n, r); break; // евклидова
	case 2: norm_r = NormaSupV(n, r); break; // кубическая норма
	case 3: norm_r = NormaSup2V(n, r); break; // октаэдрическая норма
	}

	if ((resid = norm_r / normb) <= dterminfatedTResudual) {
		//tol = resid;
		maxit = 0;
		return 0;
	}

	Real** H = new Real*[m + 2]; // Hessenberg
	for (int i_1 = 0; i_1 < m + 2; i_1++) H[i_1] = new Real[m + 2];
	for (int i_1 = 0; i_1 < m + 2; i_1++)
	{
		for (int j_1 = 0; j_1 < m + 2; j_1++)
		{
			H[i_1][j_1] = 0.0;
		}
	}

	//Vector *v = new Vector[m + 1];
	Real** v = new Real*[m + 2];
	for (int i_1 = 0; i_1 <= m + 1; i_1++) v[i_1] = new Real[n];
	for (int i_1 = 0; i_1 <= m + 1; i_1++) {
		for (int j_1 = 0; j_1 < n; j_1++)
		{
			v[i_1][j_1] = 0.0;
		}
	}

	while (j <= maxit) {

		//v[0] = r * (1.0 / beta);    // ??? r / beta
		for (int j_1 = 0; j_1 < n; j_1++)
		{
			v[0][j_1] = r[j_1] * (1.0 / beta);
		}
    	//s = 0.0;
		for (int i_1 = 0; i_1 <= m + 1; i_1++) s[i_1] = 0.0;
		s[0] = beta;

		for (i = 0; i < m && j <= maxit; i++, j++) {
			//w = M.solve(A * v[i]);
			MatrixCRSByVector(n, val, col_ind, row_ptr, v[i], w);
			for (k = 0; k <= i; k++) {
				H[k][i] = Scal(n, w, v[k]);
				for (int j_1 = 0; j_1 < n; j_1++)
				{
					w[j_1] -= H[k][i] * v[k][j_1];
				}
			}
			//H[i + 1][i] = norm(w);
			switch (ibasenorma)
			{
			case 1: H[i + 1][i] = NormaV(n, w); break; // евклидова
			case 2: H[i + 1][i] = NormaSupV(n, w); break; // кубическая норма
			case 3: H[i + 1][i] = NormaSup2V(n, w); break; // октаэдрическая норма
			}

			for (int j_1 = 0; j_1 < n; j_1++)
			{
				v[i + 1][j_1] = w[j_1] * (1.0 / H[i + 1][i]); // ??? w / H(i+1, i)
			}

			for (k = 0; k < i; k++)
				ApplyPlaneRotation(H[k][i], H[k + 1][i], cs[k], sn[k]);

			GeneratePlaneRotation(H[i][i], H[i + 1][i], cs[i], sn[i]);
			ApplyPlaneRotation(H[i][i], H[i + 1][i], cs[i], sn[i]);
			ApplyPlaneRotation(s[i], s[i + 1], cs[i], sn[i]);

			if ((resid = fabs(s[i + 1]) / normb) < dterminfatedTResudual) {
				Update(dx, i, n, H, s, v);
				//tol = resid;
				//maxit = j;
				for (i = 0; i<n; i++) {
					dX0[i] = dx[i];
					dxret[i] = dx[i];
				}
				for (int i_1 = 0; i_1 <= m + 1; i_1++) delete[] v[i_1];
				delete[] v;
				delete[] dx;
				delete[] r;
				delete[] w;
				delete[] s;
				delete[] cs;
				delete[] sn;
				for (int i_1 = 0; i_1 < m + 2; i_1++) delete[] H[i_1];
				delete[] H;
				return 0;
			}
		}
		Update(dx, i - 1, n, H, s, v);
		//r = M.solve(b - A * x);
		MatrixCRSByVector(n, val, col_ind, row_ptr, dx, r);
		for (i = 0; i < n; i++) r[i] = dV[i] - r[i];
		//beta = norm(r);
		switch (ibasenorma)
		{
		case 1: beta = NormaV(n, r); break; // евклидова
		case 2: beta = NormaSupV(n, r); break; // кубическая норма
		case 3: beta = NormaSup2V(n, r); break; // октаэдрическая норма
		}

		if ((resid = beta / normb) < dterminfatedTResudual) {
			//tol = resid;
			//maxit = j;
			for (i = 0; i<n; i++) {
				dX0[i] = dx[i];
				dxret[i] = dx[i];
			}
			for (int i_1 = 0; i_1 <= m + 1; i_1++) delete[] v[i_1];
			delete[] v;
			delete[] dx;
			delete[] r;
			delete[] w;
			delete[] s;
			delete[] cs;
			delete[] sn;
			for (int i_1 = 0; i_1 < m + 2; i_1++) delete[] H[i_1];
			delete[] H;
			return 0;
		}
	}

	//tol = resid;
	for (i = 0; i<n; i++) {
		dX0[i] = dx[i];
		dxret[i] = dx[i];
	}
	for (int i_1 = 0; i_1 <= m + 1; i_1++) delete[] v[i_1];
	delete[] v;
	delete[] dx;
	delete[] r;
	delete[] w;
	delete[] s;
	delete[] cs;
	delete[] sn;
	for (int i_1 = 0; i_1 < m + 2; i_1++) delete[] H[i_1];
	delete[] H;
	return 1;

}

// экспорт результата решения уравнений Нвье-Стокса
// в переменных вихрь-функция тока 
//  в программу tecplot 360.
void exporttecplotNSRoacheFedushkinanimate(Real** curl, Real** stream_function, 
	                                Real** temperature,
	                                Real** u, Real** v, 
				                    Real* x, Real* y, int icadr, int m, int n) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "fedorenko1animation.PLT", "a")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y curl stream_function temperature u v\n");
		fprintf(fp,"zone T=\"cadr%d\",\n",icadr);
		fprintf(fp,"I=%d, J=%d, K=1, F=POINT\n",m+2,n+2);
		for (int j=0; j<n+2; j++) {
			for (int i=0; i<m+2; i++) {
				fprintf(fp,"%e %e %e %e %e %e %e\n", x[i], y[j], curl[i][j], stream_function[i][j], temperature[i][j], u[i][j], v[i][j]);
			}
		}
		fclose(fp);
	}

	//getchar();

} // exporttecplotNSRoacheFedushkinanimate

// печать в файл рассчитанной температуры перпендикуляно пластине
// в точке проходящей через её центр.
void exportgradtemp(Real** u, Real* y, int ixpoint, int m, int n) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "centergradtemp.txt", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "temperature in center line\n");
		for (int j=0; j<n+2; j++) fprintf(fp,"%e %e\n",y[j],u[ixpoint][j]);
		fclose(fp);
	}

	//getchar();

} // exportgradtemp

// Перечень функций для наивного алгоритма.

// Выделение памяти под граничные условия.
void my_alloc_bound(BONCONDOMAIN &my_bound,int m, int n) {
	my_bound.left=new BONCONPOINT[n+2];
	my_bound.right=new BONCONPOINT[n+2];
	my_bound.top=new BONCONPOINT[m+2];
	my_bound.bottom=new BONCONPOINT[m+2];
} //  my_alloc_bound

// универсальное выделение памяти
// подходит и для грубой и для подробной сеток.
void my_alloc(Real** &u, Real** &u_old, Real** &r, 
	          Real** &rthdsd, MATRNODE** &A,
			  int m, int n) {
	u=new Real*[m+2];
	for (int i=0; i<m+2; i++) u[i]=new Real[n+2];
	rthdsd=new Real*[m+2];
	for (int i=0; i<m+2; i++) rthdsd[i]=new Real[n+2];
	u_old=new Real*[m+2];
	for (int i=0; i<m+2; i++) u_old[i]=new Real[n+2];
	r=new Real*[m+2];
	for (int i=0; i<m+2; i++) r[i]=new Real[n+2];
	A=new MATRNODE*[m+2];
	for (int i=0; i<m+2; i++) A[i]=new MATRNODE[n+2];

	for (int i = 0; i < m + 2; i++) {
		for (int j = 0; j < n + 2; j++) {
			u[i][j] = 0.0;
			rthdsd[i][j] = 0.0;
			u_old[i][j] = 0.0;
			r[i][j] = 0.0;
			A[i][j].ae = 0.0;
			A[i][j].an = 0.0;
			A[i][j].as = 0.0;
			A[i][j].aw = 0.0;
			A[i][j].ap = 0.0;
			A[i][j].ann = 0.0;
		}
	}

} // my_alloc 

void my_alloc_curl_old(Real** &curlold, Real** &curloldi, int m, int n) {
	curlold=new Real*[m+2];
	for (int i=0; i<m+2; i++) curlold[i]=new Real[n+2];
	curloldi=new Real*[m+2];
	for (int i=0; i<m+2; i++) curloldi[i]=new Real[n+2];
	for (int i = 0; i < m + 2; i++) {
		for (int j = 0; j < n + 2; j++) {
			curlold[i][j] = 0.0;
			curloldi[i][j] = 0.0;
		}
	}
} // my_alloc_curl_old

void my_alloc_temp_old(Real** &temp_old, int m, int n) {
	temp_old=new Real*[m+2];
	for (int i=0; i<m+2; i++) temp_old[i]=new Real[n+2];
	for (int i = 0; i < m + 2; i++) {
		for (int j = 0; j < n + 2; j++) {
			temp_old[i][j] = 0.0;
		}
	}
} // my_alloc_temp_old

// Выделение памяти под произвольный вектор ru.
void my_alloc_universal(Real** &ru, int m, int n) {
	ru=new Real*[m+2];
	for (int i=0; i<m+2; i++) ru[i]=new Real[n+2];
	for (int i = 0; i < m + 2; i++) {
		for (int j = 0; j < n + 2; j++) {
			ru[i][j] = 0.0;
		}
	}
} // my_alloc_universal

// Освобождение памяти из под произвольного вектора ru
void my_free_universal(Real** &ru, int m, int n) {
	for (int i=0; i<m+2; i++) delete[] ru[i];
	delete[] ru;
} // my_free_universal

// копирование вектора.
void my_copy_vector(Real** &rucopy, Real** &ru, int m, int n) {
   for (int i=0; i<m+2; i++) {
	   for (int j=0; j<n+2; j++) {
		   rucopy[i][j]=ru[i][j];
	   }
   }
} // my_copy_vector

// Выделение памяти под компоненты скорости на грубой сетке.
void my_alloc_vel_loc(Real** &u1, Real** &v1, int m, int n) {
	u1=new Real*[m+2];
	for (int i=0; i<m+2; i++) u1[i]=new Real[n+2];
	v1=new Real*[m+2];
	for (int i=0; i<m+2; i++) v1[i]=new Real[n+2];
	for (int i = 0; i < m + 2; i++) {
		for (int j = 0; j < n + 2; j++) {
			u1[i][j] = 0.0;
			v1[i][j] = 0.0;
		}
	}
} // my_alloc_vel_loc

// Выделение памяти в алгоритме В.Г.Зверева.
void my_alloc_zver(Real** &ksi, Real** &etta, Real** &gamma, Real** &delta, int m, int n) {
	ksi=new Real*[m+2];
	for (int i=0; i<m+2; i++) ksi[i]=new Real[n+2];
	etta=new Real*[m+2];
	for (int i=0; i<m+2; i++) etta[i]=new Real[n+2];
	gamma=new Real*[m+2];
	for (int i=0; i<m+2; i++) gamma[i]=new Real[n+2];
	delta=new Real*[m+2];
	for (int i=0; i<m+2; i++) delta[i]=new Real[n+2];
} // my_alloc_zver

// Уничтожение памяти в алгоритме В.Г. Зверева.
void my_free_zver(Real** &ksi, Real** &etta, Real** &gamma, Real** &delta, int m, int n) {
	for (int i=0; i<m+2; i++) {
		delete[] ksi[i];
		delete[] etta[i];
		delete[] gamma[i];
		delete[] delta[i];
	}
	delete[] ksi;
	delete[] etta;
	delete[] gamma;
	delete[] delta;
} // my_free_zver

// Выделение оперативной памяти под задачу вычислительной гидродинамики
// в переменных вихрь-функция тока.
void my_alloc_Roach_Fedushkin(Real** &curl, Real** &stream_function,
	                          Real** &temperature, Real** &u, Real** &v,
							  Real** &gradxtemperature,
			                  int m, int n) {
	// выделение памяти под вихрь, функцию тока и температуру.
	curl=new Real*[m+2];
	for (int i=0; i<m+2; i++) curl[i]=new Real[n+2];
	stream_function=new Real*[m+2];
	for (int i=0; i<m+2; i++) stream_function[i]=new Real[n+2];
	temperature=new Real*[m+2];
	for (int i=0; i<m+2; i++) temperature[i]=new Real[n+2];
	// выделение памяти под компоненты скорости.
	u=new Real*[m+2];
	for (int i=0; i<m+2; i++) u[i]=new Real[n+2];
	v=new Real*[m+2];
	for (int i=0; i<m+2; i++) v[i]=new Real[n+2];
	// выделение памяти под градиент температуры.
    gradxtemperature=new Real*[m+2];
	for (int i=0; i<m+2; i++) gradxtemperature[i]=new Real[n+2];

	for (int i = 0; i < m + 2; i++) {
		for (int j = 0; j < n + 2; j++) {
			curl[i][j] = 0.0;
			stream_function[i][j] = 0.0;
			temperature[i][j] = 0.0;
			u[i][j] = 0.0;
			v[i][j] = 0.0;
			gradxtemperature[i][j] = 0.0;
		}
	}
} // my_alloc_Roach_Fedushkin

// инициализация значением internalval для внутренности расчётной области и 
// соотвествующими значениями на границах.
void my_init_zero(Real bondW, Real bondE, Real bondS, Real bondN, Real internalval,
	              Real** &u, int m, int n) {

	int iapprox=0; // 0 - среднее арефметическое, 1 - среднее геометрическое.

	for (int i=0; i<m+2; i++) {
		for (int j=0; j<n+2; j++) {
			u[i][j]=internalval;
		}
	}

	for (int j=1; j<n+1; j++) {
		u[0][j]=bondW; // левая граница
		u[m+1][j]=bondE; // правая граница
	}

	for (int i=1; i<m+1; i++) {
		u[i][n+1]=bondN; // верхняя граница
		u[i][0]=bondS; // нижняя граница
	}

	// Угловые точки, которые не подвержены вычислениям сеточным методом.
	switch (iapprox) {
	case 0 : // среднее арефметическое
	         u[0][0]=0.5*(bondW+bondS);
	         u[m+1][0]=0.5*(bondE+bondS);
	         u[0][n+1]=0.5*(bondW+bondN);
	         u[m+1][n+1]=0.5*(bondE+bondN);
	         break;
	default : // При среднем геометрическом возможно деление на ноль
		// поэтому лучше применить среднее арифметическое.
		 // среднее арефметическое
	     u[0][0]=0.5*(bondW+bondS);
	     u[m+1][0]=0.5*(bondE+bondS);
	     u[0][n+1]=0.5*(bondW+bondN);
	     u[m+1][n+1]=0.5*(bondE+bondN);    
		break;
	} // end switch

} // my_init_zero

// Начальное распределение потенциала !!!
void my_init_zero_potencial(Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain,
									Real ug, Real ud,
	                    Real* x, Real internalval,
					    Real** &u, int m, int n) {

	for (int i=0; i<m+2; i++) {
		for (int j=0; j<n+2; j++) {
			u[i][j]=internalval;
		}
	}

	for (int j=1; j<n+1; j++) {
		u[0][j]=internalval; // левая граница
		u[m+1][j]=internalval; // правая граница
	}

	for (int i=1; i<m+1; i++) {
		if (x[i]<xendsource) {
			    // source
		      u[i][n+1]=0.0; // верхняя граница
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   // gate
		       u[i][n+1]=ug; // верхняя граница
		   }
		   else if (x[i]>xstartdrain) {
               // drain
		       u[i][n+1]=ud; // верхняя граница
		   }
		   else
		   {
		       u[i][n+1]=internalval;
		   }
		
		u[i][0]=internalval; // нижняя граница
	}

	// Угловые точки, которые не подвержены вычислениям сеточным методом.
	// среднее арефметическое
	u[0][0]=0.5*(u[0][1]+u[1][0]);
	u[m+1][0]=0.5*(u[m][0]+u[m+1][1]);
	u[0][n+1]=0.5*(u[0][n]+u[1][n+1]);
	u[m+1][n+1]=0.5*(u[m+1][n]+u[m][n+1]);

} // my_init_zero_potencial

void my_init_zero_n(Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					Real Nd, Real* x, Real internalval, Real** &neg, Real** &n_oldi, Real** &n_old, int m, int n) 
{
	for (int i=0; i<m+2; i++) {
		for (int j=0; j<n+2; j++) {
			neg[i][j]=internalval;
			n_old[i][j]=internalval;
			n_oldi[i][j]=internalval;
		}
	}

	for (int j=1; j<n+1; j++) {
		neg[0][j]=internalval; // левая граница
		neg[m+1][j]=internalval; // правая граница
		n_old[0][j]=internalval; // левая граница
		n_old[m+1][j]=internalval; // правая граница
		n_oldi[0][j]=internalval; // левая граница
		n_oldi[m+1][j]=internalval; // правая граница
	}

	for (int i=1; i<m+1; i++) {
		if (x[i]<xendsource) {
			    // source
		       neg[i][n+1]=Nd; // верхняя граница
			   n_old[i][n+1]=Nd;
			   n_oldi[i][n+1]=Nd;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   // gate
		       neg[i][n+1]=internalval; // верхняя граница
			   n_old[i][n+1]=internalval;
			   n_oldi[i][n+1]=internalval;
		   }
		   else if (x[i]>xstartdrain) {
               // drain
		       neg[i][n+1]=Nd; // верхняя граница
			   n_old[i][n+1]=Nd;
			   n_oldi[i][n+1]=Nd;
		   }
		   else
		   {
		       neg[i][n+1]=internalval;
			   n_old[i][n+1]=internalval;
			   n_oldi[i][n+1]=internalval;
		   }
		
		neg[i][0]=internalval; // нижняя граница
		n_old[i][0]=internalval;
		n_oldi[i][0]=internalval;
	}

	// Угловые точки, которые не подвержены вычислениям сеточным методом.
	// среднее арефметическое
	neg[0][0]=0.5*(neg[0][1]+neg[1][0]);
	neg[m+1][0]=0.5*(neg[m][0]+neg[m+1][1]);
	neg[0][n+1]=0.5*(neg[0][n]+neg[1][n+1]);
	neg[m+1][n+1]=0.5*(neg[m+1][n]+neg[m][n+1]);

	n_old[0][0]=0.5*(n_old[0][1]+n_old[1][0]);
	n_old[m+1][0]=0.5*(n_old[m][0]+n_old[m+1][1]);
	n_old[0][n+1]=0.5*(n_old[0][n]+n_old[1][n+1]);
	n_old[m+1][n+1]=0.5*(n_old[m+1][n]+n_old[m][n+1]);

	n_oldi[0][0]=0.5*(n_oldi[0][1]+n_oldi[1][0]);
	n_oldi[m+1][0]=0.5*(n_oldi[m][0]+n_oldi[m+1][1]);
	n_oldi[0][n+1]=0.5*(n_oldi[0][n]+n_oldi[1][n+1]);
	n_oldi[m+1][n+1]=0.5*(n_oldi[m+1][n]+n_oldi[m][n+1]);
}

// Достигнута ли необходимая точность для граничных условий.
bool bfinish(Real** curl, Real** curl_old, Real epsilon, 
	         Real &vorticity_boundary_conditions, int m, int n) {
	Real rsum=0.0;
	for (int j=1; j<n+1; j++) {
		rsum+=fabs(curl[0][j]-curl_old[0][j]); // левая граница
		rsum+=fabs(curl[m+1][j]-curl_old[m+1][j]); // правая граница
	}
	for (int i=1; i<m+1; i++) {
		rsum+=fabs(curl[i][n+1]-curl_old[i][n+1]); // верхняя граница
		rsum+=fabs(curl[i][0]-curl_old[i][0]); // нижняя граница
	}

	bool br;

	if (rsum<((Real)(2.0*(M+N)*epsilon))) {
		br=false;
	}
	else {
		br=true;
	}

	// точность выполнения граничных условий для завихрённости.
	vorticity_boundary_conditions=rsum; 

	//printf("rsum==%e\n",rsum);
	//getchar();

	return br;

} // bfinish

// Достигнута ли необходимая точность для поля температуры.
bool bfinish_temp(Real** temp, Real** temp_old, Real epsilon, 
	         Real &temperature_mismatch, int m, int n) {
     Real rsum=0.0;
	 for (int i=0; i<m+2; i++) {
		for (int j=0; j<n+2; j++) {
			rsum+=fabs(temp[i][j]-temp_old[i][j]);
		}
	 }

	 bool br;

	if (rsum<((Real)(((M+2)*(N+2))*epsilon))) {
		br=false;
	}
	else {
		//printf("temperature end %e epsilon =%e\n", ((Real)(((M + 2) * (N + 2)) * epsilon)),epsilon);
		br=true;
	}

	temperature_mismatch=rsum;

	return br;

} // bfinish_temp

// инициализация линейной функцией.
// теперь данная инициализация пригодна и для неравномерной сетки.
void my_init_linear(Real** &u, char chdir, Real t1, Real t2, 
	                Real* x, Real* y, int m, int n) {
	// chdir - направление изменения линейной функции : x, y.
	// t1 и t2 - граничные значения функции,
	// u - полевая величина подверженная линейному распределению.
	Real a, b;
	int i, j;
	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	// шаги были постоянными при равномерной сетке.
	//Real h1=(Real)(lengthx/(m+1));
	//Real h2=(Real)(lengthy/(n+1));

	switch (chdir) {
	case 'x' : // X - direction
		     a=(t2-t1)/lengthx;
			 b=t1;
			 for (i=0; i<m+2; i++) {
		         for (j=0; j<n+2; j++) {
			          u[i][j]=a*x[i]+b;
		         }
	         }
		     break;
	case 'y' : // Y - direction
		     a=(t2-t1)/lengthy;
			 b=t1;
			  for (i=0; i<m+2; i++) {
		         for (j=0; j<n+2; j++) {
			          u[i][j]=a*y[j]+b;
		         }
	         }
		     break;
	}

} // my_init_linear

// одна итерация Ричардсона Либмана.
// 0.0 < alpha < 0.25 - нижняя релаксация см. Патанкар.
// Это релаксационный метод.
void solve(Real alpha, Real** &u, Real** &u_old, Real** rthdsd, MATRNODE** &A, 
	       int m, int n) {
	// rthdsd - правая часть.
	// alpha - коэффициент релаксации.
	// A - матрица СЛАУ.

	// запоминаем поле с предыдущей итерации.
	// данный итерационный процесс требует в два раза больше памяти.
	for (int i=0; i<m+2; i++) {
		for (int j=0; j<n+2; j++) {
			u_old[i][j]=u[i][j];
		}
	}
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	/*//при h1=h2=1.0;
	// Коэффициент Диффузии lambda == 1.0;
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=u_old[i][j]+alpha*(u_old[i-1][j]+u_old[i][j-1]-4.0*u_old[i][j]+u_old[i][j+1]+u_old[i+1][j]+rthdsd[i][j]);
		}
	}*/

    // Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=u_old[i][j]+alpha*((A[i][j].aw*u_old[i-1][j]+A[i][j].as*u_old[i][j-1]+A[i][j].an*u_old[i][j+1]+A[i][j].ae*u_old[i+1][j]+rthdsd[i][j])/A[i][j].ap-u_old[i][j]);
		}
	}

	// Граничные условия :
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		u[i][0]=u_old[i][0]+alpha*((A[i][0].an*u_old[i][1]+rthdsd[i][0])/A[i][0].ap-u_old[i][0]);
		// верхняя граница
        u[i][n+1]=u_old[i][n+1]+alpha*((A[i][n+1].as*u_old[i][n]+rthdsd[i][n+1])/A[i][n+1].ap-u_old[i][n+1]);
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		u[0][j]=u_old[0][j]+alpha*((A[0][j].ae*u_old[1][j]+rthdsd[0][j])/A[0][j].ap-u_old[0][j]);
		// правая граница
		u[m+1][j]=u_old[m+1][j]+alpha*((A[m+1][j].aw*u_old[m][j]+rthdsd[m+1][j])/A[m+1][j].ap-u_old[m+1][j]);
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=u_old[0][0]+alpha*((A[0][0].an*u_old[0][1]+A[0][0].ae*u_old[1][0]+rthdsd[0][0])/A[0][0].ap-u_old[0][0]);

	// правый нижний угол.
	u[m+1][0]=u_old[m+1][0]+alpha*((A[m+1][0].aw*u_old[m][0]+A[m+1][0].an*u_old[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap-u_old[m+1][0]);

	// левый верхний угол.
	u[0][n+1]=u_old[0][n+1]+alpha*((A[0][n+1].as*u_old[0][n]+A[0][n+1].ae*u_old[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap-u_old[0][n+1]);

	// правый верхний угол.
	u[m+1][n+1]=u_old[m+1][n+1]+alpha*((A[m+1][n+1].aw*u_old[m][n+1]+A[m+1][n+1].as*u_old[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap-u_old[m+1][n+1]);
} // solve

// Метод Гаусса-Зейделя
// см. Патанкар.
void Seidel(Real** &u, Real** rthdsd, MATRNODE** &A,
	       int m, int n) {
	// rthdsd - правая часть.
	// A - матрица СЛАУ. (информация о геометрии и о коэффициентах уравнения).
	
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1=h2=1.0;
	// Коэффициент Диффузии lambda == 1.0;
	/*
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=0.25*(u[i-1][j]+u[i][j-1]+u[i][j+1]+u[i+1][j]+rthdsd[i][j]);
		}
	}
	*/

	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1!=h2!=1.0;
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
			if (u[i][j] != u[i][j]) {
				std::cout << A[i][j].ap << " " << A[i][j].as << " " << rthdsd[i][j] << std::endl;
				std::cout << i << " "<< j <<" error bon con " << A[i][j].aw <<" " << A[i][j].as << " " << A[i][j].an << " " << A[i][j].ae << " " << std::endl;
				std::cout << u[i - 1][j] << " " << u[i][j - 1] << " " << u[i][j + 1] <<" " << u[i + 1][j] << std::endl;
			}
		}
	}

	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		u[i][0]=(A[i][0].an*u[i][1]+rthdsd[i][0])/A[i][0].ap;
		// верхняя граница
        u[i][n+1]=(A[i][n+1].as*u[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		u[0][j]=(A[0][j].ae*u[1][j]+rthdsd[0][j])/A[0][j].ap;
		// правая граница
		u[m+1][j]=(A[m+1][j].aw*u[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;


} // Seidel

// Метод Гаусса-Зейделя
// см. Патанкар.
void SeidelP(Real** &u, Real** rthdsd, MATRNODE** &A,
	       int m, int n, int inumcore) {
	// rthdsd - правая часть.
	// A - матрица СЛАУ. (информация о геометрии и о коэффициентах уравнения).
	
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1=h2=1.0;
	// Коэффициент Диффузии lambda == 1.0;
	/*
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=0.25*(u[i-1][j]+u[i][j-1]+u[i][j+1]+u[i+1][j]+rthdsd[i][j]);
		}
	}
	*/

	if (inumcore==1) {
	    // Вычисляем новое значение.
	    // Только внутренность (граничные условия и так выполнены).
	    // Классический процесс Зейделя. при h1!=h2!=1.0;
	    for (int i=1; i<m+1; i++) {
	    	for (int j=1; j<n+1; j++) {
		    	u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
	    	}
	    }
	}
	if (inumcore==2) {
		int iM2=(int)((m+2)/2);

#pragma omp parallel shared(u,A,rthdsd)
		{
	    // Вычисляем новое значение.
	    // Только внутренность (граничные условия и так выполнены).
	    // Классический процесс Зейделя. при h1!=h2!=1.0;
#pragma omp sections
			{
#pragma omp section
				{
					for (int i=1; i<iM2; i++) {
	    	            for (int j=1; j<n+1; j++) {
		    	             u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
	    	            }
	                }
				}
#pragma omp section
				{
					for (int i=iM2+1; i<m+1; i++) {
	    	            for (int j=1; j<n+1; j++) {
		    	             u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
	    	            }
	                }
				}

			}
		}

		int i=iM2; 
	    for (int j=1; j<n+1; j++) {
		    u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
	    }
	                
	    
	}
	if (inumcore==4) {
		int iM2=(int)((m+2)/2);
int iM4=(int)(iM2/2);
int iM5=iM2+iM4;

        int i=iM2; 
	    for (int j=1; j<n+1; j++) {
		    u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
	    }
		 i=iM5; 
	    for (int j=1; j<n+1; j++) {
		    u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
	    }
		 i=iM4; 
	    for (int j=1; j<n+1; j++) {
		    u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
	    }

#pragma omp parallel shared(u,A,rthdsd)
		{
	    // Вычисляем новое значение.
	    // Только внутренность (граничные условия и так выполнены).
	    // Классический процесс Зейделя. при h1!=h2!=1.0;
#pragma omp sections
			{
#pragma omp section
				{
					for (int i=1; i<iM4; i++) {
	    	            for (int j=1; j<n+1; j++) {
		    	             u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
	    	            }
	                }
				}
#pragma omp section
				{
					for (int i=iM4+1; i<iM2; i++) {
	    	            for (int j=1; j<n+1; j++) {
		    	             u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
	    	            }
	                }
				}
#pragma omp section
				{
					for (int i=iM2+1; i<iM5; i++) {
	    	            for (int j=1; j<n+1; j++) {
		    	             u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
	    	            }
	                }
				}
#pragma omp section
				{
					for (int i=iM5+1; i<m+1; i++) {
	    	            for (int j=1; j<n+1; j++) {
		    	             u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
	    	            }
	                }
				}

			}
		}


		

	    
	}


	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		u[i][0]=(A[i][0].an*u[i][1]+rthdsd[i][0])/A[i][0].ap;
		// верхняя граница
        u[i][n+1]=(A[i][n+1].as*u[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		u[0][j]=(A[0][j].ae*u[1][j]+rthdsd[0][j])/A[0][j].ap;
		// правая граница
		u[m+1][j]=(A[m+1][j].aw*u[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;


} // SeidelP


// Метод Гаусса-Зейделя
// см. Патанкар.
void Seidel1(Real** &u, Real** rthdsd, MATRNODE** &A,
	       int m, int n, Real alpha, Real* x, Real xendsource, Real xstartdrain, Real Nd) {

	// rthdsd - правая часть.
	// A - матрица СЛАУ. (информация о геометрии и о коэффициентах уравнения).
	
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1=h2=1.0;
	// Коэффициент Диффузии lambda == 1.0;
	/*
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=0.25*(u[i-1][j]+u[i][j-1]+u[i][j+1]+u[i+1][j]+rthdsd[i][j]);
		}
	}
	*/

	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1!=h2!=1.0;
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			Real ptilda=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
			u[i][j]=u[i][j] + alpha*(ptilda-u[i][j]);
		}
	}

	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		Real ptilda=(A[i][0].an*u[i][1]+rthdsd[i][0])/A[i][0].ap;
		u[i][0]=u[i][0]+alpha*(ptilda-u[i][0]);
		// верхняя граница
		if ((x[i]>=xendsource)&&(x[i]<=xstartdrain)) {
			ptilda=(A[i][n+1].as*u[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
            u[i][n+1]=u[i][n+1]+alpha*(ptilda-u[i][n+1]);
		}
		else {
			u[i][n+1]=Nd;
		}
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		Real ptilda=(A[0][j].ae*u[1][j]+rthdsd[0][j])/A[0][j].ap;
		u[0][j]=u[0][j]+alpha*(ptilda-u[0][j]);
		// правая граница
		ptilda=(A[m+1][j].aw*u[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
		u[m+1][j]=u[m+1][j]+alpha*(ptilda-u[m+1][j]);
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;


} // Seidel1

// Метод Гаусса-Зейделя
// см. Патанкар.
void Seidel2(Real** &u, Real** rthdsd, MATRNODE** &A,
	       int m, int n, Real alpha, Real* x, Real xendsource, Real xstartdrain, Real Nd) {

	// rthdsd - правая часть.
	// A - матрица СЛАУ. (информация о геометрии и о коэффициентах уравнения).
	
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1=h2=1.0;
	// Коэффициент Диффузии lambda == 1.0;
	/*
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=0.25*(u[i-1][j]+u[i][j-1]+u[i][j+1]+u[i+1][j]+rthdsd[i][j]);
		}
	}
	*/


	for (int i=0; i<m+2; i++) {
		for (int j=0; j<n+2; j++) {

	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1!=h2!=1.0;
	if ((i>=1)&&(i<m+1)&&(j>=1)&&(j<n+1)) {
		Real ptilda=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
		u[i][j]=u[i][j] + alpha*(ptilda-u[i][j]);
	}

	

	// Граничные условия :
	// граничные условия.
	
	if ((j==0)&&(i>=1)&&(i<m+1)) {
		// нижняя граница
		Real ptilda=(A[i][0].an*u[i][1]+rthdsd[i][0])/A[i][0].ap;
		u[i][0]=u[i][0]+alpha*(ptilda-u[i][0]);
	}
		// верхняя граница
	if ((j==n+1)&&(i>=1)&&(i<m+1)) {
		if ((x[i]>=xendsource)&&(x[i]<=xstartdrain)) {
			Real ptilda=(A[i][n+1].as*u[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
            u[i][n+1]=u[i][n+1]+alpha*(ptilda-u[i][n+1]);
		}
		else {
			u[i][n+1]=Nd;
		}
	}
	
	// граничные условия.
	if ((j>=1)&&(j<n+1)) {
		if (i==0) {
		    // левая граница
		    Real ptilda=(A[0][j].ae*u[1][j]+rthdsd[0][j])/A[0][j].ap;
		    u[0][j]=u[0][j]+alpha*(ptilda-u[0][j]);
		}
		if (i==m+1) {
		    // правая граница
		    Real ptilda=(A[m+1][j].aw*u[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
		    u[m+1][j]=u[m+1][j]+alpha*(ptilda-u[m+1][j]);
		}
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	if ((i==0)&&(j==0)) {
	    u[0][0]=(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;
	}

	// правый нижний угол.
	if ((i==m+1)&&(j==0)) {
    	u[m+1][0]=(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;
	}

	// левый верхний угол.
	if ((i==0)&&(j==n+1)) {
	    u[0][n+1]=(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;
	}

	// правый верхний угол.
	if ((i==m+1)&&(j==n+1)) {
	u[m+1][n+1]=(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;
	}
		}
	}


} // Seidel2


// норма невязки : (сумма модулей).
// октаэдрическая норма.
Real normar(Real** r, int m, int n) {
	Real norm=0.0;
	for (int i=0; i<m+2; i++) {
		for (int j=0; j<n+2; j++) {
			//norm+=fabs(r[i][j]);
			norm += r[i][j] * r[i][j];
		}
	}
	// Евклидова норма вектора.
	norm = sqrt(norm) / (1.0*(m+2)*(n+2));
	return norm;
} // normar


// Вычисление невязки.
void residual(Real** &r, Real** u_old, Real** rthdsd,  MATRNODE** &A, int m, int n) {
	// rthdsd - правая часть уравнения.
	// матрица СЛАУ A хранит информацию о геометрии и коэффициентах уравнения.

	// обнуляем невязку.
	for (int i=0; i<m+2; i++) {
		for (int j=0; j<n+2; j++) {
			r[i][j]=0.0;
		}
	}

	/* Так было реализовано в программе Fedorenko1.
	// Вычисление невязкиво внутренних узлах.
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			r[i][j]=(u_old[i-1][j]+u_old[i][j-1]-4.0*u_old[i][j]+u_old[i][j+1]+u_old[i+1][j]+rthdsd[i][j]);
		}
	}*/

    // Вычисление невязкиво внутренних узлах.
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			r[i][j]=(A[i][j].aw*u_old[i-1][j]+A[i][j].as*u_old[i][j-1]-A[i][j].ap*u_old[i][j]+A[i][j].an*u_old[i][j+1]+A[i][j].ae*u_old[i+1][j]+rthdsd[i][j]);
		}
	}

	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		r[i][0]=(A[i][0].an*u_old[i][1]-A[i][0].ap*u_old[i][0]+rthdsd[i][0]);
		// верхняя граница
        r[i][n+1]=(A[i][n+1].as*u_old[i][n]-A[i][n+1].ap*u_old[i][n+1]+rthdsd[i][n+1]);
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		r[0][j]=(A[0][j].ae*u_old[1][j]-A[0][j].ap*u_old[0][j]+rthdsd[0][j]);
		// правая граница
		r[m+1][j]=(A[m+1][j].aw*u_old[m][j]-A[m+1][j].ap*u_old[m+1][j]+rthdsd[m+1][j]);
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	r[0][0]=(A[0][0].an*u_old[0][1]+A[0][0].ae*u_old[1][0]-A[0][0].ap*u_old[0][0]+rthdsd[0][0]);

	// правый нижний угол.
	r[m+1][0]=(A[m+1][0].aw*u_old[m][0]+A[m+1][0].an*u_old[m+1][1]-A[m+1][0].ap*u_old[m+1][0]+rthdsd[m+1][0]);

	// левый верхний угол.
	r[0][n+1]=(A[0][n+1].as*u_old[0][n]+A[0][n+1].ae*u_old[1][n+1]-A[0][n+1].ap*u_old[0][n+1]+rthdsd[0][n+1]);

	// правый верхний угол.
	r[m+1][n+1]=(A[m+1][n+1].aw*u_old[m][n+1]+A[m+1][n+1].as*u_old[m+1][n]-A[m+1][n+1].ap*u_old[m+1][n+1]+rthdsd[m+1][n+1]);

} // residual

// Метод последовательной релаксации с параметром релаксации,
// предложенным В.П. Ильиным в 1985 году.
// см. Патанкар.
void Ilyin1985_base(Real** &u, Real** rthdsd, MATRNODE** &A,
	       int m, int n, int inumberiter, Real omega,
		   Real* &residual_history, int &icloc) {
	// rthdsd - правая часть.
	// A - матрица СЛАУ. (информация о геометрии и о коэффициентах уравнения).
	// omega - оптимальный параметр релаксации.
	
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1=h2=1.0;
	// Коэффициент Диффузии lambda == 1.0;
	/*
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=0.25*(u[i-1][j]+u[i][j-1]+u[i][j+1]+u[i+1][j]+rthdsd[i][j]);
		}
	}
	*/

	for (int i1=0; i1<inumberiter; i1++)
	{

	    // Вычисляем новое значение.
	    // Только внутренность (граничные условия и так выполнены).
	    // Классический процесс Зейделя. при h1!=h2!=1.0;
	    for (int i=1; i<m+1; i++) {
		    for (int j=1; j<n+1; j++) {
		    	u[i][j]=(1.0-omega)*u[i][j] + omega*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
		    }
    	}

	    // Граничные условия :
	    // граничные условия.
	    for (int i=1; i<m+1; i++) {
		    // нижняя граница
		    u[i][0]=(1.0-omega)*u[i][0] + omega*(A[i][0].an*u[i][1]+rthdsd[i][0])/A[i][0].ap;
		    // верхняя граница
            u[i][n+1]=(1.0-omega)*u[i][n+1] + omega*(A[i][n+1].as*u[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	    }
	    // граничные условия.
	    for (int j=1; j<n+1; j++) {
		    // левая граница
		    u[0][j]=(1.0-omega)*u[0][j] + omega*(A[0][j].ae*u[1][j]+rthdsd[0][j])/A[0][j].ap;
		    // правая граница
		    u[m+1][j]=(1.0-omega)*u[m+1][j] + omega*(A[m+1][j].aw*u[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	    }

	    // Угловые точки, которые не рассчитываются но визуализируются.
	    // среднее арефметическое
	    // левый нижний угол.
	    u[0][0]=(1.0-omega)*u[0][0] + omega*(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	    // правый нижний угол.
	    u[m+1][0]=(1.0-omega)*u[m+1][0] + omega*(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	    // левый верхний угол.
	    u[0][n+1]=(1.0-omega)*u[0][n+1] + omega*(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	    // правый верхний угол.
	    u[m+1][n+1]=(1.0-omega)*u[m+1][n+1] + omega*(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;

		
		Real **r;
        my_alloc_universal(r, m, n);
		residual(r, u, rthdsd, A, m, n);
		//printf("%1.4e \n",normar(r,m,n));
		residual_history[icloc++]=normar(r,m,n);
        my_free_universal(r, m, n);

	}


} // Ilyin1985_base

// Метод последовательной релаксации с параметром релаксации,
// предложенным В.П. Ильиным в 1985 году.
// см. Патанкар.
void Ilyin1985_base_quick(Real** &u, Real** rthdsd, MATRNODE** &A,
	       int m, int n, int inumberiter, Real omega, int &icloc) {
	// rthdsd - правая часть.
	// A - матрица СЛАУ. (информация о геометрии и о коэффициентах уравнения).
	// omega - оптимальный параметр релаксации.
	
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1=h2=1.0;
	// Коэффициент Диффузии lambda == 1.0;
	/*
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=0.25*(u[i-1][j]+u[i][j-1]+u[i][j+1]+u[i+1][j]+rthdsd[i][j]);
		}
	}
	*/

	for (int i1=0; i1<inumberiter; i1++)
	{

	    // Вычисляем новое значение.
	    // Только внутренность (граничные условия и так выполнены).
	    // Классический процесс Зейделя. при h1!=h2!=1.0;
	    for (int i=1; i<m+1; i++) {
		    for (int j=1; j<n+1; j++) {
		    	u[i][j]=(1.0-omega)*u[i][j] + omega*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
		    }
    	}

	    // Граничные условия :
	    // граничные условия.
	    for (int i=1; i<m+1; i++) {
		    // нижняя граница
		    u[i][0]=(1.0-omega)*u[i][0] + omega*(A[i][0].an*u[i][1]+rthdsd[i][0])/A[i][0].ap;
		    // верхняя граница
            u[i][n+1]=(1.0-omega)*u[i][n+1] + omega*(A[i][n+1].as*u[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	    }
	    // граничные условия.
	    for (int j=1; j<n+1; j++) {
		    // левая граница
		    u[0][j]=(1.0-omega)*u[0][j] + omega*(A[0][j].ae*u[1][j]+rthdsd[0][j])/A[0][j].ap;
		    // правая граница
		    u[m+1][j]=(1.0-omega)*u[m+1][j] + omega*(A[m+1][j].aw*u[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	    }

	    // Угловые точки, которые не рассчитываются но визуализируются.
	    // среднее арефметическое
	    // левый нижний угол.
	    u[0][0]=(1.0-omega)*u[0][0] + omega*(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	    // правый нижний угол.
	    u[m+1][0]=(1.0-omega)*u[m+1][0] + omega*(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	    // левый верхний угол.
	    u[0][n+1]=(1.0-omega)*u[0][n+1] + omega*(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	    // правый верхний угол.
	    u[m+1][n+1]=(1.0-omega)*u[m+1][n+1] + omega*(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;

		
		//Real **r;
        //my_alloc_universal(r, m, n);
		//residual(r, u, rthdsd, A, m, n);
		//printf("%1.4e \n",normar(r,m,n));
		//residual_history[icloc++]=normar(r,m,n);
        //my_free_universal(r, m, n);

	}


} // Ilyin1985_base_quick


void Ilyin1985_body(Real** &u, Real** rthdsd, MATRNODE** &A,
	       int m, int n, int inumberiter,
		   Real* &residual_history, int &icloc) {

   Real **u1, **u2, **u3;

   my_alloc_universal(u1, m, n);
   my_alloc_universal(u2, m, n);
   my_alloc_universal(u3, m, n);

   Ilyin1985_base(u, rthdsd, A,  m, n, 1, 1.0,residual_history,icloc);
   my_copy_vector(u1, u, m, n);
   Ilyin1985_base(u, rthdsd, A,  m, n, 1, 1.0,residual_history,icloc);
   my_copy_vector(u2, u, m, n);
   Ilyin1985_base(u, rthdsd, A,  m, n, 1, 1.0,residual_history,icloc);
   my_copy_vector(u3, u, m, n);

   Real sum1=0.0, sum2=0.0;
   for (int i=0; i<m+2; i++) {
	   for (int j=0; j<n+2; j++) {
		   sum1+=(u3[i][j]-u2[i][j])*(u3[i][j]-u2[i][j]);
		   sum2+=(u2[i][j]-u1[i][j])*(u2[i][j]-u1[i][j]);
	   }
   }
   Real lambda1=sqrt(sum1/sum2);
   Real omega=2.0/(1.0+sqrt(1.0-lambda1));

   printf("lambda1=%1.4e omega=%1.4e \n",lambda1, omega);

   Ilyin1985_base(u, rthdsd, A,  m, n, inumberiter-3, omega,residual_history,icloc);

   my_free_universal(u1, m, n);
   my_free_universal(u2, m, n);
   my_free_universal(u3, m, n);

} // алгоритм Ильина 1985.

void Ilyin1985_body_quick(Real** &u, Real** rthdsd, MATRNODE** &A,
	       int m, int n, int inumberiter, int &icloc) {

   Real **u1, **u2, **u3;

   my_alloc_universal(u1, m, n);
   my_alloc_universal(u2, m, n);
   my_alloc_universal(u3, m, n);

   Ilyin1985_base_quick(u, rthdsd, A,  m, n, 1, 1.0,icloc);
   my_copy_vector(u1, u, m, n);
   Ilyin1985_base_quick(u, rthdsd, A,  m, n, 1, 1.0,icloc);
   my_copy_vector(u2, u, m, n);
   Ilyin1985_base_quick(u, rthdsd, A,  m, n, 1, 1.0,icloc);
   my_copy_vector(u3, u, m, n);

   Real sum1=0.0, sum2=0.0;
   for (int i=0; i<m+2; i++) {
	   for (int j=0; j<n+2; j++) {
		   sum1+=(u3[i][j]-u2[i][j])*(u3[i][j]-u2[i][j]);
		   sum2+=(u2[i][j]-u1[i][j])*(u2[i][j]-u1[i][j]);
	   }
   }
   Real lambda1=sqrt(sum1/sum2);
   Real omega=2.0/(1.0+sqrt(1.0-lambda1));

   //printf("lambda1=%1.4e omega=%1.4e \n",lambda1, omega);

   Ilyin1985_base_quick(u, rthdsd, A,  m, n, inumberiter-3, omega,icloc);

   my_free_universal(u1, m, n);
   my_free_universal(u2, m, n);
   my_free_universal(u3, m, n);

} // алгоритм Ильина 1985.


// алгоритм Ильина 1985 год.
void Ilyin1985(Real** &u, Real** rthdsd, MATRNODE** &A,
					int m, int n, int inumberiter) {
	int ic=0;
	const int lengthcycle=10;

	 Real *residual_history=new Real[inumberiter+1];
	  for (int i=0; i<inumberiter; i++) {
		  residual_history[i]=1.0; // инициализация.
	  }

     int icloc=0;
	 while (ic<inumberiter) {
		Ilyin1985_body(u,rthdsd,A,m,n,lengthcycle,residual_history,icloc);
		ic=ic+lengthcycle;
	 }

	 // нормированная октаэдрическая норма (сумма модулей).
	 for (int i=1; i<inumberiter; i++) {
	     residual_history[i]=residual_history[i]/residual_history[0];
	 }
	 residual_history[0]=1.0;

	 for (int i=0; i<inumberiter; i++) {
	     printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	 }
	 delete residual_history;

	
}

// алгоритм Ильина 1985 год.
void Ilyin1985quick(Real** &u, Real** rthdsd, MATRNODE** &A,
					int m, int n, int inumberiter) {
	//int ic=0;
	//const int lengthcycle=10;

	

     int icloc=0;
	 /*
	 while (ic<inumberiter) {
		Ilyin1985_body_quick(u,rthdsd,A,m,n,lengthcycle,icloc);
		ic=ic+lengthcycle;
	 }
	 */

	 Ilyin1985_body_quick(u,rthdsd,A,m,n,inumberiter,icloc);


	
}


// Метод Гаусса-Зейделя с чёт-нечет упорядочиванием.
// Чёт нечетупорядочивание позволяет устранить конфликты по доступу к данным 
// и применить эффективное распараллеливание.
// см. Патанкар.
void Seidel_Red_Black(Real** &u, Real** rthdsd, MATRNODE** &A,
	       bool** bred_black, int m, int n) {
	// rthdsd - правая часть.
	// A - матрица СЛАУ. (информация о геометрии и о коэффициентах уравнения).
	
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1=h2=1.0;
	// Коэффициент Диффузии lambda == 1.0;
	/*
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=0.25*(u[i-1][j]+u[i][j-1]+u[i][j+1]+u[i+1][j]+rthdsd[i][j]);
		}
	}
	*/

    bool bflag=true;
	for (int k=0; k<2; k++) {

       if (k==0) bflag=true; // i+j Чётное.
	   if (k==1) bflag=false; // i+j нечётное.

	   // Вычисляем новое значение.
	   // Только внутренность (граничные условия и так выполнены).
	   // Классический процесс Зейделя. при h1!=h2!=1.0;
	   for (int i=1; i<m+1; i++) {
		    for (int j=1; j<n+1; j++) {
			    if ((bflag&&bred_black[i][j])||((!bflag)&&(!bred_black[i][j]))) {
				    // Чётное (Red). Нечётное (Black)
			        u[i][j]=(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
			    }
		    }
	   }

	   // Граничные условия :
	   // граничные условия.
	   for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   if ((bflag&&bred_black[i][0])||((!bflag)&&(!bred_black[i][0]))) {
		       u[i][0]=(A[i][0].an*u[i][1]+rthdsd[i][0])/A[i][0].ap;
		   }
		   if ((bflag&&bred_black[i][n+1])||((!bflag)&&(!bred_black[i][n+1]))) {
		       // верхняя граница
               u[i][n+1]=(A[i][n+1].as*u[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
		   }
	    }
	    // граничные условия.
	    for (int j=1; j<n+1; j++) {
		    if ((bflag&&bred_black[0][j])||((!bflag)&&(!bred_black[0][j]))) {
		        // левая граница
		        u[0][j]=(A[0][j].ae*u[1][j]+rthdsd[0][j])/A[0][j].ap;
		    }
		    if ((bflag&&bred_black[m+1][j])||((!bflag)&&(!bred_black[m+1][j]))) {
		        // правая граница
		        u[m+1][j]=(A[m+1][j].aw*u[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
		    }
	     }

	}
	
	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;


} // Seidel_Red_Black

// Метод Верхней релаксации с оптимальным параметром.
// см. Е.Н.Бондарев, А.С.Кокорев МАИ Численные методы решения уравнений Навье-Стокса М. 1992.
// Оптимальное значение коэффициента релаксации известно лишь для прямоугольной области и граничных условий Дирихле.
// см. Патанкар.
void  SORDirichlet(Real** &u, Real** rthdsd, MATRNODE** &A, Real URF,
	       int m, int n) {
	// rthdsd - правая часть.
	// A - матрица СЛАУ. (информация о геометрии и о коэффициентах уравнения).
	// URF - параметр релаксации.
	
	
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1=h2=1.0;
	// Коэффициент Диффузии lambda == 1.0;
	/*
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=(1.0-URF)*u[i][j]+URF*0.25*(u[i-1][j]+u[i][j-1]+u[i][j+1]+u[i+1][j]+rthdsd[i][j]);
		}
	}
	*/

	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1!=h2!=1.0;
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
#if MY_FLOAT
			u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
			u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
			
		}
	}

#if MY_FLOAT
	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		u[i][0]=(1.0f-URF)*u[i][0]+URF*(A[i][0].an*u[i][1]+rthdsd[i][0])/A[i][0].ap;
		// верхняя граница
        u[i][n+1]=(1.0f-URF)*u[i][n+1]+URF*(A[i][n+1].as*u[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		u[0][j]=(1.0f-URF)*u[0][j]+URF*(A[0][j].ae*u[1][j]+rthdsd[0][j])/A[0][j].ap;
		// правая граница
		u[m+1][j]=(1.0f-URF)*u[m+1][j]+URF*(A[m+1][j].aw*u[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(1.0f-URF)*u[0][0]+URF*(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(1.0f-URF)*u[m+1][0]+URF*(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(1.0f-URF)*u[0][n+1]+URF*(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(1.0f-URF)*u[m+1][n+1]+URF*(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;
#else
	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		u[i][0]=(1.0-URF)*u[i][0]+URF*(A[i][0].an*u[i][1]+rthdsd[i][0])/A[i][0].ap;
		// верхняя граница
        u[i][n+1]=(1.0-URF)*u[i][n+1]+URF*(A[i][n+1].as*u[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		u[0][j]=(1.0-URF)*u[0][j]+URF*(A[0][j].ae*u[1][j]+rthdsd[0][j])/A[0][j].ap;
		// правая граница
		u[m+1][j]=(1.0-URF)*u[m+1][j]+URF*(A[m+1][j].aw*u[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(1.0-URF)*u[0][0]+URF*(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(1.0-URF)*u[m+1][0]+URF*(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(1.0-URF)*u[0][n+1]+URF*(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(1.0-URF)*u[m+1][n+1]+URF*(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;
#endif
	


} // SORDirichlet

// метод Якоби не содержит параметров релаксации и пригоден для массовой
// параллельной обработки.
// Все узлы могут обрабатываться независимо друг от друга.
void Jacobi_parallel(Real** &u, Real** &jacobi, Real** rthdsd, MATRNODE** &A, int m, int n) 
{
	// rthdsd - правая часть.
	// A - матрица СЛАУ. (информация о геометрии и о коэффициентах уравнения).
	
	
	for (int i=0; i<=m+1; i++) {
		for (int j=0; j<=n+1; j++) {
			jacobi[i][j]=u[i][j];
		}
	}

	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1!=h2!=1.0;
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
#if MY_FLOAT
			u[i][j]=(A[i][j].aw*jacobi[i-1][j]+A[i][j].as*jacobi[i][j-1]+A[i][j].an*jacobi[i][j+1]+A[i][j].ae*jacobi[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
			u[i][j]=(A[i][j].aw*jacobi[i-1][j]+A[i][j].as*jacobi[i][j-1]+A[i][j].an*jacobi[i][j+1]+A[i][j].ae*jacobi[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
			
		}
	}

#if MY_FLOAT
	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		u[i][0]=(A[i][0].an*jacobi[i][1]+rthdsd[i][0])/A[i][0].ap;
		// верхняя граница
        u[i][n+1]=(A[i][n+1].as*jacobi[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		u[0][j]=(A[0][j].ae*jacobi[1][j]+rthdsd[0][j])/A[0][j].ap;
		// правая граница
		u[m+1][j]=(A[m+1][j].aw*jacobi[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(A[0][0].an*jacobi[0][1]+A[0][0].ae*jacobi[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(A[m+1][0].aw*jacobi[m][0]+A[m+1][0].an*jacobi[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(A[0][n+1].as*jacobi[0][n]+A[0][n+1].ae*jacobi[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(A[m+1][n+1].aw*jacobi[m][n+1]+A[m+1][n+1].as*jacobi[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;
#else
	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		u[i][0]=(A[i][0].an*jacobi[i][1]+rthdsd[i][0])/A[i][0].ap;
		// верхняя граница
        u[i][n+1]=(A[i][n+1].as*jacobi[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		u[0][j]=(A[0][j].ae*jacobi[1][j]+rthdsd[0][j])/A[0][j].ap;
		// правая граница
		u[m+1][j]=(A[m+1][j].aw*jacobi[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(A[0][0].an*jacobi[0][1]+A[0][0].ae*jacobi[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(A[m+1][0].aw*jacobi[m][0]+A[m+1][0].an*jacobi[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(A[0][n+1].as*jacobi[0][n]+A[0][n+1].ae*jacobi[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(A[m+1][n+1].aw*jacobi[m][n+1]+A[m+1][n+1].as*jacobi[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;
#endif

	
	



}

// При параллельной обработке новые значения рассчитываются на основании предыдущих послойно, этот код моделирует эту ситуацию.
// Метод Верхней релаксации с оптимальным параметром.
// см. Е.Н.Бондарев, А.С.Кокорев МАИ Численные методы решения уравнений Навье-Стокса М. 1992.
// Оптимальное значение коэффициента релаксации известно лишь для прямоугольной области и граничных условий Дирихле.
// см. Патанкар.
void  SORDirichlet_test(Real** &u, Real** rthdsd, MATRNODE** &A, Real URF,
	       int m, int n) {
	// rthdsd - правая часть.
	// A - матрица СЛАУ. (информация о геометрии и о коэффициентах уравнения).
	// URF - параметр релаксации.
    Real **u_old;
	my_alloc_universal(u_old, M, N);
	for (int i=0; i<=m+1; i++) {
		for (int j=0; j<=n+1; j++) {
			u_old[i][j]=u[i][j];
		}
	}
	
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1=h2=1.0;
	// Коэффициент Диффузии lambda == 1.0;
	/*
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=(1.0-URF)*u[i][j]+URF*0.25*(u[i-1][j]+u[i][j-1]+u[i][j+1]+u[i+1][j]+rthdsd[i][j]);
		}
	}
	*/

	
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1!=h2!=1.0;
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
#if MY_FLOAT
			u[i][j]=(1.0f-URF)*u_old[i][j]+URF*(A[i][j].aw*u_old[i-1][j]+A[i][j].as*u_old[i][j-1]+A[i][j].an*u_old[i][j+1]+A[i][j].ae*u_old[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
			u[i][j]=(1.0-URF)*u_old[i][j]+URF*(A[i][j].aw*u_old[i-1][j]+A[i][j].as*u_old[i][j-1]+A[i][j].an*u_old[i][j+1]+A[i][j].ae*u_old[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
			
		}
	}

#if MY_FLOAT
	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		u[i][0]=(1.0f-URF)*u_old[i][0]+URF*(A[i][0].an*u_old[i][1]+rthdsd[i][0])/A[i][0].ap;
		// верхняя граница
        u[i][n+1]=(1.0f-URF)*u_old[i][n+1]+URF*(A[i][n+1].as*u_old[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		u[0][j]=(1.0f-URF)*u_old[0][j]+URF*(A[0][j].ae*u_old[1][j]+rthdsd[0][j])/A[0][j].ap;
		// правая граница
		u[m+1][j]=(1.0f-URF)*u_old[m+1][j]+URF*(A[m+1][j].aw*u_old[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(1.0f-URF)*u_old[0][0]+URF*(A[0][0].an*u_old[0][1]+A[0][0].ae*u_old[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(1.0f-URF)*u_old[m+1][0]+URF*(A[m+1][0].aw*u_old[m][0]+A[m+1][0].an*u_old[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(1.0f-URF)*u_old[0][n+1]+URF*(A[0][n+1].as*u_old[0][n]+A[0][n+1].ae*u_old[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(1.0f-URF)*u_old[m+1][n+1]+URF*(A[m+1][n+1].aw*u_old[m][n+1]+A[m+1][n+1].as*u_old[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;
#else
	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		u[i][0]=(1.0-URF)*u_old[i][0]+URF*(A[i][0].an*u_old[i][1]+rthdsd[i][0])/A[i][0].ap;
		// верхняя граница
        u[i][n+1]=(1.0-URF)*u_old[i][n+1]+URF*(A[i][n+1].as*u_old[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		u[0][j]=(1.0-URF)*u_old[0][j]+URF*(A[0][j].ae*u_old[1][j]+rthdsd[0][j])/A[0][j].ap;
		// правая граница
		u[m+1][j]=(1.0-URF)*u_old[m+1][j]+URF*(A[m+1][j].aw*u_old[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(1.0-URF)*u_old[0][0]+URF*(A[0][0].an*u_old[0][1]+A[0][0].ae*u_old[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(1.0-URF)*u_old[m+1][0]+URF*(A[m+1][0].aw*u_old[m][0]+A[m+1][0].an*u_old[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(1.0-URF)*u_old[0][n+1]+URF*(A[0][n+1].as*u_old[0][n]+A[0][n+1].ae*u_old[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(1.0-URF)*u_old[m+1][n+1]+URF*(A[m+1][n+1].aw*u_old[m][n+1]+A[m+1][n+1].as*u_old[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;
#endif

	
	
my_free_universal(u_old, M, N);

} // SORDirichlet_text


// Метод Верхней релаксации с оптимальным параметром.
// см. Е.Н.Бондарев, А.С.Кокорев МАИ Численные методы решения уравнений Навье-Стокса М. 1992.
// Оптимальное значение коэффициента релаксации известно лишь для прямоугольной области и граничных условий Дирихле.
// см. Патанкар.
// Параллельный решатель.
void  SORDirichlet_P(Real** &u, Real** rthdsd, MATRNODE** &A, Real URF,
	       int m, int n, int inumcore) {
	// rthdsd - правая часть.
	// A - матрица СЛАУ. (информация о геометрии и о коэффициентах уравнения).
	// URF - параметр релаксации.
	
			   if (inumcore==1) {
	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1=h2=1.0;
	// Коэффициент Диффузии lambda == 1.0;
	/*
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			u[i][j]=(1.0-URF)*u[i][j]+URF*0.25*(u[i-1][j]+u[i][j-1]+u[i][j+1]+u[i+1][j]+rthdsd[i][j]);
		}
	}
	*/

	// Вычисляем новое значение.
	// Только внутренность (граничные условия и так выполнены).
	// Классический процесс Зейделя. при h1!=h2!=1.0;
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
#if MY_FLOAT
			u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
			u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
			
		}
	}
			   }


#if MY_FLOAT
#else
#endif

	 if (inumcore==2) {
	// два ядра.

	int im2=(int)((m+2)/2);
#pragma omp parallel shared(u,A,rthdsd,URF)
	{
#pragma omp sections
		{
#pragma omp section
			{
               // Вычисляем новое значение.
	           // Только внутренность (граничные условия и так выполнены).
	           // Классический процесс Зейделя. при h1!=h2!=1.0;
	           for (int i=1; i<im2; i++) {
	             	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
                        u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	           }
			}
#pragma omp section
			{
				// Вычисляем новое значение.
	            // Только внутренность (граничные условия и так выполнены).
	            // Классический процесс Зейделя. при h1!=h2!=1.0;
	            for (int i=im2+1; i<m+1; i++) {
	               	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	            }
			}
	
		}
	}

	          int i=im2; 
	          for (int j=1; j<n+1; j++) {
#if MY_FLOAT
				  u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
				  u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		          	
		      }
	            
}

	 if (inumcore==4) {
	// четыре ядра.

	int im2=(int)((m+2)/2);
	int im4=(int)(im2/2);
	int im5=im2+im4;

#pragma omp parallel shared(u,A,rthdsd,URF)
	{
#pragma omp sections
		{
#pragma omp section
			{
               // Вычисляем новое значение.
	           // Только внутренность (граничные условия и так выполнены).
	           // Классический процесс Зейделя. при h1!=h2!=1.0;
	           for (int i=1; i<im4; i++) {
	             	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
	  u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
      u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	           }
			}
#pragma omp section
			{
               // Вычисляем новое значение.
	           // Только внутренность (граничные условия и так выполнены).
	           // Классический процесс Зейделя. при h1!=h2!=1.0;
	           for (int i=im4+1; i<im2; i++) {
	             	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
    u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
	u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	           }
			}
#pragma omp section
			{
				// Вычисляем новое значение.
	            // Только внутренность (граничные условия и так выполнены).
	            // Классический процесс Зейделя. при h1!=h2!=1.0;
	            for (int i=im2+1; i<im5; i++) {
	               	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	            }
			}
#pragma omp section
			{
				// Вычисляем новое значение.
	            // Только внутренность (граничные условия и так выполнены).
	            // Классический процесс Зейделя. при h1!=h2!=1.0;
	            for (int i=im5+1; i<m+1; i++) {
	               	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	            }
			}
	
		}
	}

	#pragma omp parallel shared(u,A,rthdsd,URF)
	{
#pragma omp sections
		{
#pragma omp section
			{
				 for (int i=im5; i<im5+1; i++) {
		for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
				 }
			}
			#pragma omp section
			{
 
 for (int i=im2; i<im2+1; i++) {
		for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
 }
			}
			#pragma omp section
			{
		for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[im4][j]=(1.0f-URF)*u[im4][j]+URF*(A[im4][j].aw*u[im4-1][j]+A[im4][j].as*u[im4][j-1]+A[im4][j].an*u[im4][j+1]+A[im4][j].ae*u[im4+1][j]+rthdsd[im4][j])/A[im4][j].ap;
#else
						u[im4][j]=(1.0-URF)*u[im4][j]+URF*(A[im4][j].aw*u[im4-1][j]+A[im4][j].as*u[im4][j-1]+A[im4][jm4].an*u[im4][j+1]+A[im4][j].ae*u[im4+1][j]+rthdsd[im4][j])/A[im4][j].ap;
#endif
		            	
		            }
			}
		}
	}

	
	   
		


			   }


	  if (inumcore==8) {
	// четыре ядра.

	int im2=(int)((m+2)/2);
	int im4=(int)(im2/2);
	int im5=im2+im4;
	int im6=(int)(im4/2);
	int im7=im4+im6;
	int im8=im2+im6;
	int im9=im5+im6;
#pragma omp parallel shared(u,A,rthdsd,URF)
	{
#pragma omp sections
		{
#pragma omp section
			{
               // Вычисляем новое значение.
	           // Только внутренность (граничные условия и так выполнены).
	           // Классический процесс Зейделя. при h1!=h2!=1.0;
	           for (int i=1; i<im6; i++) {
	             	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	           }
			}
#pragma omp section
			{
               // Вычисляем новое значение.
	           // Только внутренность (граничные условия и так выполнены).
	           // Классический процесс Зейделя. при h1!=h2!=1.0;
	           for (int i=im6; i<im4; i++) {
	             	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	           }
			}
#pragma omp section
			{
               // Вычисляем новое значение.
	           // Только внутренность (граничные условия и так выполнены).
	           // Классический процесс Зейделя. при h1!=h2!=1.0;
	           for (int i=im4; i<im7; i++) {
	             	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	           }
			}
#pragma omp section
			{
               // Вычисляем новое значение.
	           // Только внутренность (граничные условия и так выполнены).
	           // Классический процесс Зейделя. при h1!=h2!=1.0;
	           for (int i=im7; i<im2; i++) {
	             	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	           }
			}
#pragma omp section
			{
				// Вычисляем новое значение.
	            // Только внутренность (граничные условия и так выполнены).
	            // Классический процесс Зейделя. при h1!=h2!=1.0;
	            for (int i=im2; i<im8; i++) {
	               	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	            }
			}
#pragma omp section
			{
				// Вычисляем новое значение.
	            // Только внутренность (граничные условия и так выполнены).
	            // Классический процесс Зейделя. при h1!=h2!=1.0;
	            for (int i=im8; i<im5; i++) {
	               	for (int j=1; j<n+1; j++) {
						#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	            }
			}
#pragma omp section
			{
				// Вычисляем новое значение.
	            // Только внутренность (граничные условия и так выполнены).
	            // Классический процесс Зейделя. при h1!=h2!=1.0;
	            for (int i=im5; i<im9; i++) {
	               	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	            }
			}
#pragma omp section
			{
				// Вычисляем новое значение.
	            // Только внутренность (граничные условия и так выполнены).
	            // Классический процесс Зейделя. при h1!=h2!=1.0;
	            for (int i=im9; i<m+1; i++) {
	               	for (int j=1; j<n+1; j++) {
#if MY_FLOAT
						u[i][j]=(1.0f-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#else
						u[i][j]=(1.0-URF)*u[i][j]+URF*(A[i][j].aw*u[i-1][j]+A[i][j].as*u[i][j-1]+A[i][j].an*u[i][j+1]+A[i][j].ae*u[i+1][j]+rthdsd[i][j])/A[i][j].ap;
#endif
		            	
		            }
	            }
			}
	
		}
	}
			   }


#if MY_FLOAT
	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		u[i][0]=(1.0f-URF)*u[i][0]+URF*(A[i][0].an*u[i][1]+rthdsd[i][0])/A[i][0].ap;
		// верхняя граница
        u[i][n+1]=(1.0f-URF)*u[i][n+1]+URF*(A[i][n+1].as*u[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		u[0][j]=(1.0f-URF)*u[0][j]+URF*(A[0][j].ae*u[1][j]+rthdsd[0][j])/A[0][j].ap;
		// правая граница
		u[m+1][j]=(1.0f-URF)*u[m+1][j]+URF*(A[m+1][j].aw*u[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	}
#else
	// Граничные условия :
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		u[i][0]=(1.0-URF)*u[i][0]+URF*(A[i][0].an*u[i][1]+rthdsd[i][0])/A[i][0].ap;
		// верхняя граница
        u[i][n+1]=(1.0-URF)*u[i][n+1]+URF*(A[i][n+1].as*u[i][n]+rthdsd[i][n+1])/A[i][n+1].ap;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		u[0][j]=(1.0-URF)*u[0][j]+URF*(A[0][j].ae*u[1][j]+rthdsd[0][j])/A[0][j].ap;
		// правая граница
		u[m+1][j]=(1.0-URF)*u[m+1][j]+URF*(A[m+1][j].aw*u[m][j]+rthdsd[m+1][j])/A[m+1][j].ap;
	}
#endif

	

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
#if MY_FLOAT
	// левый нижний угол.
	u[0][0]=(1.0f-URF)*u[0][0]+URF*(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(1.0f-URF)*u[m+1][0]+URF*(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(1.0f-URF)*u[0][n+1]+URF*(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(1.0f-URF)*u[m+1][n+1]+URF*(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;
#else
	// левый нижний угол.
	u[0][0]=(1.0-URF)*u[0][0]+URF*(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(1.0-URF)*u[m+1][0]+URF*(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(1.0-URF)*u[0][n+1]+URF*(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(1.0-URF)*u[m+1][n+1]+URF*(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;
#endif
	


} // SORDirichlet_P

// Реализация метода прогонки для трёхдиагональной матрицы. 
// См. Гарбер Г.З. стр. 190, 191.
// См. С. Патанкар.
void fbright(int n, Real* alpha, Real* beta, Real* gamma, Real* delta, Real* &u) {

	   // equation
       //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	   // i==0..n-1
	   // alpha[0]==0.0 а u[-1] просто не существует.
	   // аналогично справа : gamma[n-1]==0.0 а u[n] не существует.

	   Real* P=new Real[n+1];
	   Real* Q=new Real[n+1];

	   // Значение P[0], Q[0] - не используется.

	   // прямая прогонка.
	   P[1]=gamma[0]/beta[0];
	   Q[1]=delta[0]/beta[0];

	   for (int i=1; i<n; i++) {
		   P[i+1]=gamma[i]/(-alpha[i]*P[i]+beta[i]);
		   Q[i+1]=(delta[i]+alpha[i]*Q[i])/(-alpha[i]*P[i]+beta[i]);
	   }

	   // Обратная прогонка.
	   // В случае условий Дирихле этого делать ненадо : не делать u[n-1]=Q[n-1].
	   u[n-1]=Q[n]; // Это нужно делать лишь в случае однородных условий Неймана (по видимому).
	   //u[n-1]=(delta[n-1]+alpha[n-1]*Q[n-2])/(-alpha[n-1]*P[n-2]+beta[n-1]);

	   for (int i=n-1; i>0; i--) {
		   u[i-1]=P[i]*u[i]+Q[i];
	   }

	   delete P;
	   delete Q;

} // fb

// Реализация метода прогонки для трёхдиагональной матрицы. 
// См. Гарбер Г.З. стр. 190, 191.
// См. С. Патанкар.
void fbright_pq(int n, Real* alpha, Real* beta, Real* gamma, Real* delta, Real* &P, Real* &Q, Real* &u) {

	   // equation
       //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	   // i==0..n-1
	   // alpha[0]==0.0 а u[-1] просто не существует.
	   // аналогично справа : gamma[n-1]==0.0 а u[n] не существует.

	   //Real* P=new Real[n+1];
	   //Real* Q=new Real[n+1];

	   // Значение P[0], Q[0] - не используется.

	   // прямая прогонка.
	   P[1]=gamma[0]/beta[0];
	   Q[1]=delta[0]/beta[0];

	   for (int i=1; i<n; i++) {
		   P[i+1]=gamma[i]/(-alpha[i]*P[i]+beta[i]);
		   Q[i+1]=(delta[i]+alpha[i]*Q[i])/(-alpha[i]*P[i]+beta[i]);
	   }

	   // Обратная прогонка.
	   // В случае условий Дирихле этого делать ненадо : не делать u[n-1]=Q[n-1].
	   u[n-1]=Q[n]; // Это нужно делать лишь в случае однородных условий Неймана (по видимому).
	   //u[n-1]=(delta[n-1]+alpha[n-1]*Q[n-2])/(-alpha[n-1]*P[n-2]+beta[n-1]);

	   for (int i=n-1; i>0; i--) {
		   u[i-1]=P[i]*u[i]+Q[i];
	   }

	   //delete P;
	   //delete Q;

} // fb_pq

// Реализация метода прогонки для трёхдиагональной матрицы. 
// См. Гарбер Г.З. стр. 190, 191.
// См. С. Патанкар.
// fbc - fb counter (серийная версия встречной прогонки).
void fbcounter(int n, Real* alpha, Real* beta, Real* gamma, Real* delta, Real* &u) {

	   // equation
       //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	   // i==0..n-1
	   // alpha[0]==0.0 а u[-1] просто не существует.
	   // аналогично справа : gamma[n-1]==0.0 а u[n] не существует.

	   Real* P=new Real[n+1];
	   Real* Q=new Real[n+1];

	   // Определим центральный узел на котором сойдутся прогонки с двух разных концов.
	   int i0=n/2-1; // целочисленное деление.

	   // Схема параллельного исполнения:
	   // Если точка i0 находится посередине то это обеспечивает необходимую балансировку параллельно выполняемых задач.
	   // рабочая секция 1 выполняется одновременно с рабочей секцией 2. 
	   // в точке i0 выполняется серийное сопряжение. Это последовательный участок кода.
	   // рабочая секция 3 может выполняться параллельно с секцией 4.

	   // рабочая секция 1. начало.

	   // правая прогонка прямой ход.
	   P[0]=gamma[0]/beta[0];
	   Q[0]=delta[0]/beta[0];

	   for (int i=1; i<=i0; i++) {
		   P[i]=gamma[i]/(-alpha[i]*P[i-1]+beta[i]);
		   Q[i]=(delta[i]+alpha[i]*Q[i-1])/(-alpha[i]*P[i-1]+beta[i]);
	   }

	   // рабочая секция 1. конец.

	   // рабочая секция 2. начало.

	   // левая прогонка прямой ход.
	   P[n]=alpha[n-1]/beta[n-1];
	   Q[n]=delta[n-1]/beta[n-1];

	   for (int i=n-1; i>i0+1; i--) {
		   P[i]=alpha[i-1]/(beta[i-1]-gamma[i-1]*P[i+1]);
		   Q[i]=(Q[i+1]*gamma[i-1]+delta[i-1])/(beta[i-1]-gamma[i-1]*P[i+1]);
	   }


	   // рабочая секцция 2. конец.

	   // Серийное сопряжение.
	   u[i0]=(Q[i0]+P[i0]*Q[i0+2])/(1.0-P[i0]*P[i0+2]); // Эта операция обязательно должна быть выполнена последовательно.

	   // Обратная прогонка.
	   
	   // рабочая секция 3. начало.

	   for (int i=i0; i>0; i--) {
		   u[i-1]=P[i-1]*u[i]+Q[i-1];
	   }

	   // рабочая секция 3. конец.

	   // рабочая секция 4. начало.

	   for (int i=i0; i<n-1; i++) {
		   u[i+1]=P[i+2]*u[i]+Q[i+2];
	   }

	   // рабочая секция 4. окончание.

	   delete P;
	   delete Q;

} // fbcounter

// Реализация метода прогонки для трёхдиагональной матрицы. 
// См. Гарбер Г.З. стр. 190, 191.
// См. С. Патанкар.
// fbc - fb counter (серийная версия встречной прогонки).
void fbcounter_pq(int n, Real* alpha, Real* beta, Real* gamma, Real* delta, Real* &P, Real* &Q, Real* &u) {

	   // equation
       //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	   // i==0..n-1
	   // alpha[0]==0.0 а u[-1] просто не существует.
	   // аналогично справа : gamma[n-1]==0.0 а u[n] не существует.

	   //Real* P=new Real[n+1];
	   //Real* Q=new Real[n+1];

	   // Определим центральный узел на котором сойдутся прогонки с двух разных концов.
	   int i0=n/2-1; // целочисленное деление.

	   // Схема параллельного исполнения:
	   // Если точка i0 находится посередине то это обеспечивает необходимую балансировку параллельно выполняемых задач.
	   // рабочая секция 1 выполняется одновременно с рабочей секцией 2. 
	   // в точке i0 выполняется серийное сопряжение. Это последовательный участок кода.
	   // рабочая секция 3 может выполняться параллельно с секцией 4.

	   // рабочая секция 1. начало.

	   // правая прогонка прямой ход.
	   P[0]=gamma[0]/beta[0];
	   Q[0]=delta[0]/beta[0];

	   for (int i=1; i<=i0; i++) {
		   P[i]=gamma[i]/(-alpha[i]*P[i-1]+beta[i]);
		   Q[i]=(delta[i]+alpha[i]*Q[i-1])/(-alpha[i]*P[i-1]+beta[i]);
	   }

	   // рабочая секция 1. конец.

	   // рабочая секция 2. начало.

	   // левая прогонка прямой ход.
	   P[n]=alpha[n-1]/beta[n-1];
	   Q[n]=delta[n-1]/beta[n-1];

	   for (int i=n-1; i>i0+1; i--) {
		   P[i]=alpha[i-1]/(beta[i-1]-gamma[i-1]*P[i+1]);
		   Q[i]=(Q[i+1]*gamma[i-1]+delta[i-1])/(beta[i-1]-gamma[i-1]*P[i+1]);
	   }


	   // рабочая секцция 2. конец.

	   // Серийное сопряжение.
	   u[i0]=(Q[i0]+P[i0]*Q[i0+2])/(1.0-P[i0]*P[i0+2]); // Эта операция обязательно должна быть выполнена последовательно.

	   // Обратная прогонка.
	   
	   // рабочая секция 3. начало.

	   for (int i=i0; i>0; i--) {
		   u[i-1]=P[i-1]*u[i]+Q[i-1];
	   }

	   // рабочая секция 3. конец.

	   // рабочая секция 4. начало.

	   for (int i=i0; i<n-1; i++) {
		   u[i+1]=P[i+2]*u[i]+Q[i+2];
	   }

	   // рабочая секция 4. окончание.

	   //delete P;
	   //delete Q;

} // fbcounter_pq

/*
// Реализация метода прогонки для трёхдиагональной матрицы. 
// См. Гарбер Г.З. стр. 190, 191.
// См. С. Патанкар.
// fbc - fb counter (серийная версия встречной прогонки).
// fbcp - fb counter parallel (параллельная версия встречной прогонки).
void fbcounter_parallel(int n, Real* alpha, Real* beta, Real* gamma, Real* delta, Real* &u) {

	   // equation
       //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	   // i==0..n-1
	   // alpha[0]==0.0 а u[-1] просто не существует.
	   // аналогично справа : gamma[n-1]==0.0 а u[n] не существует.

	   Real* P=new Real[n+1];
	   Real* Q=new Real[n+1];

	   // Определим центральный узел на котором сойдутся прогонки с двух разных концов.
	   int i0=n/2-1; // целочисленное деление.

	   // Схема параллельного исполнения:
	   // Если точка i0 находится посередине то это обеспечивает необходимую балансировку параллельно выполняемых задач.
	   // рабочая секция 1 выполняется одновременно с рабочей секцией 2. 
	   // в точке i0 выполняется серийное сопряжение. Это последовательный участок кода.
	   // рабочая секция 3 может выполняться параллельно с секцией 4.


	   // параллельное исполнение двумя потоками.
	   // shared - задаёт переменные общие для всех нитей.
#pragma omp parallel shared(P,Q, n, i0, alpha, beta, gamma, delta) 
	   {

#pragma omp sections firstprivate (i0)
		   {

	   // рабочая секция 1. начало.
#pragma omp section  
		   {
			   // повидимому переменные о которых не упомянуто остаются глобальными.

			   // пусть одна из нитей трудится над левой половиной расчётной области.
			   // В то же время вторая нить не будет ждать первую а продолжить вычислять код
			   // после первого сингла в секции 2.

	           // правая прогонка прямой ход.
	           P[0]=gamma[0]/beta[0];
	           Q[0]=delta[0]/beta[0];

        	   for (int i=1; i<=i0; i++) {
		           P[i]=gamma[i]/(-alpha[i]*P[i-1]+beta[i]);
		           Q[i]=(delta[i]+alpha[i]*Q[i-1])/(-alpha[i]*P[i-1]+beta[i]);
	           }

		   }
	   // рабочая секция 1. конец.

	   // рабочая секция 2. начало.
#pragma omp section  
		   {
			   // повидимому переменные о которых не упомянуто остаются глобальными.

			   // Внимание nowait не пишем, т.к. после окончания секцции 2 должна быть выполнена синхронизация.
			   // Вторая нить будет выполнять вторую секцию.
			   // Так как размеры секций равны то работа будет распределена более менее равномерно.

	           // левая прогонка прямой ход.
	           P[n]=alpha[n-1]/beta[n-1];
	           Q[n]=delta[n-1]/beta[n-1];

        	   for (int i=n-1; i>i0+1; i--) {
		           P[i]=alpha[i-1]/(beta[i-1]-gamma[i-1]*P[i+1]);
		           Q[i]=(Q[i+1]*gamma[i-1]+delta[i-1])/(beta[i-1]-gamma[i-1]*P[i+1]);
	           }

		   }

	   // рабочая секция 2. конец.
		   }

	   }

	   // Серийное сопряжение.
	   
		   // исполнение только нитью мастером.
		   // внимание к этому моменту должна быть выполнена синхронизация.

		   // Этот кусок выполняется также серийно чтобы избежать конфликтов по данным.
		   // begin
		   P[i0+1]=alpha[i0]/(beta[i0]-gamma[i0]*P[i0+2]);
		   Q[i0+1]=(Q[i0+2]*gamma[i0]+delta[i0])/(beta[i0]-gamma[i0]*P[i0+2]);
		   // end

	       u[i0]=(Q[i0]+P[i0]*Q[i0+2])/(1.0-P[i0]*P[i0+2]); // Эта операция обязательно должна быть выполнена последовательно.

		   // Этот кусок выполняется также серийно чтобы избежать конфликтов по данным.
		   // begin
		    u[i0-1]=P[i0-1]*u[i0]+Q[i0-1]; // обращение к u[i0] должно быть только одномоментным.
			//end
	   

#pragma omp parallel shared(P,Q,i0, n, u)
	   {
	   // Обратная прогонка.

#pragma omp sections firstprivate (i0) 
		   {
	   
	   // рабочая секция 3. начало.
#pragma omp section 
	   {
		   // повидимому переменные о которых не упомянуто остаются глобальными.

	       for (int i=i0-1; i>0; i--) {
		       u[i-1]=P[i-1]*u[i]+Q[i-1];
	       }

	   }

	   // рабочая секция 3. конец.

	   // рабочая секция 4. начало.
#pragma omp section 
	   {

		   // повидимому переменные о которых не упомянуто остаются глобальными.

	       for (int i=i0; i<n-1; i++) {
		       u[i+1]=P[i+2]*u[i]+Q[i+2];
	       }

	   }

	   // рабочая секция 4. окончание.
		   }

	   }

	   delete P;
	   delete Q;

} // fbcounter_parallel*/

/*
// Реализация метода прогонки для трёхдиагональной матрицы. 
// См. Гарбер Г.З. стр. 190, 191.
// См. С. Патанкар.
// fbc - fb counter (серийная версия встречной прогонки).
// fbcp - fb counter parallel (параллельная версия встречной прогонки).
void fbcounter_parallel(int n, Real* alpha, Real* beta, Real* gamma, Real* delta, Real* &u) {

	   // equation
       //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	   // i==0..n-1
	   // alpha[0]==0.0 а u[-1] просто не существует.
	   // аналогично справа : gamma[n-1]==0.0 а u[n] не существует.

	   Real* P=new Real[n+1];
	   Real* Q=new Real[n+1];

	   // Определим центральный узел на котором сойдутся прогонки с двух разных концов.
	   int i0=n/2-1; // целочисленное деление.

	   Real* P1=new Real[i0+1];
	   Real* Q1=new Real[i0+1];

	   // Схема параллельного исполнения:
	   // Если точка i0 находится посередине то это обеспечивает необходимую балансировку параллельно выполняемых задач.
	   // рабочая секция 1 выполняется одновременно с рабочей секцией 2. 
	   // в точке i0 выполняется серийное сопряжение. Это последовательный участок кода.
	   // рабочая секция 3 может выполняться параллельно с секцией 4.


	   // параллельное исполнение двумя потоками.
	   // shared - задаёт переменные общие для всех нитей.
#pragma omp parallel num_threads(2) shared(P1,Q1, P,Q, n, i0, alpha, beta, gamma, delta) 
	   {

#pragma omp sections firstprivate (i0)
		   {

	   // рабочая секция 1. начало.
#pragma omp section  
		   {
			   // повидимому переменные о которых не упомянуто остаются глобальными.

			   // пусть одна из нитей трудится над левой половиной расчётной области.
			   // В то же время вторая нить не будет ждать первую а продолжить вычислять код
			   // после первого сингла в секции 2.

	           // правая прогонка прямой ход.
	           P1[0]=gamma[0]/beta[0];
	           Q1[0]=delta[0]/beta[0];

        	   for (int i=1; i<=i0; i++) {
		           P1[i]=gamma[i]/(-alpha[i]*P1[i-1]+beta[i]);
		           Q1[i]=(delta[i]+alpha[i]*Q1[i-1])/(-alpha[i]*P1[i-1]+beta[i]);
	           }

		   }
	   // рабочая секция 1. конец.

	   // рабочая секция 2. начало.
#pragma omp section  
		   {
			   // повидимому переменные о которых не упомянуто остаются глобальными.

			   // Внимание nowait не пишем, т.к. после окончания секцции 2 должна быть выполнена синхронизация.
			   // Вторая нить будет выполнять вторую секцию.
			   // Так как размеры секций равны то работа будет распределена более менее равномерно.

	           // левая прогонка прямой ход.
	           P[n]=alpha[n-1]/beta[n-1];
	           Q[n]=delta[n-1]/beta[n-1];

        	   for (int i=n-1; i>i0+1; i--) {
		           P[i]=alpha[i-1]/(beta[i-1]-gamma[i-1]*P[i+1]);
		           Q[i]=(Q[i+1]*gamma[i-1]+delta[i-1])/(beta[i-1]-gamma[i-1]*P[i+1]);
	           }

		   }

	   // рабочая секция 2. конец.
		   }

	   }

	   // Серийное сопряжение.
	   
		   // исполнение только нитью мастером.
		   // внимание к этому моменту должна быть выполнена синхронизация.

		   // Этот кусок выполняется также серийно чтобы избежать конфликтов по данным.
		   // begin
		   //P[i0+1]=alpha[i0]/(beta[i0]-gamma[i0]*P[i0+2]);
		   //Q[i0+1]=(Q[i0+2]*gamma[i0]+delta[i0])/(beta[i0]-gamma[i0]*P[i0+2]);
		   // end

	       u[i0]=(Q1[i0]+P1[i0]*Q[i0+2])/(1.0-P1[i0]*P[i0+2]); // Эта операция обязательно должна быть выполнена последовательно.

		   // Этот кусок выполняется также серийно чтобы избежать конфликтов по данным.
		   // begin
		    u[i0-1]=P1[i0-1]*u[i0]+Q1[i0-1]; // обращение к u[i0] должно быть только одномоментным.
			//end
	   

#pragma omp parallel num_threads(2) shared(P,Q,P1,Q1,i0, n, u)
	   {
	   // Обратная прогонка.

#pragma omp sections firstprivate (i0) 
		   {
	   
	   // рабочая секция 3. начало.
#pragma omp section 
	   {
		   // повидимому переменные о которых не упомянуто остаются глобальными.

	       for (int i=i0-1; i>0; i--) {
		       u[i-1]=P1[i-1]*u[i]+Q1[i-1];
	       }

	   }

	   // рабочая секция 3. конец.

	   // рабочая секция 4. начало.
#pragma omp section 
	   {

		   // повидимому переменные о которых не упомянуто остаются глобальными.

	       for (int i=i0; i<n-1; i++) {
		       u[i+1]=P[i+2]*u[i]+Q[i+2];
	       }

	   }

	   // рабочая секция 4. окончание.
		   }

	   }

	   delete P;
	   delete Q;

	   delete P1;
	   delete Q1;


} // fbcounter_parallel*/

/*
// Реализация метода прогонки для трёхдиагональной матрицы. 
// См. Гарбер Г.З. стр. 190, 191.
// См. С. Патанкар.
// fbc - fb counter (серийная версия встречной прогонки).
// fbcp - fb counter parallel (параллельная версия встречной прогонки).
void fbcounter_parallel(int n, Real* alpha, Real* beta, Real* gamma, Real* delta, Real* &u) {

	   // equation
       //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	   // i==0..n-1
	   // alpha[0]==0.0 а u[-1] просто не существует.
	   // аналогично справа : gamma[n-1]==0.0 а u[n] не существует.

	   Real* P=new Real[n+1];
	   Real* Q=new Real[n+1];

	   // Определим центральный узел на котором сойдутся прогонки с двух разных концов.
	   int i0=n/2-1; // целочисленное деление.
	   int i0dubl=i0;

	   Real* P1=new Real[i0+1];
	   Real* Q1=new Real[i0+1];

	   // Схема параллельного исполнения:
	   // Если точка i0 находится посередине то это обеспечивает необходимую балансировку параллельно выполняемых задач.
	   // рабочая секция 1 выполняется одновременно с рабочей секцией 2. 
	   // в точке i0 выполняется серийное сопряжение. Это последовательный участок кода.
	   // рабочая секция 3 может выполняться параллельно с секцией 4.


	   // параллельное исполнение двумя потоками.
	   // shared - задаёт переменные общие для всех нитей.
//#pragma omp parallel num_threads(2) shared(P1,Q1, P,Q, n, i0, alpha, beta, gamma, delta) 
	//   {

#pragma omp sections 
		   {

	   // рабочая секция 1. начало.
#pragma omp section  
		   {
			   // повидимому переменные о которых не упомянуто остаются глобальными.

			   // пусть одна из нитей трудится над левой половиной расчётной области.
			   // В то же время вторая нить не будет ждать первую а продолжить вычислять код
			   // после первого сингла в секции 2.

	           // правая прогонка прямой ход.
	           P1[0]=gamma[0]/beta[0];
	           Q1[0]=delta[0]/beta[0];

        	   for (int i=1; i<=i0dubl; i++) {
		           P1[i]=gamma[i]/(-alpha[i]*P1[i-1]+beta[i]);
		           Q1[i]=(delta[i]+alpha[i]*Q1[i-1])/(-alpha[i]*P1[i-1]+beta[i]);
	           }

		   }
	   // рабочая секция 1. конец.

	   // рабочая секция 2. начало.
#pragma omp section  
		   {
			   // повидимому переменные о которых не упомянуто остаются глобальными.

			   // Внимание nowait не пишем, т.к. после окончания секцции 2 должна быть выполнена синхронизация.
			   // Вторая нить будет выполнять вторую секцию.
			   // Так как размеры секций равны то работа будет распределена более менее равномерно.

	           // левая прогонка прямой ход.
	           P[n]=alpha[n-1]/beta[n-1];
	           Q[n]=delta[n-1]/beta[n-1];

        	   for (int i=n-1; i>i0+1; i--) {
		           P[i]=alpha[i-1]/(beta[i-1]-gamma[i-1]*P[i+1]);
		           Q[i]=(Q[i+1]*gamma[i-1]+delta[i-1])/(beta[i-1]-gamma[i-1]*P[i+1]);
	           }

		   }

	   // рабочая секция 2. конец.
		   }

#pragma omp barrier

	  // }

	   // Серийное сопряжение.
	   
		   // исполнение только нитью мастером.
		   // внимание к этому моменту должна быть выполнена синхронизация.

		   // Этот кусок выполняется также серийно чтобы избежать конфликтов по данным.
		   // begin
		   //P[i0+1]=alpha[i0]/(beta[i0]-gamma[i0]*P[i0+2]);
		   //Q[i0+1]=(Q[i0+2]*gamma[i0]+delta[i0])/(beta[i0]-gamma[i0]*P[i0+2]);
		   // end

	       u[i0]=(Q1[i0]+P1[i0]*Q[i0+2])/(1.0-P1[i0]*P[i0+2]); // Эта операция обязательно должна быть выполнена последовательно.

		   // Этот кусок выполняется также серийно чтобы избежать конфликтов по данным.
		   // begin
		    u[i0-1]=P1[i0-1]*u[i0]+Q1[i0-1]; // обращение к u[i0] должно быть только одномоментным.
			//end
	   

//#pragma omp parallel num_threads(2) shared(P,Q,P1,Q1,i0, n, u)
	//   {
	   // Обратная прогонка.

#pragma omp sections  
		   {
	   
	   // рабочая секция 3. начало.
#pragma omp section 
	   {
		   // повидимому переменные о которых не упомянуто остаются глобальными.

	       for (int i=i0-1; i>0; i--) {
		       u[i-1]=P1[i-1]*u[i]+Q1[i-1];
	       }

	   }

	   // рабочая секция 3. конец.

	   // рабочая секция 4. начало.
#pragma omp section 
	   {

		   // повидимому переменные о которых не упомянуто остаются глобальными.

	       for (int i=i0dubl; i<n-1; i++) {
		       u[i+1]=P[i+2]*u[i]+Q[i+2];
	       }

	   }

	   // рабочая секция 4. окончание.
		   }

	  // }

		   #pragma omp barrier

	   delete P;
	   delete Q;

	   delete P1;
	   delete Q1;


} // fbcounter_parallel
*/

// Реализация метода прогонки для трёхдиагональной матрицы. 
// См. Гарбер Г.З. стр. 190, 191.
// См. С. Патанкар.
// fbc - fb counter (серийная версия встречной прогонки).
// fbcp - fb counter parallel (параллельная версия встречной прогонки).
void fbcounter_parallel(int n, Real* alpha, Real* beta, Real* gamma, Real* delta, Real* &u) {

	   // equation
       //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	   // i==0..n-1
	   // alpha[0]==0.0 а u[-1] просто не существует.
	   // аналогично справа : gamma[n-1]==0.0 а u[n] не существует.

	   Real* P=new Real[n+1];
	   Real* Q=new Real[n+1];

	   // Определим центральный узел на котором сойдутся прогонки с двух разных концов.
	   int i0=n/2-1; // целочисленное деление.
	   int i0dubl=i0;


	   // Схема параллельного исполнения:
	   // Если точка i0 находится посередине то это обеспечивает необходимую балансировку параллельно выполняемых задач.
	   // рабочая секция 1 выполняется одновременно с рабочей секцией 2. 
	   // в точке i0 выполняется серийное сопряжение. Это последовательный участок кода.
	   // рабочая секция 3 может выполняться параллельно с секцией 4.


	   // параллельное исполнение двумя потоками.
	   // shared - задаёт переменные общие для всех нитей.
//intel//#pragma omp parallel num_threads(2) shared( P,Q, n, i0, alpha, beta, gamma, delta) 
   {

//#pragma omp sections 
	//	   {

	   // рабочая секция 1. начало.
//#pragma omp section  
	//	   {

	 //intel//  int num=omp_get_thread_num();

	//intel//   if (num == 0) {
			   // повидимому переменные о которых не упомянуто остаются глобальными.

			   // пусть одна из нитей трудится над левой половиной расчётной области.
			   // В то же время вторая нить не будет ждать первую а продолжить вычислять код
			   // после первого сингла в секции 2.

	           // правая прогонка прямой ход.
	           P[0]=gamma[0]/beta[0];
	           Q[0]=delta[0]/beta[0];

        	   for (int i=1; i<=i0dubl; i++) {
		           P[i]=gamma[i]/(-alpha[i]*P[i-1]+beta[i]);
		           Q[i]=(delta[i]+alpha[i]*Q[i-1])/(-alpha[i]*P[i-1]+beta[i]);
	           }

	  //intel// }

		  // }
	   // рабочая секция 1. конец.

	   // рабочая секция 2. начало.
//#pragma omp section  
	//	   {

	  //intel//  if (num == 1) {
			   // повидимому переменные о которых не упомянуто остаются глобальными.

			   // Внимание nowait не пишем, т.к. после окончания секцции 2 должна быть выполнена синхронизация.
			   // Вторая нить будет выполнять вторую секцию.
			   // Так как размеры секций равны то работа будет распределена более менее равномерно.

	           // левая прогонка прямой ход.
	           P[n]=alpha[n-1]/beta[n-1];
	           Q[n]=delta[n-1]/beta[n-1];

        	   for (int i=n-1; i>i0+1; i--) {
		           P[i]=alpha[i-1]/(beta[i-1]-gamma[i-1]*P[i+1]);
		           Q[i]=(Q[i+1]*gamma[i-1]+delta[i-1])/(beta[i-1]-gamma[i-1]*P[i+1]);
	           }

		//intel//}

		   //}

	   // рабочая секция 2. конец.
		 //  }

		//intel//#pragma omp barrier
   }



	  // }

	   // Серийное сопряжение.
	   
		   // исполнение только нитью мастером.
		   // внимание к этому моменту должна быть выполнена синхронизация.

		   // Этот кусок выполняется также серийно чтобы избежать конфликтов по данным.
		   // begin
		   //P[i0+1]=alpha[i0]/(beta[i0]-gamma[i0]*P[i0+2]);
		   //Q[i0+1]=(Q[i0+2]*gamma[i0]+delta[i0])/(beta[i0]-gamma[i0]*P[i0+2]);
		   // end

	       u[i0]=(Q[i0]+P[i0]*Q[i0+2])/(1.0-P[i0]*P[i0+2]); // Эта операция обязательно должна быть выполнена последовательно.

		   // Этот кусок выполняется также серийно чтобы избежать конфликтов по данным.
		   // begin
		    u[i0-1]=P[i0-1]*u[i0]+Q[i0-1]; // обращение к u[i0] должно быть только одномоментным.
			//end
	   

//intel//#pragma omp parallel num_threads(2) shared(P,Q, i0, n, u)
   {
	   // Обратная прогонка.

//#pragma omp sections  
	//	   {
	   
	   // рабочая секция 3. начало.
//#pragma omp section 
	//   {
	 //intel//  int num=omp_get_thread_num();

	 //intel//  if (num == 0 ) 
	   {
		   // повидимому переменные о которых не упомянуто остаются глобальными.

	       for (int i=i0-1; i>0; i--) {
		       u[i-1]=P[i-1]*u[i]+Q[i-1];
	       }

	  // }
   }

	   // рабочая секция 3. конец.

	   // рабочая секция 4. начало.
//#pragma omp section 
	//   {
	 //intel//  if (num == 1) 
	   {
		   // повидимому переменные о которых не упомянуто остаются глобальными.

	       for (int i=i0dubl; i<n-1; i++) {
		       u[i+1]=P[i+2]*u[i]+Q[i+2];
	       }

   }
	  // }

	   // рабочая секция 4. окончание.
		//   }

	  // }

		//intel//   #pragma omp barrier
   }

	   delete P;
	   delete Q;


} // fbcounter_parallel

// Реализация метода прогонки для трёхдиагональной матрицы. 
// См. Гарбер Г.З. стр. 190, 191.
// См. С. Патанкар.
void fb(int n, Real* alpha, Real* beta, Real* gamma, Real* delta, Real* &u) {
	 // equation
     //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	 // i==0..n-1
     //fbright(n, alpha, beta, gamma, delta, u); // правая прогонка
	 fbcounter(n, alpha, beta, gamma, delta, u); // встречная прогонка.
	//fbcounter_parallel(n, alpha, beta, gamma, delta, u); // параллельная версия встречной прогонки. // работает только при включённом OpenMP
}

// Реализация метода прогонки для трёхдиагональной матрицы. 
// См. Гарбер Г.З. стр. 190, 191.
// См. С. Патанкар.
// Эта версия от 11% до 39% быстрее версии fb.
// Из за тго что выделение и уничтожение памяти не производится многократно.
void fb_pq(int n, Real* alpha, Real* beta, Real* gamma, Real* delta, Real* &P, Real* &Q, Real* &u) {
	 // equation
     //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	 // i==0..n-1
	 // P and Q прогоночные коэффициенты.
     //fbright_pq(n, alpha, beta, gamma, delta, P,Q, u); // правая прогонка
	 fbcounter_pq(n, alpha, beta, gamma, delta, P,Q, u); // встречная прогонка.
	 //fbcounter_parallel_pq(n, alpha, beta, gamma, delta, P,Q, u); // параллельная версия встречной прогонки.
}


// полинейный метод решения.
void LRsolve(Real** &u, Real** rthdsd, MATRNODE** &A,
	       int m, int n) {

	// A - матрица СЛАУ.

	// equation
    //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	// i==0..n-1

    Real* alpha;
	Real* beta;
	Real* gamma;
	Real* delta;
	Real* ul;
	// ускорим.
	Real *P, *Q;

	// Горизонтальные прогонки.
	alpha=new Real[m+2];
	beta=new Real[m+2];
	gamma=new Real[m+2];
	delta=new Real[m+2];
	ul=new Real[m+2];
	// память будем выделять централизованно.
	P=new Real[m+3];
	Q=new Real[m+3];

//#pragma omp parallel for
	for (int j=1; j<n+1; j++) {

		for (int i=0; i<m+2; i++) {
			if (i==0) {
				alpha[0]=0.0;
				gamma[0]=A[i][j].ae; // 0.0 Дирихле
				beta[0]=A[i][j].ap;
				delta[0]=rthdsd[0][j]; // u[0][j] Дирихле
			}
			else if (i==m+1) {
				gamma[m+1]=0.0;
				alpha[m+1]=A[i][j].aw; // 0.0 Дирихле
				beta[m+1]=A[i][j].ap;
				delta[m+1]=rthdsd[m+1][j]; // u[m+1][j] Дирихле
			}
			else {
				gamma[i]=A[i][j].ae;
				alpha[i]=A[i][j].aw; 
				beta[i]=A[i][j].ap;
				delta[i]=rthdsd[i][j]+A[i][j].an*u[i][j+1]+A[i][j].as*u[i][j-1]; // плюс rthdsd !
			}
			ul[i]=u[i][j];	
		}

		fb(m+2, alpha, beta, gamma, delta, ul); // прогонка.
		//fb_pq(m+2, alpha, beta, gamma, delta, P, Q, ul); // прогонка.

		for (int i=0; i<m+2; i++) {
			u[i][j]=ul[i];
		}
	}

	delete[] alpha;
	delete[] beta;
	delete[] gamma;
	delete[] delta;
	delete[] ul;
	// ускорение
	delete[] P;
	delete[] Q;

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;

	
	// Вертикальные прогонки.
	alpha=new Real[n+2];
	beta=new Real[n+2];
	gamma=new Real[n+2];
	delta=new Real[n+2];
	ul=new Real[n+2];
	// ускорение операций.
	P=new Real[n+3];
	Q=new Real[n+3];

//#pragma omp parallel for
	for (int j=1; j<m+1; j++) {

		for (int i=0; i<n+2; i++) {
			if (i==0) {
				alpha[0]=0.0;
				gamma[0]=A[j][i].an; // 0.0 Дирихле
				beta[0]=A[j][i].ap;
				delta[0]=rthdsd[j][0]; // u[j][0]
			}
			else if (i==n+1) {
				gamma[n+1]=0.0;
				alpha[n+1]=A[j][i].as; // 0.0 Дирихле
				beta[n+1]=A[j][i].ap;
				delta[n+1]=rthdsd[j][n+1]; // u[j][n+1]
			}
			else {
				gamma[i]=A[j][i].an;
				alpha[i]=A[j][i].as; 
				beta[i]=A[j][i].ap;
				delta[i]=rthdsd[j][i]+A[j][i].ae*u[j+1][i]+A[j][i].aw*u[j-1][i]; // плюс rthdsd
			}
			ul[i]=u[j][i];	
		}

		fb(n+2, alpha, beta, gamma, delta, ul); // прогонка.
		//fb_pq(n+2, alpha, beta, gamma, delta, P,Q, ul); // прогонка.

		for (int i=0; i<n+2; i++) {
			u[j][i]=ul[i];
		}
	}

	delete[] alpha;
	delete[] beta;
	delete[] gamma;
	delete[] delta;
	delete[] ul;
	// уничтожение памяти
	delete[] P;
	delete[] Q;
	
	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;

} // LR


// Алгоритм В.Г. Зверева 1999 года.
// "Об одном итерационном алгоритме решения разностных эллиптических уравнений".
// Томский государственный университет.
// Алгоритм основан на идее усиления эллиптичности.
void ZVERsolve(Real** &u, Real** &rthdsd, MATRNODE** &A,
	           Real** &ksi, Real** &etta, Real** &gam, Real** &d, Real theta,
			   //Real** &rthdsd, 
	           int m, int n) {

	// Внимание!!! внутри одной итерации нельзя тратить время на выделение и уничтожение памяти, т.к. это занимает в сумме больше времени
	// чем время чистого счёта.

	// rthdsd_original - истинная правая часть уравнения, а rthdsd - локальная правая часть использующаяся только внутри данной процедуры ZVERsolve.

	// theta - параметр релаксации в алгоритме Зверева.
	// A - матрица СЛАУ.

	// equation
    //beta[i]*u[i]=gamma[i]*u[i+1]+alpha[i]*u[i-1]+delta[i]
	// i==0..n-1

	//Real** rthdsd; Внимание никакого выделения памяти быть не должно.
	//my_alloc_universal(rthdsd,m,n);
	/*
	for (int i=0; i<m+2; i++) {
	    for (int j=0; j<n+2; j++) {
			rthdsd[i][j]=rthdsd_original[i][j];
		}
	}


	for (int j=0; j<n+2; j++) {
		rthdsd[m+1][j]=u[m+1][j];
		rthdsd[0][j]=u[0][j];
	}
	for (int i=1; i<m+1; i++) {
		rthdsd[i][n+1]=u[i][n+1];
		rthdsd[i][0]=u[i][0];
	}
	*/
	
    Real* alpham;
	Real* betam;
	Real* gammam;
	Real* deltam;
	Real* ulm;

	// Горизонтальные прогонки.
	alpham=new Real[m+2];
	betam=new Real[m+2];
	gammam=new Real[m+2];
	deltam=new Real[m+2];
	ulm=new Real[m+2];
	

	for (int i=0; i<m+2; i++) {
	    for (int j=0; j<n+2; j++) {
			ksi[i][j]=0.0;
			etta[i][j]=0.0;
		}
	}

	/*
	for (int i=1; i<m+1; i++) {
		ksi[i][n+1]=0.0; // в условиях Дирихле (Если Нейман то уже не ноль)
		etta[i][n+1]=u[i][n+1]; // Краевое условие Дирихле.
	}*/
		
	// Левая пргонка для нахождения ksi && etta
	for (int i=1; i<m+1; i++) {
	    for (int j=n+1; j>0; j--) {
			Real z1=A[i][j].ap-theta*(A[i][j].ae+A[i][j].aw)-A[i][j].an*ksi[i][j];
			ksi[i][j-1]=A[i][j].as/(z1);
			etta[i][j-1]=(rthdsd[i][j]+A[i][j].ae*u[i+1][j]+A[i][j].aw*u[i-1][j]-theta*(A[i][j].ae+A[i][j].aw)*u[i][j]+A[i][j].an*etta[i][j])/(z1);
		}
	}


	// Горизонтальные прогонки.
	for (int j=1; j<n+1; j++) {

		for (int i=0; i<m+2; i++) {
			if (i==0) {
				alpham[0]=0.0;
				gammam[0]=A[i][j].ae; // 0.0 Дирихле
				betam[0]=A[i][j].ap;
				deltam[0]=rthdsd[0][j]; // u[0][j]
			}
			else if (i==m+1) {
				gammam[m+1]=0.0;
				alpham[m+1]=A[i][j].aw; // 0.0 Дирихле
				betam[m+1]=A[i][j].ap;
				deltam[m+1]=rthdsd[m+1][j]; // u[m+1][j]
			}
			else {
				gammam[i]=A[i][j].ae;
				alpham[i]=A[i][j].aw; 
				betam[i]=A[i][j].ap-A[i][j].an*ksi[i][j];
				deltam[i]=rthdsd[i][j]+A[i][j].an*etta[i][j]+A[i][j].as*u[i][j-1]; // плюс rthdsd !
			}
			ulm[i]=u[i][j];	
		}

		fb(m+2, alpham, betam, gammam, deltam, ulm); // прогонка.

		for (int i=0; i<m+2; i++) {
			u[i][j]=ulm[i];
		}
	}

	
	delete alpham;
	delete betam;
	delete gammam;
	delete deltam;
	delete ulm;


	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;
	
	// Вертикальные прогонки.
	 Real* alphan;
	Real* betan;
	Real* gamman;
	Real* deltan;
	Real* uln;

	alphan=new Real[n+2];
	betan=new Real[n+2];
	gamman=new Real[n+2];
	deltan=new Real[n+2];
	uln=new Real[n+2];
	

	for (int i=0; i<m+2; i++) {
	    for (int j=0; j<n+2; j++) {
			gam[i][j]=0.0;
			d[i][j]=0.0;
		}
	}

	/*
	for (int j=1; j<n+1; j++) {
		gam[m+1][j]=0.0; // в условиях Дирихле (Если Нейман то уже не ноль)
		d[m+1][j]=u[m+1][j]; // Краевое условие Дирихле.	
	}*/
	
		
	// Левая пргонка для нахождения ksi && etta
	for (int i=m+1; i>0; i--) {
	    for (int j=1; j<n+1; j++) {
			Real z1=A[i][j].ap-theta*(A[i][j].an+A[i][j].as)-A[i][j].ae*gam[i][j];
			gam[i-1][j]=A[i][j].aw/(z1);
			d[i-1][j]=(rthdsd[i][j]+A[i][j].an*u[i][j+1]+A[i][j].as*u[i][j-1]-theta*(A[i][j].an+A[i][j].as)*u[i][j]+A[i][j].ae*d[i][j])/(z1);
		}
	}


	// Вертикальные прогонки.
	for (int j=1; j<m+1; j++) {

		for (int i=0; i<n+2; i++) {
			if (i==0) {
				alphan[0]=0.0;
				gamman[0]=A[j][i].an; // 0.0 Дирихле
				betan[0]=A[j][i].ap;
				deltan[0]=rthdsd[j][0]; // u[j][0]
			}
			else if (i==n+1) {
				gamman[n+1]=0.0;
				alphan[n+1]=A[j][i].as; // 0.0 Дирихле
				betan[n+1]=A[j][i].ap;
				deltan[n+1]=rthdsd[j][n+1]; // u[j][n+1]
			}
			else {
				gamman[i]=A[j][i].an;
				alphan[i]=A[j][i].as; 
				betan[i]=A[j][i].ap-A[j][i].ae*gam[j][i];
				deltan[i]=rthdsd[j][i]+A[j][i].ae*d[j][i]+A[j][i].aw*u[j-1][i]; // плюс rthdsd
			}
			uln[i]=u[j][i];	
		}

		fb(n+2, alphan, betan, gamman, deltan, uln); // прогонка.

		for (int i=0; i<n+2; i++) {
			u[j][i]=uln[i];
		}
	}

	
	delete alphan;
	delete betan;
	delete gamman;
	delete deltan;
	delete uln;
	

	// Внимание !!! никакого уничтожения памяти быть недолжно так как нету и выделения памяти.
	// Вся память должна быть выделена заранее вне итерационного цикла.
	//my_free_universal(rthdsd,m,n);
	
	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;

} // ZVER



// прослойка для запуска методов подпространства Крылова.
void itsolve_krjlov(Real** &u, Real** &u_old, Real** &r,
	              Real** rthdsd, int m, int n, int ialg, MATRNODE** &A, int iend) {

	int ialg_loc=CongruateGradient; // BiCGStab

    if (ialg==BiCGStabalg) {
		ialg_loc=BiCGStab;
		ialg=CGalg; // изменяем локальную копию.
	}

	if (ialg == GMRESalg) {
		ialg_loc = GMRESalg;
		ialg = CGalg; // изменяем локальную копию.
	}
	

    // шаг 1. условия Дирихле и сохранение симметричности.
	Real eps0=1.0e-30; // пороговая точность распознания условия Дирихле.
	//int ialg=CGalg;//ICCGalg; //CGalg; 
	/*
	// Симметризация СЛАУ.
	int imaxnumbernode=(m+2)*(n+2); // количество расчётных узлов сетки.
	bool *bdirichlet=new bool[imaxnumbernode];
	for (int k1=0; k1<imaxnumbernode; k1++) {
		bdirichlet[k1]=false; // пока это не узел с условием Дирихле.
	}
	
	for (int j=0; j<n+2; j++) {
		for (int i=0; i<m+2; i++) {
			// внутренний узел
			if ((fabs(A[i][j].ae)<eps0) && (fabs(A[i][j].aw)<eps0) && (fabs(A[i][j].an)<eps0) && (fabs(A[i][j].as)<eps0)) {
				bdirichlet[i+j*(m+2)]=true;
			}
		}
	}
	// правка db_loc и коэффициентов матрицы СЛАУ.
	
	for (int j=0; j<n+2; j++) {
		for (int i=0; i<m+2; i++) {
			// внутренний узел
			int ipi=i+j*(m+2);
			if (!bdirichlet[ipi]) {
				// Не условие Дирихле в узле.
				int iei=i+1+j*(m+2);
				if (i<m+1) {
				  if (bdirichlet[iei]) {
					  rthdsd[i][j]+=A[i][j].ae*rthdsd[i+1][j]/A[i+1][j].ap;
					  A[i][j].ae=0.0;
				  }
				}
				int iwi=i-1+j*(m+2);
				if (i-1>=0) {
				  if (bdirichlet[iwi]) {
					  rthdsd[i][j]+=A[i][j].aw*rthdsd[i-1][j]/A[i-1][j].ap;
					  A[i][j].aw=0.0;
				  }
				}
				int ini=i+(j+1)*(m+2);
				if (j<n+1) {
				  if (bdirichlet[ini]) {
					  rthdsd[i][j]+=A[i][j].an*rthdsd[i][j+1]/A[i][j+1].ap;
					  A[i][j].an=0.0;
				  }
				}
				int isi=i+(j-1)*(m+2);
				if (j-1>=0) {
				  if (bdirichlet[isi]) {
					  rthdsd[i][j]+=A[i][j].as*rthdsd[i][j-1]/A[i][j-1].ap;
					  A[i][j].as=0.0;
				  }
				}
			}
		}
	}


	delete bdirichlet;
	*/
	// Конец симметризации СЛАУ.

	

	// myrP - невязка.
	int k=0; // количество элементов в разреженной матрице.
	int il=0; // количество уравнений которое требуется решить
	

	

	for (int j=0; j<n+2; j++) {
		for (int i=0; i<m+2; i++) {
			//Только не угловые точки:
			if (!(((i==0)&&(j==0))||((i==m+1)&&(j==0))||((i==m+1)&&(j==n+1))||((i==0)&&(j==n+1)))) {



			   // внутренний узел
			   il++; 
			   if (fabs(A[i][j].ae)>eps0) k++;
			   if (fabs(A[i][j].aw)>eps0) k++;
			   if (fabs(A[i][j].an)>eps0) k++;
			   if (fabs(A[i][j].as)>eps0) k++;
			   if (fabs(A[i][j].ap)>eps0) k++;
			}
		}
	}

	//printf("k=%d, il=%d, m=%d, n=%d\n",k,il,m,n); // debug
	//getchar();

	TmyNonZeroElemMatrix *nze=new TmyNonZeroElemMatrix[k+1]; // ненулевые элементы которые потом придётся сортировать по строкам
	
	// выделение памяти под вектор правой части
	Real *dV1=new Real[il];
	 // выделение памяти под результат вычисления
	Real *dx=new Real[il];

   // обнуление матрицы dА
   // здесь было от 1 до iNelem
   for(int  k1=0; k1<=k; k1++) 
   {
      // инициализация
      // массива для хранения
      // ненулевых элементов
      nze[k1].i=-2000;
      nze[k1].j=-2000;
      nze[k1].aij=0.0;
      nze[k1].key=-2000;
	  nze[k1].bNei=false;
	  nze[k1].bugol=false;

   }

   

   for (int k1=0; k1<=il-1; k1++)
   {
	  dV1[k1]=0.0;  // инициализация вектора правой части
   }

   // прямое преобразование
   // Память лучше выделять в Delphi.
   int *pointerlist=new int[il];
   for (int i1=0; i1<il; i1++) {
       pointerlist[i1]=-1; // инициализация !!!
   }
    // обратное преобразование
   int *pointerlistrevers=new int[(m+2)*(n+2)]; // выделение памяти
   
   // инициализация
   // номер -1 соответствует hollow point
   for (int i1=0; i1<il; i1++)  pointerlistrevers[i1]=-1;

   int j1=0;
   for (int j=0; j<n+2; j++) {
		for (int i=0; i<m+2; i++) {
			//Только не угловые точки:
			if (!(((i==0)&&(j==0))||((i==m+1)&&(j==0))||((i==m+1)&&(j==n+1))||((i==0)&&(j==n+1)))) {

              // список номеров уравнений
              pointerlist[j1]=i+j*(m+2);
		      pointerlistrevers[i+j*(m+2)]=j1;
		
              j1++; // переход к следующей непустой точке
			}
	    }
   }
   
   // инициализация вектора
   int k1=0;
   
   // Вариант 2:
   for (int j=0; j<n+2; j++) {
		for (int i=0; i<m+2; i++) {
			//Только не угловые точки:
			if (!(((i==0)&&(j==0))||((i==m+1)&&(j==0))||((i==m+1)&&(j==n+1))||((i==0)&&(j==n+1)))) {

				// внутренний узел 
				int ipi=i+j*(m+2);
				dx[pointerlistrevers[ipi]]=u[i][j];

		    }
		}
   }
			

   int k2=0; // счётчик ненулевых элементов // Начинается обязательно с нуля !!!
   // k - это просто индекс, нумерация начиная с 1 нужна для пирамидальной сортировки

   // здесь происходит обращение к элементам nze от 0 до iNelem-1

   // Заполнение матрицы dА с учётом её разреженности и
   // вектора правой части dV
  for (int j=0; j<n+2; j++) {
		for (int i=0; i<m+2; i++) {
			//Только не угловые точки:
			if (!(((i==0)&&(j==0))||((i==m+1)&&(j==0))||((i==m+1)&&(j==n+1))||((i==0)&&(j==n+1)))) {

            // внутренний узел если icountnod==5.
   
			int istart=k2, icountnod=1;
    
		    Real dmul=1.0/A[i][j].ap; // диагональное предъобуславливание
			//Real dmul=1.0;
            nze[k2].i=pointerlistrevers[i+j*(m+2)]; nze[k2].j=pointerlistrevers[i+j*(m+2)]; nze[k2].aij=A[i][j].ap*dmul; nze[k2].key=pointerlistrevers[i+j*(m+2)];  k2++;
			if (fabs(A[i][j].ae)>eps0) { icountnod++; nze[k2].i=pointerlistrevers[i+j*(m+2)]; nze[k2].j=pointerlistrevers[i+1+j*(m+2)]; nze[k2].aij= - dmul*A[i][j].ae; nze[k2].key=pointerlistrevers[i+j*(m+2)]; k2++;}
			if (fabs(A[i][j].aw)>eps0) { icountnod++; nze[k2].i=pointerlistrevers[i+j*(m+2)]; nze[k2].j=pointerlistrevers[i-1+j*(m+2)]; nze[k2].aij= - dmul*A[i][j].aw; nze[k2].key=pointerlistrevers[i+j*(m+2)]; k2++;}
			if (fabs(A[i][j].an)>eps0) { icountnod++; nze[k2].i=pointerlistrevers[i+j*(m+2)]; nze[k2].j=pointerlistrevers[i+(j+1)*(m+2)]; nze[k2].aij= - dmul*A[i][j].an; nze[k2].key=pointerlistrevers[i+j*(m+2)]; k2++;}
			if (fabs(A[i][j].as)>eps0) { icountnod++; nze[k2].i=pointerlistrevers[i+j*(m+2)]; nze[k2].j=pointerlistrevers[i+(j-1)*(m+2)]; nze[k2].aij= - dmul*A[i][j].as; nze[k2].key=pointerlistrevers[i+j*(m+2)]; k2++;}
            dV1[pointerlistrevers[i+j*(m+2)]]= dmul*rthdsd[i][j];
			if (icountnod==2) {
				nze[istart].bNei=true;
			}

			}
			
		}
	}

  
  for (int j=0; j<n+2; j++) {
		for (int i=0; i<m+2; i++) {
			if (ialg == ICCGalg) {
				printf("p=%e, e=%e, w=%e, n=%e, s=%e\n", A[i][j].ap, A[i][j].ae, A[i][j].aw, A[i][j].an, A[i][j].as);
			}
			if (A[i][j].ap < 1.0e-30) {
				printf("i=%d j=%d m=%d n=%d\n",i,j,m,n);
				getchar();
			}
		}
  }


    // Угловых точек нет и не может быть они исключены выше.
  /*
    // Распознавание угловых точек.
    k2=0;
     for (int j=0; j<n+2; j++) {
		for (int i=0; i<m+2; i++) {
            // внутренний узел если icountnod==5.
			int icountnod=1;
			int istart=k2;
			k2++;
			if (fabs(A[i][j].ae)>eps0) { icountnod++; k2++;}
			if (fabs(A[i][j].aw)>eps0) { icountnod++; k2++;}
			if (fabs(A[i][j].an)>eps0) { icountnod++; k2++;}
			if (fabs(A[i][j].as)>eps0) { icountnod++; k2++;}

			if (icountnod==3) {
				nze[istart].bugol=true;

				// предположим что у него могут только 2 соседа и на 
				// каждом из них может стоять условие Неймана (однордное).
			}
		}
	 }
	 */
  // i,j, k2 - нумерация начинается с нуля. Даные отсорти
   for (int k1=k; k1>=1; k1--) nze[k1]=nze[k1-1]; // сдвиг вправо на 1.
   if (ialg == ICCGalg) {
	   printf("k=%d k2=%d\n", k, k2);
   }


   /*
   for (int k1=1; k1<=k; k1++) {
	   printf("%e %d i==%d j==%d key==%d\n",nze[k1].aij,k1,nze[k1].i,nze[k1].j, nze[k1].key);
	   getchar();
   }
   */

   // нумерация начинается с 1, а при заполнении nze нумерация начиналась с нуля
   //if (itypesorter_loc == 1)
   //{
     // QuickSort(nze,1,k); // быстрая сортировка Хоара
   //}
    //else
//	{
      // itypesorter = 2
    //  HeapSort(nze,k); // пирамидальная сортировка
  //  }
   


    // Сопряжённые градиенты Хестенса и Штифеля
   if (ialg==ICCGalg) {
	   // ICCG:
       
	   Real* val1 = new Real[k]; // ненулевые элементы матрицы СЛАУ
	   int* col_ind1 = new int[k]; // соответствующие ненулевым элементам номера столбцов
	   int* row_ptr1 = new int[il + 1]; // информация о том где начинается следующая строка


	   // обнуление матрицы dА
	   for (int k1 = 0; k1 <= k - 1; k1++)
	   {
		   // инициализация
		   val1[k1] = 0.0;
		   col_ind1[k1] = 0;
	   }

	   // т.к. нумерация начинается с нуля, то и максимальное значение (iNelem+1)-1,
	   // где -1 для учёта элемента с номером ноль, т.к. нумерация массива начинается с 0.
	   for (int k1 = 0; k1 <= il; k1++) row_ptr1[k1] = k; // инициализация указателей на следующую строку


	   // формирование матрицы разреженной матрицы СЛАУ
	   //  в формате CRS (сортировка нужна для упорядочивания элементов по строкам).
	   for (int k1 = 0; k1 <= k - 1; k1++)
	   {
		   // для nze индекс k+1 т.к. нумерация этого массива начиналась с 1.
		   // это требование алгоритма пирамидальной сортировки.
		   val1[k1] = nze[k1 + 1].aij;
		   col_ind1[k1] = nze[k1 + 1].j;
		   row_ptr1[nze[k1 + 1].i] = imin(k1, row_ptr1[nze[k1 + 1].i]);
	   }




	   Real* val2 = new Real[k]; // ненулевые элементы матрицы СЛАУ
	   int* col_ind2 = new int[k]; // соответствующие ненулевым элементам номера столбцов
	   int* row_ptr2 = new int[il + 1]; // информация о том где начинается следующая строка


	   // обнуление матрицы dА
	   for (int k1 = 0; k1 <= k - 1; k1++)
	   {
		   // инициализация
		   val2[k1] = 0.0;
		   col_ind2[k1] = 0;
	   }

	   // т.к. нумерация начинается с нуля, то и максимальное значение (iNelem+1)-1,
	   // где -1 для учёта элемента с номером ноль, т.к. нумерация массива начинается с 0.
	   for (int k1 = 0; k1 <= il; k1++) row_ptr2[k1] = k; // инициализация указателей на следующую строку


	   // формирование матрицы разреженной матрицы СЛАУ
	   //  в формате CRS (сортировка нужна для упорядочивания элементов по строкам).
	   for (int k1 = 0; k1 <= k - 1; k1++)
	   {
		   // для nze индекс k+1 т.к. нумерация этого массива начиналась с 1.
		   // это требование алгоритма пирамидальной сортировки.
		   val2[k1] = nze[k1 + 1].aij;
		   col_ind2[k1] = nze[k1 + 1].j;
		   row_ptr2[nze[k1 + 1].i] = imin(k1, row_ptr2[nze[k1 + 1].i]);
	   }




	   // матрица СЛАУ
	   // в формате CSIR:
	   // Хранится верхний треугольник симметричной разреженной матрицы.
	   Real *adiag=NULL, *altr=NULL;
	   int *jptr=NULL, *iptr=NULL;

	   

	    adiag = new Real[il]; // диагональные элементы
		int nz=(int)((k-il)/2);
		//int nz=(int)(k/2); // количество элементов данное с запасом
		altr = new Real[nz]; // поддиагональные элементы
		jptr = new int[nz]; // номера столцов для нижнего треугольника
		iptr = new int[il+1]; // указатели на следующую строку

		// инициализация
		for (int k1=0; k1<il; k1++) adiag[k1]=0.0;
        for (int k1=0; k1<(nz); k1++) {
		   altr[k1]=0.0;
		   jptr[k1]=0;
	    }
        for (int k1=0; k1<=il; k1++) {
		    //iptr[k]=k; // присваиваем количество ненулевых элементов плюс 1 с учётом того что нумерация массива начинается с 0
			iptr[k1]=nz; // debug
	    }



        int ik=0, ik2=0;
		int imin_=1;
		bool bvisit=false; // сбрасывается на FALSE только при переходе к новой строке.
		int ioldstr=0;


		for (int k1=0; k1<=k-1; k1++)
        {
			if (nze[k1+1].i>ioldstr) {
				ioldstr=nze[k1+1].i;
				bvisit=false;
			}

			if (nze[k1+1].j==nze[k1+1].i) {
				// диагональный.
				adiag[nze[k1+1].j]=nze[k1+1].aij;
			}
			else if (nze[k1+1].j<nze[k1+1].i) 
			{
				if (ik<nz) {
                   altr[ik]=nze[k1+1].aij;
				   jptr[ik]=nze[k1+1].j;
				   
				}
				ik2++;
				//iptr[nze[k1 + 1].i] = imin(iptr[nze[k1 + 1].i], ik);
				//iptr[nze[k1 + 1].i] = imin(iptr[nze[k1 + 1].i], ik);
				
				bvisit=true;
			}
			//imin_=imin(iptr[nze[k1+1].i],ik);
			//iptr[nze[k1+1].i]=imin_;
			iptr[nze[k1 + 1].i] = imin(iptr[nze[k1 + 1].i], ik);
			//if (imin_==0) for (int k3=0; k3<nze[k1+1].i; k3++) iptr[k3]=0;	
			if (bvisit) { 
				ik++;
				bvisit=false;
			}
		}


	//	printf("%d %d\n", ik2, ik);
		//getchar();

		for (int k3=0; k3<il; k3++) QuickSortCSIR(jptr, altr, iptr[k3], iptr[k3+1]-1);

		/*
		Real *val=new Real[k]; // ненулевые элементы матрицы СЛАУ
	   int *col_ind=new int[k]; // соответствующие ненулевым элементам номера столбцов
	   int *row_ptr=new int[il+1]; // информация о том где начинается следующая строка


	   // обнуление матрицы dА
       for(int  k1=0; k1<=k-1; k1++) 
       {
           // инициализация
           val[k1]=0.0;
           col_ind[k1]=0;
       }

       // т.к. нумерация начинается с нуля, то и максимальное значение (iNelem+1)-1,
       // где -1 для учёта элемента с номером ноль, т.к. нумерация массива начинается с 0.
       for (int k1=0; k1<=il; k1++) row_ptr[k1]=k; // инициализация указателей на следующую строку


	   // формирование матрицы разреженной матрицы СЛАУ
       //  в формате CRS (сортировка нужна для упорядочивания элементов по строкам).
       for (int k1=0; k1<=k-1; k1++)
       {
            // для nze индекс k+1 т.к. нумерация этого массива начиналась с 1.
            // это требование алгоритма пирамидальной сортировки.
            val[k1]=nze[k1+1].aij;
            col_ind[k1]=nze[k1+1].j;
            row_ptr[nze[k1+1].i]=imin(k1, row_ptr[nze[k1+1].i]);
       }*/
		
		// предобуславливатель:
	   // неполным разложением Холесского в
	   // формате CSIR_ITL:
	   Real *val=NULL;
	   int *indx=NULL, *pntr=NULL;

	   // Нужно правильно посчитать количество элементов (учитывая однородные условия Неймана).

		// поддиагональные элементы в altr хранятся построчно
		//nz=(int)((k-il)/2 + il); // число ненулевых элементов
		nz=0;
		for (int k1=0; k1<=k-1; k1++)
        {
			
			
			if (nze[k1+1].bNei) {
				k1++;
				nz+=2;
			}/*
			 // Этот случай теперь никогда не будет происходить,
			 // так как мы исключили все угловые точки.
			else if (nze[k1+1].bugol) {
				
				k1+=2;
				nz+=3;
				
			}*/
			else if (nze[k1+1].j>=nze[k1+1].i) {
				nz++;
			}
		}


		
		
		val = new Real[nz]; // диагональные элементы и наддиагональные элементы
		indx = new int[nz]; // номера столцов для нижнего треугольника
		pntr = new int[il+1]; // указатели на следующую строку

		
		// инициализация
        for (int k1=0; k1<(nz); k1++) {
		   val[k1]=0.0;
		   indx[k1]=0;
	    }
        for (int k1=0; k1<=il; k1++) {
		    pntr[k1]=nz; // присваиваем количество ненулевых элементов плюс 1 с учётом того что нумерация массива начинается с 0
	    }

		int ic=0;
        for (int k1=0; k1<=k-1; k1++)
        {
			if (nze[k1+1].bNei) {
			    ic++;
			}
		}
		printf("k=%d %d neiman condition\n",k,ic);

		ik=0; // счётчик ненулевых поддиагональных элементов СЛАУ
		for (int k1=0; k1<=k-1; k1++)
        {
			
			
			if (nze[k1+1].bNei) {
				// Однородные условия Неймана включаются особым образом:
				val[ik]=nze[k1+1].aij; // ненулевое значение
			    indx[ik]=nze[k1+1].j; // номер столбца
				pntr[nze[k1+1].i]=imin(pntr[nze[k1+1].i],ik);
			    ik++;

				k1++;

				val[ik]=nze[k1+1].aij; // ненулевое значение
			    indx[ik]=nze[k1+1].j; // номер столбца
				pntr[nze[k1+1].i]=imin(pntr[nze[k1+1].i],ik);
			    ik++;

				
				/*if (val[pntr[nze[k1+1].i]]<0.0) {
					swapCSIR(indx,val,pntr[nze[k1+1].i],pntr[nze[k1+1].i]+1);
				}
				*/


			}
			/*
			 // Этот случай теперь никогда не будет происходить, так как мы исключили все угловые точки.
			else if (nze[k1+1].bugol) {

				//k1+=2;
				

				// Однородные условия Неймана включаются особым образом:
				val[ik]=nze[k1+1].aij; // ненулевое значение
			    indx[ik]=nze[k1+1].j; // номер столбца
				pntr[nze[k1+1].i]=imin(pntr[nze[k1+1].i],ik);
			    ik++;

				k1++;

				val[ik]=nze[k1+1].aij; // ненулевое значение
			    indx[ik]=nze[k1+1].j; // номер столбца
				pntr[nze[k1+1].i]=imin(pntr[nze[k1+1].i],ik);
			    ik++;

				k1++;

				val[ik]=nze[k1+1].aij; // ненулевое значение
			    indx[ik]=nze[k1+1].j; // номер столбца
				pntr[nze[k1+1].i]=imin(pntr[nze[k1+1].i],ik);
			    ik++;

				
				/*if (val[pntr[nze[k1+1].i]]<0.0) {
					swapCSIR(indx,val,pntr[nze[k1+1].i],pntr[nze[k1+1].i]+1);
				}
				*//*
			

			}*/
			else if (nze[k1+1].j>=nze[k1+1].i) {
				// Только Внутренность или условия Дирихле.
				val[ik]=nze[k1+1].aij; // ненулевое значение
			    indx[ik]=nze[k1+1].j; // номер столбца

				pntr[nze[k1+1].i]=imin(pntr[nze[k1+1].i],ik);
			    ik++;
			}

		}
		
		//printf("ik=%d nz=%d",ik,nz);
		//getchar();
		
		/*
        // k  
		for (int k1=0; k1<il; k1++) {
			printf("%e pntr=%d string=%d",val[pntr[k1]],pntr[k1],k1);
			getchar();
		}
		*/


		for (int k1=0; k1<il; k1++) {
			
			if ((nze[pntr[k1]+1].bNei) /*|| (nze[pntr[k1]+1].bugol)*/) {
				// ничего не делаем
			}
			else {
			   QuickSortCSIR(indx, val, pntr[k1], pntr[k1+1]-1);
			}
			

			//QuickSortCSIR(indx, val, pntr[k1], pntr[k1+1]-1);
		}
		
		for (int k1=0; k1<=k-1; k1++)
        {
            if (nze[k1+1].bNei) {
            	if (val[pntr[nze[k1+1].i]]<0.0) {
					swapCSIR(indx,val,pntr[nze[k1+1].i],pntr[nze[k1+1].i]+1);
				}
            }
		}
		
		/*
		// k  
		for (int k1=0; k1<il; k1++) {
			printf("%e pntr=%d string=%d",val[pntr[k1]],pntr[k1],k1);
			getchar();
		}

		/*
		// k 1 200 201 202 
		for (int k1=0; k1<il; k1++) {
			printf("%e %d",val[k1],k1);
			getchar();
		}*/
		for (int k1=0; k1<il; k1++) {
			//printf("%d %e",pntr[k1],val[pntr[k1]]);
			if (val[pntr[k1]]<=0.0) {
				printf("pered ICCG negative diag elem %e string=%d il=%d\n",val[pntr[k1]],k1,il);
			    getchar();
			}
		}
		/*
		for (int k1=0; k1<il; k1++) {
			//printf("%d %e",row_ptr[k1],val[pntr[k1]]);
			if (val[row_ptr[k1]]<=0.0) {
				printf("pered ICCG negative diag elem %e string=%d il=%d\n",val[row_ptr[k1]],k1,il);
			    getchar();
			}
		}
		*/
		Real* dinit = new Real[il];

		for (int j = 0; j < n + 2; j++) {
			for (int i = 0; i < m + 2; i++) {
				if (!(((i == 0) && (j == 0)) || ((i == m + 1) && (j == 0)) || ((i == m + 1) && (j == n + 1)) || ((i == 0) && (j == n + 1)))) {


					// внутренний узел 
					int ipi = i + j * (m + 2);
					dinit[pointerlistrevers[ipi]] = u[i][j];
				}
			}
		}

		// Всё готово.
		bool bmessage=true;
		Real *residual_history=new Real[iend+1];
	    for (int i=0; i<iend; i++) {
		    residual_history[i]=1.0; // инициализация.
	    }
		ICCG(adiag, altr, jptr, iptr, val1, col_ind1, row_ptr1, val2, col_ind2, row_ptr2, val, indx, pntr, dV1, dx, il, bmessage, iend, 1.0e-20, residual_history);
		//ICCG(adiag, altr, jptr, iptr, val, col_ind, row_ptr, dV1, dx, il, bmessage, iend, 1.0e-20, residual_history);

		///---->SoprGradCSIR(il, adiag, altr, jptr, iptr, val1, col_ind, row_ptr, dV1, dinit, dx, residual_history, bmessage, iend,  1.0e-20, 3);
			

		delete[] adiag;
		delete[] altr;
		delete[] jptr;
		delete[] iptr;

		delete[] val;
		delete[] indx;
		delete[] pntr;
		//delete col_ind;
		//delete row_ptr;

		 // Освобождение оперативной памяти.
		if (val1 != NULL) {
			delete val1;
		}
		if (col_ind1 != NULL) {
			delete col_ind1;
		}
		if (row_ptr1 != NULL) {
			delete row_ptr1;
		}
		if (val2 != NULL) {
			delete val2;
		}
		if (col_ind2 != NULL) {
			delete col_ind2;
		}
		if (row_ptr2 != NULL) {
			delete row_ptr2;
		}
		delete[] dinit;
		
		 // нормированная октаэдрическая норма (сумма модулей).
	     for (int i=1; i<iend; i++) {
		     residual_history[i]=residual_history[i]/residual_history[0];
	     }
	     residual_history[0]=1.0;

	     for (int i=0; i<iend; i++) {
		     printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	     }
	     delete residual_history;

   }
   else {

	   Real *val=new Real[k]; // ненулевые элементы матрицы СЛАУ
	   int *col_ind=new int[k]; // соответствующие ненулевым элементам номера столбцов
	   int *row_ptr=new int[il+1]; // информация о том где начинается следующая строка


	   // обнуление матрицы dА
       for(int  k1=0; k1<=k-1; k1++) 
       {
           // инициализация
           val[k1]=0.0;
           col_ind[k1]=0;
       }

       // т.к. нумерация начинается с нуля, то и максимальное значение (iNelem+1)-1,
       // где -1 для учёта элемента с номером ноль, т.к. нумерация массива начинается с 0.
       for (int k1=0; k1<=il; k1++) row_ptr[k1]=k; // инициализация указателей на следующую строку


	   // формирование матрицы разреженной матрицы СЛАУ
       //  в формате CRS (сортировка нужна для упорядочивания элементов по строкам).
       for (int k1=0; k1<=k-1; k1++)
       {
            // для nze индекс k+1 т.к. нумерация этого массива начиналась с 1.
            // это требование алгоритма пирамидальной сортировки.
            val[k1]=nze[k1+1].aij;
            col_ind[k1]=nze[k1+1].j;
            row_ptr[nze[k1+1].i]=imin(k1, row_ptr[nze[k1+1].i]);
       }

	   /*
	   for (int k3=0; k3<il; k3++) QuickSortCSIR(col_ind, val, row_ptr[k3], row_ptr[k3+1]-1);
	   */

	   // debug
	   /*
	   printf("val: \n");
	   for (int k1=0; k1<=k-1; k1++)
       {
		   printf("%4e \n",val[k1]);
		   getchar();
	   }
	   */
	   

      // Решение СЛАУ
      // методом Сопряжённых Градиентов
      // Хестенса и Штифеля
      // на основе технологии хранения и обработки разреженных матриц CRS
      // В зависимости от значения параметра bgt применяется или не применяется трансформация Гаусса.
	  Real* dinit=new Real[il];
	    // копирование полученного решения обратно в U
	  // Вариант 1 :
	  /*
      for (int i1=0; i1<=il-1; i1++)
      {
         dinit[i1] = P_loc[pointerlist_loc[i1]+1]; // вектор с начальным приближением;
      }*/
	  // Вариант 2 :
	  for (int j=0; j<n+2; j++) {
		for (int i=0; i<m+2; i++) {
			if (!(((i==0)&&(j==0))||((i==m+1)&&(j==0))||((i==m+1)&&(j==n+1))||((i==0)&&(j==n+1)))) {


			// внутренний узел 
			int ipi=i+j*(m+2);
			dinit[pointerlistrevers[ipi]]=u[i][j];
			}
		}
      }
      bool bmessage=true;
      bool bgt=false;
	  Real *residual_history=new Real[iend+1];
	  for (int i=0; i<iend; i++) {
		  residual_history[i]=1.0; // инициализация.
	  }

	  int m_restart = 32;
	  switch (ialg_loc) {
	  case CongruateGradient : // Метод Сопряжённых Градиентов.
		  SoprGradCRS(il, val, col_ind, row_ptr, dV1, dinit, dx, residual_history, bmessage, iend, bgt, 1.0e-20, 3);  
		  break;
	  case BiCGStab : // Алгоритм Хенрика Ван Дер Ворста
		  Bi_CGStabCRS(il, val, col_ind, row_ptr, dV1, dinit, dx, iend, 1.0e-20, 3, residual_history);
		  break;
	  case GMRESalg :
		  m_restart = 32;
		  gmres(il, val, col_ind, row_ptr, dV1, dinit, dx, iend, 1.0e-20, 3, residual_history, m_restart);
		  break;
	  default : // по умолчанию алгоритм Хенрика Ван Дер Ворста
		        Bi_CGStabCRS(il, val, col_ind, row_ptr, dV1, dinit, dx, iend, 1.0e-20, 3, residual_history);
		        break;
	  }
	 
	  // Освобождение оперативной памяти.
	  if (val!=NULL) {
	  delete val;
	  }
	  if (col_ind!=NULL) {
	  delete col_ind;
	  }
	  if (row_ptr!=NULL) {
	  delete row_ptr;
	  }
	  delete[] dinit;
	 
	  // нормированная октаэдрическая норма (сумма модулей).
	  for (int i=1; i<iend; i++) {
		  residual_history[i]=residual_history[i]/residual_history[0];
	   }
	  residual_history[0]=1.0;

	  for (int i=0; i<iend; i++) {
		 // printf("  %d   %1.4e  \n",i+1,residual_history[i]);
		 // getchar();
	  }
	  delete residual_history;

   }
   

   // копирование полученного решения обратно в U
   // Вариант 1:
   /*
   for (int i1=0; i1<=il-1; i1++)
   {
      P_loc[pointerlist_loc[i1]+1] = dx[i1]; // вектор с решением задачи;
   }*/
   // Вариант 2:
    for (int j=0; j<n+2; j++) {
		for (int i=0; i<m+2; i++) {
			//Только не угловые точки:
			if (!(((i==0)&&(j==0))||((i==m+1)&&(j==0))||((i==m+1)&&(j==n+1))||((i==0)&&(j==n+1)))) {
			// внутренний узел 
			int ipi=i+j*(m+2);
			u[i][j]=dx[pointerlistrevers[ipi]];
			}
		}
   }

	
	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	u[0][0]=(A[0][0].an*u[0][1]+A[0][0].ae*u[1][0]+rthdsd[0][0])/A[0][0].ap;

	// правый нижний угол.
	u[m+1][0]=(A[m+1][0].aw*u[m][0]+A[m+1][0].an*u[m+1][1]+rthdsd[m+1][0])/A[m+1][0].ap;

	// левый верхний угол.
	u[0][n+1]=(A[0][n+1].as*u[0][n]+A[0][n+1].ae*u[1][n+1]+rthdsd[0][n+1])/A[0][n+1].ap;

	// правый верхний угол.
	u[m+1][n+1]=(A[m+1][n+1].aw*u[m][n+1]+A[m+1][n+1].as*u[m+1][n]+rthdsd[m+1][n+1])/A[m+1][n+1].ap;
			 

	
	delete nze;
	
	delete dV1;
	delete dx;

	delete pointerlist; // память выделяется в Delphi.
	delete pointerlistrevers; // память выделяется в Delphi.
	

}



// наивный алгоритм
void itsolve_naiv(Real** &u, Real** &u_old, Real** &r,
	              Real** rthdsd, int m, int n, int ialg, MATRNODE** &A, int iend) {

      Real *residual_history=new Real[iend+1];
	  for (int i=0; i<iend; i++) {
		  residual_history[i]=1.0; // инициализация.
	  }

	 

	// Внимание: iend - передаваемое количество итераций.
	// Если iend==1 и ialg==STANDART то это эквивалентно полностью явной схеме для уравнения конвекции-диффузии.
	// 1. По видимому для уравнения конвекции-диффузии можно использовать либо полностью явную схему (с соответствующим ограничением на шаг по времени Диффузиоонное ограничение плюс конвективное ограничение)
	// 2. либо метод Писмена-Рекфорда без каких либо ограничений на шаг по времени, но предполагая его достаточно малым (например ограничение Куранта),
	// 3. либо метод Бураго Н.Г. при котором диффузионная часть аппроксимируется полностью неявно а конвективная явно (в этом случае действую ограничение Куранта).
	// 4. Полностью неявную схему и решение СЛАУ до упора применять по-моему нельзя.

    Real URF=1.0; // инициализировано без релаксации.
	if (ialg==SORDIRICHLET) {
		// постоянные шаги сетки h1 по оси x и h2 по оси y.
	    // Real h1=(Real)(lengthx/(m+1));
	    // Real h2=(Real)(lengthy/(n+1));
        // Внимание оптимальный параметр релаксации верен только в случае краевых условий Дирихле.
	    const Real MPI=3.1415; // Число ПИ.
	    //Real b=0.5*cos(MPI*h1)+0.5*cos(MPI*h2);
        Real b=0.5*cos(MPI/(m+1))+0.5*cos(MPI/(n+1));
	    URF=2.0/(1.0+sqrt(1.0-b*b)); // Оптимальный параметр верхней релаксации для граничных условий Дирихле.
		// см. Е.Н.Бондарев, А.С.Кокорев МАИ Численные методы решения уравнений Навье-Стокса М. 1992.
        // Оптимальное значение коэффициента релаксации известно лишь для прямоугольной области и граничных условий Дирихле.
		// Чтобы узнать оптимальное значение параметра релаксации нужно знать : уравнение, форму области, сетку.
		// Т.е. спектральные характеристики матрицы. 
		// Данное значение параметра релаксации подходит лишь для решения уравнения типа уравнения для функции тока (коэффициент диффузии 1.0)
		// граничные условия Дирихле.
	}


	Real** ksi;
	Real** etta;
	Real** gamma;
	Real** d;
	Real theta; // параметр в диапазоне от нуля до 1.
	
	if (ialg==ZVER) {
		// Выделение оперативной памяти.
       my_alloc_zver(ksi, etta, gamma, d, m, n);
	   theta=1.0;	  
	}

	Real norm=0.0;
	//int iend=1;
	for (int i=0; i<iend; i++) {
		switch (ialg) {
		  case STANDART : solve(0.125, u, u_old, rthdsd, A, m, n); break;
		  case SEIDEL :  // запоминаем поле с предыдущей итерации.
	                     // данный итерационный процесс требует в два раза больше памяти.
	                     for (int i1=0; i1<m+2; i1++) {
		                     for (int j1=0; j1<n+2; j1++) {
			                      u_old[i1][j1]=u[i1][j1];
		                     }
	                     }
						 
			             Seidel(u, rthdsd, A, m, n);						 
						 break;
		  case LR : // запоминаем поле с предыдущей итерации.
	                // данный итерационный процесс требует в два раза больше памяти.
	                for (int i1=0; i1<m+2; i1++) {
		                for (int j1=0; j1<n+2; j1++) {
			                 u_old[i1][j1]=u[i1][j1];
		                }
	                }
			        LRsolve(u, rthdsd, A, m, n); break;
		  case SORDIRICHLET : for (int i1=0; i1<m+2; i1++) {
		                          for (int j1=0; j1<n+2; j1++) {
			                          u_old[i1][j1]=u[i1][j1];
		                          }
	                          }
			                  // Метод верхней релаксации только в случае условий Дирихле 
			                  // С оптимальным параметром релаксации.
			                  // Подходит только для функции тока и более не для чего.
			                  SORDirichlet(u, rthdsd, A, URF, m, n); 
			          break;
		  case ZVER : // запоминаем поле с предыдущей итерации.
	                  // данный итерационный процесс требует в два раза больше памяти.
	                  for (int i1=0; i1<m+2; i1++) {
		                  for (int j1=0; j1<n+2; j1++) {
			                  u_old[i1][j1]=u[i1][j1];
		                  }
	                  }
					  ZVERsolve(u, rthdsd, A, ksi, etta, gamma, d, theta,  m, n);
			          break;
		  default : solve(0.125, u, u_old, rthdsd, A, m, n); break;
		}
		residual(r, u_old, rthdsd, A, m, n);
		norm=normar(r,m,n);
		//if (i%10==0) printf(" iter  residual\n");
		//printf("  %d   %1.4e  \n",i+1,norm);
		residual_history[i]=norm;
	}

	if (ialg==ZVER) {
		// Освобождение памяти из под вспомогательных структур используемых в алгоритме В.Г. Зверева.
		my_free_zver(ksi, etta, gamma, d, m, n);		
	}

	 // нормированная октаэдрическая норма (сумма модулей).
	 for (int i=1; i<iend; i++) {
	     residual_history[i]=residual_history[i]/residual_history[0];
	 }
	 residual_history[0]=1.0;
	 
	 //for (int i=0; i<iend; i++) {
	    // printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	 //}
	 
	 delete residual_history;
	
} // itsolve_naiv

/*
// Учёт в матрице СЛАУ граничных условий Дирихле.
void boundaryDirichletApproach(MATRNODE** &A, int m, int n) {
	// Условие Дирихле.
	for (int i=1; i<m+1; i++) {
		A[i][0].ap=1.0;
		//A[i][0].abound=0.0; // Условие Дирихле
		A[i][n+1].ap=1.0;
		//A[i][n+1].abound=0.0; // Условие Дирихле
	}
	// Условие Дирихле.
	for (int i=1; i<n+1; i++) {
		A[0][i].ap=1.0;
		//A[0][1].abound=0.0; // Условие Дирихле
		A[m+1][i].ap=1.0;
		//A[m+1][i].abound=0.0; // Условие Дирихле
	}
} // boundaryDirichletApproach
*/

// Учёт в матрице СЛАУ граничных условий Дирихле.
// данный метод пригоден для неравномерной расчётной сетки.
void boundaryDirichletApproach1(MATRNODE** &A, BONCONDOMAIN &my_bound, 
	                            Real* x, Real* y, int m, int n) {

	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		if (my_bound.bottom[i].ap<0.0)
		{
		    A[i][0].ap=1.0;
		    /*A[i][0].ap=*/A[i][0].an=(my_bound.bottom[i].gamma/(y[1]-y[0]))/(my_bound.bottom[i].gamma/(y[1]-y[0])+my_bound.bottom[i].kappa);
		}
		else {
			A[i][0].ap=my_bound.bottom[i].ap;
			A[i][0].an=my_bound.bottom[i].ai;
		}
		A[i][0].ae=0.0;
		A[i][0].aw=0.0;
		A[i][0].as=0.0;
		
		// верхняя граница
		if (my_bound.top[i].ap<0.0)
		{
		    A[i][n+1].ap=1.0;
		    /*A[i][n+1].ap=*/A[i][n+1].as=(my_bound.top[i].gamma/(y[n+1]-y[n]))/(my_bound.top[i].gamma/(y[n+1]-y[n])+my_bound.top[i].kappa);
		}
		else
		{
			A[i][n+1].ap=my_bound.top[i].ap;
			A[i][n+1].as=my_bound.top[i].ai;
		}
		A[i][n+1].an=0.0;
		A[i][n+1].ae=0.0;
		A[i][n+1].aw=0.0;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		if (my_bound.left[j].ap<0.0) {
		    A[0][j].ap=1.0;
		    /*A[0][j].ap=*/A[0][j].ae=(my_bound.left[j].gamma/(x[1]-x[0]))/(my_bound.left[j].gamma/(x[1]-x[0])+my_bound.left[j].kappa);
		}
		else {
			A[0][j].ap=my_bound.left[j].ap;
			A[0][j].ae=my_bound.left[j].ai;
		}
		A[0][j].an=0.0;
		A[0][j].as=0.0;
		A[0][j].aw=0.0;
		// правая граница
		if (my_bound.right[j].ap<0.0) {
           A[m+1][j].ap=1.0;
		   /*A[m+1][j].ap=*/A[m+1][j].aw=(my_bound.right[j].gamma/(x[m+1]-x[m]))/(my_bound.right[j].gamma/(x[m+1]-x[m])+my_bound.right[j].kappa);
		}
		else {
			 A[m+1][j].ap=my_bound.right[j].ap;
			 A[m+1][j].aw=my_bound.right[j].ai;
		}		
		A[m+1][j].ae=0.0;
		A[m+1][j].an=0.0;
		A[m+1][j].as=0.0;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	A[0][0].ap=1.0;
	A[0][0].an=0.5;
	A[0][0].ae=0.5;
	A[0][0].as=0.0;
	A[0][0].aw=0.0;

	// правый нижний угол.
	A[m+1][0].ap=1.0;
	A[m+1][0].an=0.5;
	A[m+1][0].ae=0.0;
	A[m+1][0].as=0.0;
	A[m+1][0].aw=0.5;

	// левый верхний угол.
	A[0][n+1].ap=1.0;
	A[0][n+1].an=0.0;
	A[0][n+1].ae=0.5;
	A[0][n+1].as=0.5;
	A[0][n+1].aw=0.0;

	// правый верхний угол.
	A[m+1][n+1].ap=1.0;
	A[m+1][n+1].an=0.0;
	A[m+1][n+1].ae=0.0;
	A[m+1][n+1].as=0.5;
	A[m+1][n+1].aw=0.5;

	
} // boundaryDirichletApproach1

// Учёт в матрице СЛАУ граничных условий Дирихле.
// данный метод пригоден для неравномерной расчётной сетки.
void boundaryDirichletApproach1MESFET(MATRNODE** &A, Real* x, Real* y,
									  int m, int n, Real xendsource,
									  Real xstartgate, Real xendgate, Real xstartdrain) {


	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		
		if (bening_condition) {
			// На подложке вторая производная от потенциала равна нулю.
			A[i][0].ap = 1.0;
			A[i][0].an = (y[1]-y[0])/(y[2]-y[0]);
			A[i][0].ann = -(y[1]-y[0])/(y[2]-y[1]);
		}
		else {
			A[i][0].ap = 1.0;
			A[i][0].an = 1.0;
			A[i][0].ann = 0.0;
		}
		
		A[i][0].ae = 0.0;
		A[i][0].aw = 0.0;
		A[i][0].as = 0.0;

		// верхняя граница
		if (x[i]<xendsource) {
			A[i][n+1].ap=1.0;
		    A[i][n+1].as=0.0;
		}
		else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			 A[i][n+1].ap=1.0;
		     A[i][n+1].as=0.0;
		}
		else if (x[i]>xstartdrain) {
			 A[i][n+1].ap=1.0;
		     A[i][n+1].as=0.0;
		}
		else {
			A[i][n+1].ap=1.0;
		    A[i][n+1].as=1.0;
		}
		
		
		A[i][n+1].an=0.0;
		A[i][n+1].ae=0.0;
		A[i][n+1].aw=0.0;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		
		A[0][j].ap=1.0;
		A[0][j].ae=1.0;
		
		A[0][j].an=0.0;
		A[0][j].as=0.0;
		A[0][j].aw=0.0;
		// правая граница
		
		A[m+1][j].ap=1.0;
		A[m+1][j].aw=1.0;
				
		A[m+1][j].ae=0.0;
		A[m+1][j].an=0.0;
		A[m+1][j].as=0.0;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	A[0][0].ap=1.0;
	A[0][0].an=0.5;
	A[0][0].ae=0.5;
	A[0][0].as=0.0;
	A[0][0].aw=0.0;

	// правый нижний угол.
	A[m+1][0].ap=1.0;
	A[m+1][0].an=0.5;
	A[m+1][0].ae=0.0;
	A[m+1][0].as=0.0;
	A[m+1][0].aw=0.5;

	// левый верхний угол.
	A[0][n+1].ap=1.0;
	A[0][n+1].an=0.0;
	A[0][n+1].ae=0.5;
	A[0][n+1].as=0.5;
	A[0][n+1].aw=0.0;

	// правый верхний угол.
	A[m+1][n+1].ap=1.0;
	A[m+1][n+1].an=0.0;
	A[m+1][n+1].ae=0.0;
	A[m+1][n+1].as=0.5;
	A[m+1][n+1].aw=0.5;

	
} // boundaryDirichletApproach1MESFET

// Учёт в матрице СЛАУ граничных условий Дирихле.
// данный метод пригоден для неравномерной расчётной сетки.
void boundaryApproachMesfet(MATRNODE** &A, BONCONDOMAIN &my_bound, 
	                            Real* x, Real* y, int m, int n) {

	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		
		A[i][0].ap=my_bound.bottom[i].ap;
		A[i][0].an=my_bound.bottom[i].ai;
		A[i][0].ann = 0.0;
		
		A[i][0].ae=0.0;
		A[i][0].aw=0.0;
		A[i][0].as=0.0;
		
		// верхняя граница
		A[i][n+1].ap=my_bound.top[i].ap;
		A[i][n+1].as=my_bound.top[i].ai;
		
		A[i][n+1].an=0.0;
		A[i][n+1].ae=0.0;
		A[i][n+1].aw=0.0;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		
		A[0][j].ap=my_bound.left[j].ap;
		A[0][j].ae=my_bound.left[j].ai;
		
		A[0][j].an=0.0;
		A[0][j].as=0.0;
		A[0][j].aw=0.0;
		// правая граница
		
		A[m+1][j].ap=my_bound.right[j].ap;
		A[m+1][j].aw=my_bound.right[j].ai;
				
		A[m+1][j].ae=0.0;
		A[m+1][j].an=0.0;
		A[m+1][j].as=0.0;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	// левый нижний угол.
	A[0][0].ap=1.0;
	A[0][0].an=0.5;
	A[0][0].ae=0.5;
	A[0][0].as=0.0;
	A[0][0].aw=0.0;

	// правый нижний угол.
	A[m+1][0].ap=1.0;
	A[m+1][0].an=0.5;
	A[m+1][0].ae=0.0;
	A[m+1][0].as=0.0;
	A[m+1][0].aw=0.5;

	// левый верхний угол.
	A[0][n+1].ap=1.0;
	A[0][n+1].an=0.0;
	A[0][n+1].ae=0.5;
	A[0][n+1].as=0.5;
	A[0][n+1].aw=0.0;

	// правый верхний угол.
	A[m+1][n+1].ap=1.0;
	A[m+1][n+1].an=0.0;
	A[m+1][n+1].ae=0.0;
	A[m+1][n+1].as=0.5;
	A[m+1][n+1].aw=0.5;

	
} // boundaryApproachMesfet

// Сборка матрицы СЛАУ.
// с коэффициентом теплопроводности равным lambda.
// это пригодно только для равномерной сетки.
// Это обычная сборка по способу конечных разностей.
/*
void constrA0(MATRNODE** &A, BONCONDOMAIN &my_bound, Real lambda, 
              Real* x, Real* y, int m, int n) {
	// my_bound - информация о граничных узлах.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(m+1));
	Real h2=(Real)(lengthy/(n+1));

	// Внутренность матрицы.
	// Строго внутренние контрольные объёмы.
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			A[i][j].ae=lambda/(h1*h1);
			A[i][j].aw=lambda/(h1*h1);
			A[i][j].an=lambda/(h2*h2);
			A[i][j].as=lambda/(h2*h2);
			A[i][j].ap=(A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as);
		}
	}

	// граничные контрольные объёмы.
	boundaryDirichletApproach1(A, my_bound, x,y, m, n);

} // constrA0
*/

// Сборка матрицы СЛАУ.
// с коэффициентом теплопроводности равным lambda.
// это пригодно не только для равномерной сетки, но и для неравномерной тоже.
// Это обычная сборка по способу конечных разностей.
// KR - конечные разности.
// Формула для аппроксимации второй производной взята из книги Г.З. Гарбера стр 210.
void constrA0KR(MATRNODE** &A, BONCONDOMAIN &my_bound, Real lambda, 
              Real* x, Real* y, int m, int n) {
	// my_bound - информация о граничных узлах.

	// Внутренность матрицы.
	// Строго внутренние контрольные объёмы.
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			A[i][j].ae=lambda*2.0/((x[i+1]-x[i])*(x[i+1]-x[i-1]));
			A[i][j].aw=lambda*2.0/((x[i]-x[i-1])*(x[i+1]-x[i-1]));
			A[i][j].an=lambda*2.0/((y[j+1]-y[j])*(y[j+1]-y[j-1]));
			A[i][j].as=lambda*2.0/((y[j]-y[j-1])*(y[j+1]-y[j-1]));
			A[i][j].ap=(A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as);
		}
	}

	// граничные контрольные объёмы.
	boundaryDirichletApproach1(A, my_bound, x,y, m, n);

} // constrA0


// Сборка матрицы СЛАУ.
// с коэффициентом теплопроводности равным lambda.
// это пригодно для неравномерной сетки.
void constrA0MCV(MATRNODE** &A, BONCONDOMAIN &my_bound, Real lambda,
	          Real* x, Real* y, int m, int n) {
	// my_bound - информация о граничных узлах.

	
	// будем собирать матрицу по способу контрольного объёма.
	// Диффузионный член аппроксимируется на неравномерной сетке с первым порядком.

	// Внутренность матрицы.
	// Строго внутренние контрольные объёмы.
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			Real De, Dw, Ds, Dn;

			De=lambda*0.5*(y[j+1]-y[j-1])/(x[i+1]-x[i]);
			Dw=lambda*0.5*(y[j+1]-y[j-1])/(x[i]-x[i-1]);
			Dn=lambda*0.5*(x[i+1]-x[i-1])/(y[j+1]-y[j]);
			Ds=lambda*0.5*(x[i+1]-x[i-1])/(y[j]-y[j-1]);

			//if ((0.5 * (x[i + 1] - x[i - 1]) / (y[j] - y[j - 1]) > 1.02)||(0.5 * (x[i + 1] - x[i - 1]) / (y[j] - y[j - 1]) < 0.98)) {
				//printf("0.5 * (x[i + 1] - x[i - 1])=%e (y[j] - y[j - 1]) =%e", 0.5 * (x[i + 1] - x[i - 1]), (y[j] - y[j - 1]));
			//}

			A[i][j].ae=De;
			A[i][j].aw=Dw;
			A[i][j].an=Dn;
			A[i][j].as=Ds;
			A[i][j].ap=(A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as);
		}
	}
	

	// граничные контрольные объёмы.
	boundaryDirichletApproach1(A, my_bound, x, y, m, n);

} // constrA0MCV

// Сборка матрицы СЛАУ.
// с коэффициентом теплопроводности равным lambda.
// это пригодно для неравномерной сетки.
void constrA0MCVMESFET(MATRNODE** &A,  Real lambda,
	          Real* x, Real* y, int m, int n, 
			  Real xendsource, Real xstartgate, Real xendgate, Real xstartdrain) {
	// my_bound - информация о граничных узлах.

	
	// будем собирать матрицу по способу контрольного объёма.
	// Диффузионный член аппроксимируется на неравномерной сетке с первым порядком.

	// Внутренность матрицы.
	// Строго внутренние контрольные объёмы.
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			Real De, Dw, Ds, Dn;

			De=lambda*0.5*(y[j+1]-y[j-1])/(x[i+1]-x[i]);
			Dw=lambda*0.5*(y[j+1]-y[j-1])/(x[i]-x[i-1]);
			Dn=lambda*0.5*(x[i+1]-x[i-1])/(y[j+1]-y[j]);
			Ds=lambda*0.5*(x[i+1]-x[i-1])/(y[j]-y[j-1]);

			A[i][j].ae=De;
			A[i][j].aw=Dw;
			A[i][j].an=Dn;
			A[i][j].as=Ds;
			A[i][j].ap=(A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as);
		}
	}
	

	// граничные контрольные объёмы.
	boundaryDirichletApproach1MESFET(A, x, y, m, n, xendsource, xstartgate, xendgate, xstartdrain);

} // constrA0MCVMESFET

// Сборка матрицы СЛАУ.
// с коэффициентом теплопроводности равным lambda который зависит от пространственных координат.
// это пригодно для неравномерной сетки.
// ДИЭЛЕКТРИЧЕСКАЯ ПРОНИЦАЕМОСТЬ НА ГРАНИ КО аппроксимирована средним арифметическим.
void constrA0MCVMESFETAlGaNGaN(MATRNODE** &A,  Real** lambda,
	          Real* x, Real* y, int m, int n, 
			  Real xendsource, Real xstartgate, Real xendgate, Real xstartdrain) {
	// my_bound - информация о граничных узлах.

	
	// будем собирать матрицу по способу контрольного объёма.
	// Диффузионный член аппроксимируется на неравномерной сетке с первым порядком.

	// Внутренность матрицы.
	// Строго внутренние контрольные объёмы.
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			Real De, Dw, Ds, Dn;

			Real lambdag=1.0;
			lambdag=0.5*(lambda[i+1][j]+lambda[i][j]);
			De=lambdag*0.5*(y[j+1]-y[j-1])/(x[i+1]-x[i]);
			lambdag=0.5*(lambda[i-1][j]+lambda[i][j]);
			Dw=lambdag*0.5*(y[j+1]-y[j-1])/(x[i]-x[i-1]);
			lambdag=0.5*(lambda[i][j+1]+lambda[i][j]);
			Dn=lambdag*0.5*(x[i+1]-x[i-1])/(y[j+1]-y[j]);
			lambdag=0.5*(lambda[i][j-1]+lambda[i][j]);
			Ds=lambdag*0.5*(x[i+1]-x[i-1])/(y[j]-y[j-1]);

			A[i][j].ae=De;
			A[i][j].aw=Dw;
			A[i][j].an=Dn;
			A[i][j].as=Ds;
			A[i][j].ap=(A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as);
		}
	}
	

	// граничные контрольные объёмы.
	boundaryDirichletApproach1MESFET(A, x, y, m, n, xendsource, xstartgate, xendgate, xstartdrain);

} // constrA0MCVMESFETAlGaNGaN

const bool mcv = true;

// Сборка матрицы СЛАУ.
// с коэффициентом теплопроводности равным lambda.
// это пригодно для неравномерной сетки.
void constrA0(MATRNODE** &A, BONCONDOMAIN &my_bound, Real lambda,
	          Real* x, Real* y, int m, int n) {
	// my_bound - информация о граничных узлах.

	
	// аппроксимация по способу конечных разностей эквивалентна аппроксимации по способу
	// контрольного объёма делённой на объём контрольного объёма.

	if (mcv) {
		constrA0MCV(A, my_bound, lambda, x, y, m, n);
	}
	else {
		constrA0KR(A, my_bound, lambda, x, y, m, n); 
	}

} // constrA0


// Сборка правой части.
// данный метод пригоден для неравномерной сетки.
void constrrthdsd0(Real** &rthdsd, Real** &rinternalsource, BONCONDOMAIN &my_bound,
	               Real* x, Real* y, int m, int n) {

	// my_bound - информация о граничных узлах.

	// rinternalsource - источник для внутренности расчётной области.
	// именно строго внутренние контрольные объёмы.

	// Строго внутренние контрольные объёмы.
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			rthdsd[i][j]=rinternalsource[i][j];
		}
	}

	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		if (my_bound.bottom[i].ap<0.0) {
			rthdsd[i][0]=((my_bound.bottom[i].kappa*my_bound.bottom[i].FI_inf+my_bound.bottom[i].qset))/(my_bound.bottom[i].gamma/(y[1]-y[0])+my_bound.bottom[i].kappa);
		} 
		else {
			rthdsd[i][0]=0.0;
		}
		// верхняя граница
		if (my_bound.top[i].ap<0.0) {
			rthdsd[i][n+1]=((my_bound.top[i].kappa*my_bound.top[i].FI_inf+my_bound.top[i].qset))/(my_bound.top[i].gamma/(y[n+1]-y[n])+my_bound.top[i].kappa);
		}
		else {
			rthdsd[i][n+1]=0.0;
		}		
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		if (my_bound.left[j].ap<0.0) {
            rthdsd[0][j]=((my_bound.left[j].kappa*my_bound.left[j].FI_inf+my_bound.left[j].qset))/(my_bound.left[j].gamma/(x[1]-x[0])+my_bound.left[j].kappa);
		}
		else {
			rthdsd[0][j]=0.0;
		}
		
		// правая граница
		if (my_bound.right[j].ap<0.0) {
			rthdsd[m+1][j]=((my_bound.right[j].kappa*my_bound.right[j].FI_inf+my_bound.right[j].qset))/(my_bound.right[j].gamma/(x[m+1]-x[m])+my_bound.right[j].kappa);
		}
		else {
			rthdsd[m+1][j]=0.0;
		}
		
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // constrrthdsd0

// Сборка правой части.
// данный метод пригоден для неравномерной сетки.
void constrrthdsd0potencialMESFET(Real** &rthdsd, Real** &rinternalsource, 
	               Real* x, Real* y, int m, int n, Real vgate, Real vdrain,Real xendsource, Real xstartgate, Real xendgate, Real xstartdrain) {

	// my_bound - информация о граничных узлах.

	// rinternalsource - источник для внутренности расчётной области.
	// именно строго внутренние контрольные объёмы.

	// Строго внутренние контрольные объёмы.
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			rthdsd[i][j]=rinternalsource[i][j];
		}
	}

	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		rthdsd[i][0]=0.0;

		// верхняя граница
		 if (x[i]<xendsource) {
			  rthdsd[i][n+1]=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			  
             rthdsd[i][n+1]=vgate; // gate
		   }
		   else if (x[i]>xstartdrain) {
			    rthdsd[i][n+1]=vdrain; // drain
		   }
		   else
		   {
		      rthdsd[i][n+1]=0.0;
		   }
				
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		rthdsd[0][j]=0.0;
		
		
		// правая граница
		rthdsd[m+1][j]=0.0;	
		
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // constrrthdsd0potencialMESFET

// Сборка правой части.
// данный метод пригоден для неравномерной сетки.
void constrrthdsd0MESFETn(Real** &rthdsd, Real** &rinternalsource, BONCONDOMAIN &my_bound,
	               Real* x, Real* y, int m, int n) {

	// my_bound - информация о граничных узлах.

	// rinternalsource - источник для внутренности расчётной области.
	// именно строго внутренние контрольные объёмы.

	// Строго внутренние контрольные объёмы.
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			rthdsd[i][j]=rinternalsource[i][j];
		}
	}
	/*
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		rthdsd[i][0]=0.0;

		// верхняя граница
		rthdsd[i][n+1]=0.0;
				
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		rthdsd[0][j]=0.0;
		
		
		// правая граница
		rthdsd[m+1][j]=0.0;
		
		
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;
	*/
} // constrrthdsd0MESFETn

// Сборка правой части.
// данный метод пригоден для неравномерной сетки.
void constrrthdsd0MESFETnu(Real** &rthdsd, Real** &rinternalsource, BONCONDOMAIN &my_bound,
	               Real* x, Real* y, int m, int n) {

	// my_bound - информация о граничных узлах.

	// rinternalsource - источник для внутренности расчётной области.
	// именно строго внутренние контрольные объёмы.

	// Строго внутренние контрольные объёмы.
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			rthdsd[i][j]=rinternalsource[i][j];
		}
	}
	/*
	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		rthdsd[i][0]=0.0;

		// верхняя граница
		rthdsd[i][n+1]=0.0;
				
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		rthdsd[0][j]=0.0;
		
		
		// правая граница
		rthdsd[m+1][j]=0.0;
		
		
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;
	*/
} // constrrthdsd0MESFETnu

// Делаем однородные краевые условия.
// Сборка правой части.
void constrrthdsdzero(Real** &rthdsd, int m, int n) {

	// граничные условия.
	for (int i=1; i<m+1; i++) {
		// нижняя граница
		rthdsd[i][0]=0.0;
		// верхняя граница
		rthdsd[i][n+1]=0.0;
	}
	// граничные условия.
	for (int j=1; j<n+1; j++) {
		// левая граница
		rthdsd[0][j]=0.0;
		// правая граница
		rthdsd[m+1][j]=0.0;
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // constrrthdsdzero

// Сборка матрицы СЛАУ.
// с коэффициентом теплопроводности lambdaxy распределённым в пространстве.
// Данный метод пригоден лишь для равномерной сетки.
/*
void constrA1(MATRNODE** &A, BONCONDOMAIN &my_bound, Real** &lambdaxy , int m, int n) {
	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(m+1));
	Real h2=(Real)(lengthy/(n+1));

	// Данная аппроксимация заимствована из книги Самарского.
	// По видимому данная аппроксимация совпадает с аппроксимацией по способу метода контрольного объёма.

	// Теплопроводность или коэффициент диффузии всегда положителен и ограничен сверху.
	// Строгую положительность можно использовать для аппроксимации по способу среднего гармонического.

	int igarmonicapprox=1; // 0 - среднее арефметическое, 1 - среднее гармоническое.

    switch(igarmonicapprox) {
	case 0 : // Теплопроводность аппроксимирована средним арифметическим.
	         // Внутренность матрицы.
	         for (int i=1; i<m+1; i++) {
	        	for (int j=1; j<n+1; j++) {
					
			       A[i][j].ae=(0.5*(lambdaxy[i][j]+lambdaxy[i+1][j]))/(h1*h1);
			       A[i][j].aw=(0.5*(lambdaxy[i-1][j]+lambdaxy[i][j]))/(h1*h1);
			       A[i][j].an=(0.5*(lambdaxy[i][j]+lambdaxy[i][j+1]))/(h2*h2);
			       A[i][j].as=(0.5*(lambdaxy[i][j]+lambdaxy[i][j-1]))/(h2*h2);
			       A[i][j].ap=(A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as);
		        }
	         }
			 break;
	case 1 : // Среднее гармоническое для теплопроводности.
		     // Внутренность матрицы.
	         for (int i=1; i<m+1; i++) {
	        	for (int j=1; j<n+1; j++) {
			       
			       A[i][j].ae=(0.5*lambdaxy[i][j]*lambdaxy[i+1][j])/((lambdaxy[i][j]+lambdaxy[i+1][j])*(h1*h1));
			       A[i][j].aw=(0.5*lambdaxy[i-1][j]*lambdaxy[i][j])/((lambdaxy[i-1][j]+lambdaxy[i][j])*(h1*h1));
			       A[i][j].an=(0.5*lambdaxy[i][j]*lambdaxy[i][j+1])/((lambdaxy[i][j]+lambdaxy[i][j+1])*(h2*h2));
			       A[i][j].as=(0.5*lambdaxy[i][j]*lambdaxy[i][j-1])/((lambdaxy[i][j]+lambdaxy[i][j-1])*(h2*h2));
			       A[i][j].ap=(A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as);
		        }
	         }
		     break;
	}

	
	// Условие Дирихле.
	boundaryDirichletApproach1(A, my_bound, m, n);

} // constrA1
*/

// Сборка матрицы СЛАУ.
// с коэффициентом теплопроводности lambdaxy распределённым в пространстве.
// Данный метод пригоден  для неравномерной сетки.
void constrA1(MATRNODE** &A, BONCONDOMAIN &my_bound, Real** &lambdaxy, 
	          Real* x, Real* y, int m, int n) {

	// Данная аппроксимация заимствована из книги Самарского.
	// По видимому данная аппроксимация совпадает с аппроксимацией по способу метода контрольного объёма.

	// Теплопроводность или коэффициент диффузии всегда положителен и ограничен сверху.
	// Строгую положительность можно использовать для аппроксимации по способу среднего гармонического.

	int igarmonicapprox=1; // 0 - среднее арефметическое, 1 - среднее гармоническое.

	// Сборка матрицы осуществляется по способу метода контрольного объёма.
	// Здесь используется поузловая а не поячечная сборка матрицы, грань контрольного объёма
	// находится строго посередине между узловыми точками, при этом центры контрольных объёмов
	// находятся не в геометрическом центре контрольного объёма.

    switch(igarmonicapprox) {
	case 0 : // Теплопроводность аппроксимирована средним арифметическим.
	         // Внутренность матрицы.
	         for (int i=1; i<m+1; i++) {
	        	for (int j=1; j<n+1; j++) {
					
					Real De, Dw, Ds, Dn;

			        De=(0.5*(lambdaxy[i][j]+lambdaxy[i+1][j]))*0.5*(y[j+1]-y[j-1])/(x[i+1]-x[i]);
			        Dw=(0.5*(lambdaxy[i-1][j]+lambdaxy[i][j]))*0.5*(y[j+1]-y[j-1])/(x[i]-x[i-1]);
			        Dn=(0.5*(lambdaxy[i][j]+lambdaxy[i][j+1]))*0.5*(x[i+1]-x[i-1])/(y[j+1]-y[j]);
			        Ds=(0.5*(lambdaxy[i][j]+lambdaxy[i][j-1]))*0.5*(x[i+1]-x[i-1])/(y[j]-y[j-1]);

			        A[i][j].ae=De;
			        A[i][j].aw=Dw;
			        A[i][j].an=Dn;
			        A[i][j].as=Ds;
			        A[i][j].ap=(A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as);
		        }
	         }
			 break;
	case 1 : // Среднее гармоническое для теплопроводности.
		     // Внутренность матрицы.
	         for (int i=1; i<m+1; i++) {
	        	for (int j=1; j<n+1; j++) {
			     
                   Real De, Dw, Ds, Dn;

			       De=((0.5*lambdaxy[i][j]*lambdaxy[i+1][j])/((lambdaxy[i][j]+lambdaxy[i+1][j])))*0.5*(y[j+1]-y[j-1])/(x[i+1]-x[i]);
			       Dw=((0.5*lambdaxy[i][j]*lambdaxy[i+1][j])/((lambdaxy[i][j]+lambdaxy[i+1][j])))*0.5*(y[j+1]-y[j-1])/(x[i]-x[i-1]);
			       Dn=((0.5*lambdaxy[i][j]*lambdaxy[i][j+1])/((lambdaxy[i][j]+lambdaxy[i][j+1])))*0.5*(x[i+1]-x[i-1])/(y[j+1]-y[j]);
			       Ds=((0.5*lambdaxy[i][j]*lambdaxy[i][j-1])/((lambdaxy[i][j]+lambdaxy[i][j-1])))*0.5*(x[i+1]-x[i-1])/(y[j]-y[j-1]);

			       A[i][j].ae=De;
			       A[i][j].aw=Dw;
			       A[i][j].an=Dn;
			       A[i][j].as=Ds;

			       A[i][j].ap=(A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as);
		        }
	         }
		     break;
	}

	
	// Условие Дирихле.
	boundaryDirichletApproach1(A, my_bound, x, y, m, n);

} // constrA1


// Сборка матрицы СЛАУ.
// для обобщённого уравнения конвекции - диффузии на пятиточечном шаблоне.
// На основе схемы Самарского. С краевыми условиями Дирихле.
// См. А.И. Федюшкин Исследование матричного метода решения уравнений конвекции.
// Комплекс программ "МАРЕНА". Москва 1990 год.
/*
void constrASamarskii(MATRNODE** &A, BONCONDOMAIN &my_bound, Real** &u, Real** &v, Real R, 
	                  Real dzeta1, Real dzeta2, int m, int n) {

	// пятиточечная аппроксимация.

	// Варианты аппроксимации:
	// dzeta1=dzeta2==0 - симметричные разности,
	// dzeta1=1, dzeta2=0 - направленные разности,
	// dzeta1=1, dzeta2=1 - монотонная аппроксимация А.А.Самарского.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(m+1));
	Real h2=(Real)(lengthy/(n+1));

    // Внутренность матрицы.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			// А.И. Федюшкин стр. 5

			Real a1, a2, a3, a4, a5, a6, a7, a8;
			a1=u[i][j];
			a2=-0.5*fabs(u[i][j])*dzeta1;
			a3=-a2;
			a4=v[i][j];
			a5=-0.5*fabs(v[i][j])*dzeta1;
			a6=-a5;
			a7=-R*R/(R+0.5*fabs(u[i][j])*h1*dzeta2);
			a8=-R*R/(R+0.5*fabs(v[i][j])*h2*dzeta2);

			A[i][j].ap=-a2/h1+a3/h1-a5/h2+a6/h2-2.0*a7/(h1*h1)-2.0*a8/(h2*h2);
			A[i][j].ae=-1.0*(0.5*a1/h1+a2/h1+a7/(h1*h1));
			A[i][j].aw=-1.0*(-0.5*a1/h1-a3/h1+a7/(h1*h1));
			A[i][j].an=-1.0*(0.5*a4/h2+a5/h2+a8/(h2*h2));
			A[i][j].as=-1.0*(-0.5*a4/h2-a6/h2+a8/(h2*h2));
		}
	}

    // Условие Дирихле.
	boundaryDirichletApproach1(A, my_bound, m, n);
	

} // constrASamarskii
*/

// Сборка матрицы СЛАУ.
// для обобщённого уравнения конвекции - диффузии на пятиточечном шаблоне.
// На основе схемы Самарского. С краевыми условиями Дирихле.
// См. А.И. Федюшкин Исследование матричного метода решения уравнений конвекции.
// Комплекс программ "МАРЕНА". Москва 1990 год.
// Данный код пригоден лишь для равномерной сетки.
void constrASamarskii(MATRNODE** &A, BONCONDOMAIN &my_bound, Real** &u, Real** &v, Real R, 
	                  Real dzeta1, Real dzeta2, Real* x, Real* y, int m, int n) {

	// пятиточечная аппроксимация.

	// Варианты аппроксимации:
	// dzeta1=dzeta2==0 - симметричные разности,
	// dzeta1=1, dzeta2=0 - направленные разности,
	// dzeta1=1, dzeta2=1 - монотонная аппроксимация А.А.Самарского.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(m+1));
	Real h2=(Real)(lengthy/(n+1));

    // Внутренность матрицы.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			// А.И. Федюшкин стр. 5

			Real a1, a2, a3, a4, a5, a6, a7, a8;
			a1=u[i][j];
			a2=-0.5*fabs(u[i][j])*dzeta1;
			a3=-a2;
			a4=v[i][j];
			a5=-0.5*fabs(v[i][j])*dzeta1;
			a6=-a5;
			a7=-R*R/(R+0.5*fabs(u[i][j])*h1*dzeta2);
			a8=-R*R/(R+0.5*fabs(v[i][j])*h2*dzeta2);

			A[i][j].ap=-a2/h1+a3/h1-a5/h2+a6/h2-2.0*a7/(h1*h1)-2.0*a8/(h2*h2);
			A[i][j].ae=-1.0*(0.5*a1/h1+a2/h1+a7/(h1*h1));
			A[i][j].aw=-1.0*(-0.5*a1/h1-a3/h1+a7/(h1*h1));
			A[i][j].an=-1.0*(0.5*a4/h2+a5/h2+a8/(h2*h2));
			A[i][j].as=-1.0*(-0.5*a4/h2-a6/h2+a8/(h2*h2));
		}
	}

    // Условие Дирихле.
	boundaryDirichletApproach1(A, my_bound, x, y, m, n);
	

} // constrASamarskii


// степенной закон Патанкара.
Real AP_Patankar(Real P) {
	Real r;

	/*
	r=1.0-0.1*fabs(P);
	r=r*r*r*r*r;

	r=maxf(0.0,r);
	*/

	// Схема В.К.Булгакова.
	
	if (fabs(P)<10000.0) {
	    r=1.0/(1.0+0.6712*P*P);
	}
	else
	{
		r=0.0;
	}
	
	//r=1.0;
	return r;
} // AP_Patankar

/*
// аппроксимация на равномерной сетке.
void constrAPatankar(MATRNODE** &A, BONCONDOMAIN &my_bound, Real** &u, Real** &v, Real rho, Real mu, 
	                  int m, int n) {


    // mu - коэффициент диффузии,
	// rho - коэффициент перед нестационарным и конвективным членами.
	// пятиточечная аппроксимация.

	// Варианты аппроксимации:
	// схема со степенным законом Патанкара.
	

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(m+1));
	Real h2=(Real)(lengthy/(n+1));

    // Внутренность матрицы.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			// А.И. Федюшкин стр. 5

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*0.5*(u[i+1][j]+u[i][j])*h2;
			Fw=rho*0.5*(u[i-1][j]+u[i][j])*h2;
			Fn=rho*0.5*(v[i][j+1]+v[i][j])*h1;
			Fs=rho*0.5*(v[i][j-1]+v[i][j])*h1;

			Real De, Ds, Dn, Dw;
			De=mu*h2/h1;
			Dw=mu*h2/h1;
			Dn=mu*h1/h2;
			Ds=mu*h1/h2;

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
            A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
		
		}
	}

    // Условие Дирихле.
	boundaryDirichletApproach1(A, my_bound, m, n);
	

} // constrAPatankar
*/


// минимум из двух чисел.
double fmin(double fA, double fB)
{
	double r;
	
	r = fA;
	if (fB < fA) {
		r = fB;
	}
    return r;	
} // fmin

// максимум из двух чисел.
double fmax(double fA, double fB)
{
	double r;
	
	r = fA;
	if (fB > fA) {
		r = fB;
	}
    return r;
} // fmax


// Схемы Высокой разрешающей способности.
// В надежде получить гораздо более реалистичное решение.

// Возвращает минимум из трёх чисел.
double fmin3(double fA, double fB, double fC) 
{
	return fmin(fmin(fA, fB), fC);
} // fmin3

// Возвращает минимум из четырёх чисел.
double fmin4(double fA, double fB, double fC, double fD)
{
	return  fmin(fmin3(fA, fB, fC), fD);
} // fmin4

// Возвращает максимум из трёх чисел.
double fmax3(double fA, double fB, double fC) 
{
	return fmax(fmax(fA, fB), fC);
} // fmax3

// см. дискретизация конвективных потоков в уравнениях Навье-Стокса
// на основе разностных схем высокой разрешающей способности.
// К.Н. Волков. стр. 135.
// Вычислительные методы и программирование. 2004. Т. 5.
double linear_flux_limiter(double kappa, double r)
{
      return 0.5 * ((1.0 + kappa) * r + (1.0 - kappa));
} // linear_flux_limiter

const int QUICK = 1000;
const int LUS = 1001;
const int CUS = 1002;
const int SMART = 1003;
const int H_QUICK = 1004;
const int UMIST = 1005;
const int CHARM = 1006;
const int MUSCL = 1007;
const int VAN_LEER_HARMONIC = 1008;
const int OSPRE = 1009;
const int VAN_ALBADA = 1010;
const int SUPERBEE = 1011;
const int MINMOD = 1012;
const int H_CUS = 1013;
const int KOREN = 1014;
const int FROMM = 1015;
//https://vunivere.ru/work11753/page6
const int USR_k = 1016;
const int W2 = 1017;
const int STUB = 1017; // заглушка.

// по мотивам программы проф. Сполдинга PHOENICS
// К сожалению это многообразие пригодно лишь для равномерной сетки.
double limiter_function(int ishconvection, double r)
{
	double Br, Konst;
	int ishloc;


	// Дискретизация конвективных потоков в уравнениях Навье-Стокса
	// на основе разностных схем высокой разрешающей способности К.Н.Волков.
	// Вычислительные методы и программирование. 2004. Т. 5.

	Br = fmax3(0.0, fmin(2.0 * r, 1.0), fmin(r, 2.0)); // SUPERBEE - схема по дефолту
	//Konst:=0.0;

	ishloc = ishconvection;
	if ((ishloc < QUICK) || (ishloc > FROMM))
	{
		// В качестве заглушки используется схема Леонарда QUICK.
	    ishloc = STUB;   // заглушка.
	}

	double k = 0.2;

	switch (ishloc) {
	case QUICK:
		Konst = 0.5;
		Br = linear_flux_limiter(Konst, r);
		break;
	case LUS:
		Konst = -1.0;
		Br = linear_flux_limiter(Konst, r);
		break;
	case CUS:
		Konst = 1.0 / 3.0;
		Br = linear_flux_limiter(Konst, r);
		break;
	case SMART:
		// ограниченная на основе QUICK
		Br = fmax(0.0, fmin3(2.0 * r, 0.75 * r + 0.25, 4.0));
		break;
	case H_QUICK:
		// гладкая на основе QUICK
		if (r <= 0.0) {
			Br = 0.0;
		}
		else
		{
			Br = 2.0 * (r + fabs(r)) / (r + 3.0);
		}
		break;
	case UMIST:
		// TVD на основе QUICK
		Br = fmax(0.0, fmin4(2.0 * r, 0.25 + 0.75 * r, 0.75 + 0.25 * r, 2.0));
		break;
	case CHARM:
		// ограниченная на основе QUICK
		if (r <= 0.0) {
			Br = 0.0;
		}
		else {
			Br = r * (3.0 * r + 1.0) / ((r + 1) * (r + 1));
		}
		break;
	case MUSCL:
		// TVD на базе Fromm
		Br = fmax(0.0, fmin3(2.0 * r, 0.5 + 0.5 * r, 2));
		break;
	case VAN_LEER_HARMONIC:
		// TVD на базе Fromm
		if (r < 0.0)
		{
			Br = 0.0;
		}
		else
		{
			Br = (r + fabs(r)) / (r + 1.0);
		}
		break;
	case OSPRE:
		// гладкая на основе Fromm
		Br = 3.0 * (r * r + r) / (2.0 * (r * r + r + 1.0));
		break;
	case VAN_ALBADA:
		// TVD на основе Fromm
		Br = (r * r + r) / (r * r + 1.0);
		break;
	case SUPERBEE:
		// TVD  (Roe, 1986)
		Br = fmax3(0.0, fmin(2.0 * r, 1.0), fmin(r, 2.0));
		break;
	case MINMOD:
		// (SOUCUP) TVD
		Br = fmax(0.0, fmin(r, 1.0));
		break;
	case H_CUS:
		// (HCUDS) гладкая на основе CUDS
		if (r <= 0.0) {
			Br = 0.0;
		}
		else {
			Br = 1.5 * (r + fabs(r)) / (r + 2.0);
		}
		break;
	case KOREN:
		// TVD на основе CUDS
		Br = fmax(0.0, fmin3(2.0 * r, 2.0 * r / 3.0 + 1.0 / 3.0, 2.0));
		break;
	case FROMM:
		Konst = 0.0; Br = 0.5 * ((1.0 + Konst) * r + (1.0 - Konst));
		break;
	case USR_k:
		// -1 <= k <= 1
		if (r <= 1.0 / 3.0) {
			Br = r + fabs(r);
		}
		else {
			Br = ((8.0 + 9.0 * k) * r * r + (2.0 - 12.0 * k) * r + 2.0 + 3.0 * k) / (3.0*(1.0+r)*(1.0+r));
		}
		break;
	case STUB:
		// В качестве заглушки использутся схема Леонарда QUICK.
		Konst = 0.5;
		Br = linear_flux_limiter(Konst, r);
		break;
	} // case
    return  Br;
} // limiter_function


// по мотивам программы проф. Сполдинга PHOENICS
// Возвращает значение искомой величины на грани контрольного объёма.
double cell_face_value_local(int ishconvection, double  Fc, double Fd, double Fu)
{
	const int UDS = 8; // противопоточная заглушка.

	double Ff; // значение функции на грани.
	bool bcontinue;
	double r;


	Ff = Fc;  // UDS Br==0 // противопоточная схема.
	bcontinue = true;

	if (fabs(Fc - Fu) < 1.0e-30)
	{
		bcontinue = false;
	}

	if (bcontinue)
	{

		r = (Fd - Fc) / (Fc - Fu);

		if (ishconvection = UDS) {
			Ff = Fc; // UDS
		}
		else
		{
			Ff = Fc + 0.5 * limiter_function(ishconvection, r) * (Fc - Fu); // Higher-Order Scheme
		}

	}

	return Ff;

}  // cell_face_value_local

// по мотивам программы проф. Сполдинга PHOENICS
// Возвращает значение искомой величины на грани контрольного объёма.
double cell_face_value_global(int ischeme, double uf, double fa, double fb, double fc, double fd)
{
	// ff : Float;
	double Fcloc, Fdloc, Fuloc;

	// uf - скорость на грани контрольного объёма.
    // fa, fb, fc, fd - значение искомой величины (с предыдущей итерации алгоритма SIMPLE)
	// в центрах контрольного объёма.

      /*sign(uf)	 U	C	f	D
	   * +WW	W	f	P
	   *
	   *sign(uf)	D	f	C	U
	   * -W	f	P	E
	   *
	   *f - face - поверхность на которой нужно получить искомую функцию(грань контрольного объёма).
	   */

	   //Fcloc:=0.0;
	   //Fdloc:=0.0;
	   //Fuloc:=0.0;

	if (uf >= 0.0) {

		Fcloc = fb;
		Fdloc = fc;
		Fuloc = fa;
	}
	else
	{
		Fcloc = fc;
		Fdloc = fb;
		Fuloc = fd;
	}

	return cell_face_value_local(ischeme, Fcloc, Fdloc, Fuloc);
}


// аппроксимация которая подходит и для неравномерной сетки.
void constrAPatankar(MATRNODE**& A, BONCONDOMAIN& my_bound, Real**& potent, Real**& rthdsd, Real**& u,   Real**& v, Real rho, Real mu,
	Real* x, Real* y, int m, int n) {


	// mu - коэффициент диффузии,
	// rho - коэффициент перед нестационарным и конвективным членами.
	// пятиточечная аппроксимация.

	// Варианты аппроксимации:
	// схема со степенным законом Патанкара.


	// Внутренность матрицы.
	for (int i = 1; i < m + 1; i++) {
		for (int j = 1; j < n + 1; j++) {


			Real deltay = 0.5 * (y[j + 1] - y[j - 1]);
			Real deltax = 0.5 * (x[i + 1] - x[i - 1]);

			Real Fe, Fw, Fn, Fs;


			Fe = rho * 0.5 * (u[i + 1][j] + u[i][j]) * deltay;
			Fw = rho * 0.5 * (u[i - 1][j] + u[i][j]) * deltay;
			Fn = rho * 0.5 * (v[i][j + 1] + v[i][j]) * deltax;
			Fs = rho * 0.5 * (v[i][j - 1] + v[i][j]) * deltax;

			Real De, Ds, Dn, Dw;
			De = mu * deltay / (x[i + 1] - x[i]);
			Dw = mu * deltay / (x[i] - x[i - 1]);
			Dn = mu * deltax / (y[j + 1] - y[j]);
			Ds = mu * deltax / (y[j] - y[j - 1]);

			Real Pe, Pn, Ps, Pw;
			Pe = Fe / De;
			Pn = Fn / Dn;
			Pw = Fw / Dw;
			Ps = Fs / Ds;



			/*A[i][j].ae = De * AP_Patankar(fabs(Pe)) + maxf(0.0, -Fe);
			A[i][j].aw = Dw * AP_Patankar(fabs(Pw)) + maxf(0.0, Fw);
			A[i][j].an = Dn * AP_Patankar(fabs(Pn)) + maxf(0.0, -Fn);
			A[i][j].as = Ds * AP_Patankar(fabs(Ps)) + maxf(0.0, Fs);
			A[i][j].ap = De * AP_Patankar(fabs(Pe)) + maxf(0.0, Fe) + Dw * AP_Patankar(fabs(Pw)) + maxf(0.0, -Fw) + Dn * AP_Patankar(fabs(Pn)) + maxf(0.0, Fn) + Ds * AP_Patankar(fabs(Ps)) + maxf(0.0, -Fs);
			*/
			// 10.05.2021
			//A[i][j].ap = A[i][j].ae + A[i][j].aw + A[i][j].an + A[i][j].as;

			// Против потока.
			/*A[i][j].ae = De + maxf(0.0, -Fe);
			A[i][j].aw = Dw  + maxf(0.0, Fw);
			A[i][j].an = Dn  + maxf(0.0, -Fn);
			A[i][j].as = Ds  + maxf(0.0, Fs);
			A[i][j].ap = De  + maxf(0.0, Fe) + Dw  + maxf(0.0, -Fw) + Dn  + maxf(0.0, Fn) + Ds  + maxf(0.0, -Fs);
			*/

			// Центрально разностная
			A[i][j].ae = fmax(De*(1.0-0.5* fabs(Pe)) + maxf(0.0, -Fe),0.0);
			A[i][j].aw = fmax(Dw * (1.0 - 0.5 * fabs(Pw)) + maxf(0.0, Fw), 0.0);
			A[i][j].an = fmax(Dn * (1.0 - 0.5 * fabs(Pn)) + maxf(0.0, -Fn), 0.0);
			A[i][j].as = fmax(Ds * (1.0 - 0.5 * fabs(Ps)) + maxf(0.0, Fs), 0.0);
			
			/*A[i][j].ap = fmax(De * (1.0 - 0.5 * fabs(Pe)) + maxf(0.0, Fe), 0.0) +
				fmax(Dw * (1.0 - 0.5 * fabs(Pw)) + maxf(0.0, -Fw), 0.0) +
					fmax(Dn * (1.0 - 0.5 * fabs(Pn)) + maxf(0.0, Fn), 0.0) +
					fmax(Ds * (1.0 - 0.5 * fabs(Ps)) + maxf(0.0, -Fs), 0.0);*/

			//stable
			A[i][j].ap = fmax(De * (1.0 - 0.5 * fabs(Pe)) + maxf(0.0, -Fe), 0.0) +
				fmax(Dw * (1.0 - 0.5 * fabs(Pw)) + maxf(0.0, Fw), 0.0) +
					fmax(Dn * (1.0 - 0.5 * fabs(Pn)) + maxf(0.0, -Fn), 0.0) +
					fmax(Ds * (1.0 - 0.5 * fabs(Ps)) + maxf(0.0, Fs), 0.0);
					
			/*A[i][j].ap = fmax(De * (1.0 - 0.5 * fabs(Pe)) + maxf(0.0, -Fe) +
				Dw * (1.0 - 0.5 * fabs(Pw)) + maxf(0.0, Fw) +
				Dn * (1.0 - 0.5 * fabs(Pn)) + maxf(0.0, -Fn) +
				Ds * (1.0 - 0.5 * fabs(Ps)) + maxf(0.0, Fs), 0.125*(De+Dw+Ds+Dn));*/

			double attrs = 0.0;

			//attrs += fabs(Fe-Fw+Fn-Fs);

			if (0) {

				// Центрально-разностная схема второго порядка точности с помощью
				// метода отложенной коррекции (неявно учитывается противопоточная часть).
				double f_forvardx = 0.5 * (potent[i][j] + potent[i + 1][j]);
				attrs = attrs - fmax(Fe, 0.0) * (f_forvardx - potent[i][j]) + fmax(-Fe, 0.0) * (f_forvardx - potent[i + 1][j]);
				double f_backvardx = 0.5 * (potent[i][j] + potent[i - 1][j]);
				attrs = attrs - fmax(-Fw, 0.0) * (f_backvardx - potent[i][j]) + fmax(Fw, 0.0) * (f_backvardx - potent[i - 1][j]);
				double f_forvardy = 0.5 * (potent[i][j] + potent[i][j + 1]);
				attrs = attrs - fmax(Fn, 0.0) * (f_forvardy - potent[i][j]) + fmax(-Fn, 0.0) * (f_forvardy - potent[i][j + 1]);
				double f_backvardy = 0.5 * (potent[i][j] + potent[i][j - 1]);
				attrs = attrs - fmax(-Fs, 0.0) * (f_backvardy - potent[i][j]) + fmax(Fs, 0.0) * (f_backvardy - potent[i][j - 1]);

			}
			else {			

				int ishconvtemp=SMART;

				if (i+1<m) {
					// E
					// можно обрабатывать грань схемой высокого порядка
					double f_forvardx = cell_face_value_global(ishconvtemp, 0.5 * (u[i + 1][j] + u[i][j]), potent[i-1][j], potent[i][j], potent[i+1][j], potent[i+2][j]);
					attrs = attrs - fmax(Fe, 0.0) * (f_forvardx - potent[i][j]) + fmax(-Fe, 0.0) * (f_forvardx - potent[i+1][j]);
				}
				if (i-1>0) {
					// W
					// можно обрабатывать грань схемой высокого порядка
					double f_backvardx = cell_face_value_global(ishconvtemp, 0.5 * (u[i - 1][j] + u[i][j]), potent[i - 2][j], potent[i-1][j], potent[i][j], potent[i + 1][j]);
					attrs = attrs - fmax(-Fw, 0.0) * (f_backvardx - potent[i][j]) + fmax(Fw, 0.0) * (f_backvardx - potent[i-1][j]);
				}
				if (j+1<n)
				{
					// N
					// можно обрабатывать грань схемой высокого порядка
					double f_forvardy = cell_face_value_global(ishconvtemp, 0.5 * (v[i][j + 1] + v[i][j]), potent[i][j-1], potent[i][j], potent[i][j+1], potent[i][j+2]);
					attrs = attrs - fmax(Fn, 0.0) * (f_forvardy - potent[i][j]) + fmax(-Fn, 0.0) * (f_forvardy - potent[i][j+1]);
				}
				if (j-1>0) {
					// S
					// можно обрабатывать грань схемой высокого порядка
					double f_backvardy  = cell_face_value_global(ishconvtemp, 0.5 * (v[i][j - 1] + v[i][j]), potent[i][j - 2], potent[i][j-1], potent[i][j], potent[i][j + 1]);
					attrs = attrs - fmax(-Fs, 0.0) * (f_backvardy - potent[i][j]) + fmax(Fs, 0.0) * (f_backvardy - potent[i][j-1]);
				}

			}

			rthdsd[i][j] = attrs;

		}
	}

	// Условие Дирихле.
	boundaryDirichletApproach1(A, my_bound, x, y, m, n);


} // constrAPatankar

// аппроксимация которая подходит и для неравномерной сетки.
void constrAPatankar(MATRNODE** &A, BONCONDOMAIN &my_bound, Real** &u, Real** &v, Real rho, Real mu, 
	                 Real* x, Real* y, int m, int n) {


    // mu - коэффициент диффузии,
	// rho - коэффициент перед нестационарным и конвективным членами.
	// пятиточечная аппроксимация.

	// Варианты аппроксимации:
	// схема со степенным законом Патанкара.
	

    // Внутренность матрицы.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*0.5*(u[i+1][j]+u[i][j])*deltay;
			Fw=rho*0.5*(u[i-1][j]+u[i][j])*deltay;
			Fn=rho*0.5*(v[i][j+1]+v[i][j])*deltax;
			Fs=rho*0.5*(v[i][j-1]+v[i][j])*deltax;

			Real De, Ds, Dn, Dw;
			De=mu*deltay/(x[i+1]-x[i]);
			Dw=mu*deltay/(x[i]-x[i-1]);
			Dn=mu*deltax/(y[j+1]-y[j]);
			Ds=mu*deltax/(y[j]-y[j-1]);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
		
			// 10.05.2021
			//A[i][j].ap = A[i][j].ae + A[i][j].aw + A[i][j].an + A[i][j].as;

		}
	}

    // Условие Дирихле.
	boundaryDirichletApproach1(A, my_bound, x, y, m, n);
	

} // constrAPatankar



// аппроксимация которая подходит и для неравномерной сетки.
void constrAPatankarMESFET(MATRNODE** &A, BONCONDOMAIN &my_bound, Real** &u, Real** &v, Real rho, Real mu, 
	                 Real* x, Real* y, int m, int n) {


    // mu - коэффициент диффузии,
	// rho - коэффициент перед нестационарным и конвективным членами.
	// пятиточечная аппроксимация.

	// Варианты аппроксимации:
	// схема со степенным законом Патанкара.
	

    // Внутренность матрицы.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*0.5*(u[i+1][j]+u[i][j])*deltay;
			Fw=rho*0.5*(u[i-1][j]+u[i][j])*deltay;
			Fn=rho*0.5*(v[i][j+1]+v[i][j])*deltax;
			Fs=rho*0.5*(v[i][j-1]+v[i][j])*deltax;

			Real De, Ds, Dn, Dw;
			De=mu*deltay/(x[i+1]-x[i]);
			Dw=mu*deltay/(x[i]-x[i-1]);
			Dn=mu*deltax/(y[j+1]-y[j]);
			Ds=mu*deltax/(y[j]-y[j-1]);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}

    // Условие Дирихле.
	boundaryApproachMesfet(A, my_bound, x, y, m, n);
	

} // constrAPatankarMESFET

// аппроксимация которая подходит и для неравномерной сетки.
void constrAPatankarMESFET2(MATRNODE** &A, BONCONDOMAIN &my_bound, Real** &uf, Real** &vf, Real rho, Real mu, 
	                 Real* x, Real* y, int m, int n) {


    // mu - коэффициент диффузии,
	// rho - коэффициент перед нестационарным и конвективным членами.
	// пятиточечная аппроксимация.

	// Варианты аппроксимации:
	// схема со степенным законом Патанкара.
	

    // Внутренность матрицы.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

#if 0
			if (mu<(x[i+1]-x[i])*fabs(uf[i][j])) {
				printf("izmenenie Dn internal\n");
			}
			if (mu<(x[i]-x[i-1])*fabs(uf[i-1][j])) {
				printf("izmenenie Dn internal\n");
			}
			if (mu<(y[j+1]-y[j])*fabs(vf[i][j])) {
				printf("izmenenie Dn internal\n");
			}
			if (mu<(y[j]-y[j-1])*fabs(vf[i][j-1])) {
				printf("izmenenie Dn internal\n");
			}

#endif

			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=mu*deltay/(x[i+1]-x[i]);
			Dw=mu*deltay/(x[i]-x[i-1]);
			Dn=mu*deltax/(y[j+1]-y[j]);
			Ds=mu*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}

    // Условие Дирихле.
	boundaryApproachMesfet(A, my_bound, x, y, m, n);
	

} // constrAPatankarMESFET2

// отличается от второй версии тем что коэффициент диффузии распределен в пространстве (это справедливо для энергетического коэффициента диффузии.
// аппроксимация которая подходит и для неравномерной сетки.
void constrAPatankarMESFET3(MATRNODE** &A, BONCONDOMAIN &my_bound, Real** &uf, Real** &vf, Real rho, Real** &mu, 
	                 Real* x, Real* y, int m, int n) {


    // mu - коэффициент диффузии,
	// rho - коэффициент перед нестационарным и конвективным членами.
	// пятиточечная аппроксимация.

	// Варианты аппроксимации:
	// схема со степенным законом Патанкара.
	

    // Внутренность матрицы.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=(2.0*mu[i][j]*mu[i+1][j]/(mu[i][j]+mu[i+1][j]))*deltay/(x[i+1]-x[i]);
			Dw=(2.0*mu[i][j]*mu[i-1][j]/(mu[i][j]+mu[i-1][j]))*deltay/(x[i]-x[i-1]);
			Dn=(2.0*mu[i][j]*mu[i][j+1]/(mu[i][j]+mu[i][j+1]))*deltax/(y[j+1]-y[j]);
			Ds=(2.0*mu[i][j]*mu[i][j-1]/(mu[i][j]+mu[i][j-1]))*deltax/(y[j]-y[j-1]);

			/* Убрать! 24 окт 2014
			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);
			*/

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}

    // Условие Дирихле.
	boundaryApproachMesfet(A, my_bound, x, y, m, n);
	

} // constrAPatankarMESFET3

// аппроксимация которая подходит и для неравномерной сетки.
// Коэффициент диффузии в уравнении переноса электронного газа взят зависящим от пространственных координат.
void constrAPatankarMESFET2AlGaNGaN(MATRNODE** &A, BONCONDOMAIN &my_bound, Real** &uf, Real** &vf, Real rho, Real** mu, 
	                 Real* x, Real* y, int m, int n) {


    // mu - коэффициент диффузии,
	// rho - коэффициент перед нестационарным и конвективным членами.
	// пятиточечная аппроксимация.

	// Варианты аппроксимации:
	// схема со степенным законом Патанкара.
	

    // Внутренность матрицы.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}

    // Условие Дирихле.
	boundaryApproachMesfet(A, my_bound, x, y, m, n);
	

} // constrAPatankarMESFET2AlGaNGaN

// аппроксимация которая подходит и для неравномерной сетки.
// Коэффициент диффузии в уравнении переноса электронного газа взят зависящим от пространственных координат.
void constrAPatankarMESFET2AlGaNGaNP(MATRNODE** &A, BONCONDOMAIN &my_bound, Real** &uf, Real** &vf, Real rho, Real** mu, 
	                 Real* x, Real* y, int m, int n, int inumcore) {


    // mu - коэффициент диффузии,
	// rho - коэффициент перед нестационарным и конвективным членами.
	// пятиточечная аппроксимация.

	// Варианты аппроксимации:
	// схема со степенным законом Патанкара.

	//omp_set_dynamic(0); // не давать системе использовать количество нитей которое она хочет.
	//omp_set_num_threads(inumcore); // два потока
	
    if (inumcore==1) {
    // Внутренность матрицы.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
	}

	if (inumcore==2) {
		int iM2=(int)((m+2)/2);

#pragma omp parallel shared(m,n,x,y,uf,vf,mu,A)
		{
#pragma omp sections
			{
#pragma omp section
				{
 // Внутренность матрицы.
	for (int i=1; i<iM2; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
#pragma omp section
				{
					// Внутренность матрицы.
	for (int i=iM2; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
			}
		}
   
	
	}

	if (inumcore==4) {
		int iM2=(int)((m+2)/2);
		int iM4=(int)(iM2/2);
		int iM5=iM2+iM4;

#pragma omp parallel shared(m,n,x,y,uf,vf,mu,A)
		{
#pragma omp sections
			{
#pragma omp section
				{
 // Внутренность матрицы.
	for (int i=1; i<iM4; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
#pragma omp section
				{
 // Внутренность матрицы.
	for (int i=iM4; i<iM2; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
#pragma omp section
				{
 // Внутренность матрицы.
	for (int i=iM2; i<iM5; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
#pragma omp section
				{
					// Внутренность матрицы.
	for (int i=iM5; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
			}
		}
   
	
	}


	if (inumcore==8) {
		int iM2=(int)((m+2)/2);
		int iM4=(int)(iM2/2);
		int iM5=iM2+iM4;
		int iM6=(int)(iM4/2);
		int iM7=iM4+iM6;
		int iM8=iM2+iM6;
		int iM9=iM5+iM6;

#pragma omp parallel shared(m,n,x,y,uf,vf,mu,A)
		{
#pragma omp sections
			{
#pragma omp section
				{
 // Внутренность матрицы.
	for (int i=1; i<iM6; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
#pragma omp section
				{
 // Внутренность матрицы.
	for (int i=iM6+1; i<iM4; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
#pragma omp section
				{
 // Внутренность матрицы.
	for (int i=iM4+1; i<iM7; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
#pragma omp section
				{
 // Внутренность матрицы.
	for (int i=iM7+1; i<iM2; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
#pragma omp section
				{
 // Внутренность матрицы.
	for (int i=iM2+1; i<iM8; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
#pragma omp section
				{
 // Внутренность матрицы.
	for (int i=iM8+1; i<iM5; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
#pragma omp section
				{
					// Внутренность матрицы.
	for (int i=iM5+1; i<iM9; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
		
		}
   
#pragma omp section
				{
					// Внутренность матрицы.
	for (int i=iM9+1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
	}
				}
			}
		}

// Для того чтобы области не пересекались взаимно.
for (int k=0; k<7; k++) {
	int i;
	if (k==0 ) {
		i=iM9;
	}
	if (k==1 ) {
		i=iM5;
	}
	if (k==2 ) {
		i=iM8;
	}
	if (k==3 ) {
		i=iM2;
	}
	if (k==4 ) {
		i=iM7;
	}
	if (k==5 ) {
		i=iM4;
	}
	if (k==6 ) {
		i=iM6;
	}

   
	   	for (int j=1; j<n+1; j++) {
			

			Real deltay=0.5*(y[j+1]-y[j-1]);
	        Real deltax=0.5*(x[i+1]-x[i-1]);

			Real Fe, Fw, Fn, Fs;

			
			Fe=rho*uf[i][j]*deltay;
			Fw=rho*uf[i-1][j]*deltay;
			Fn=rho*vf[i][j]*deltax;
			Fs=rho*vf[i][j-1]*deltax;

			Real De, Ds, Dn, Dw;
			De=0.5*(mu[i][j]+mu[i+1][j])*deltay/(x[i+1]-x[i]);
			Dw=0.5*(mu[i-1][j]+mu[i][j])*deltay/(x[i]-x[i-1]);
			Dn=0.5*(mu[i][j]+mu[i][j+1])*deltax/(y[j+1]-y[j]);
			Ds=0.5*(mu[i][j-1]+mu[i][j])*deltax/(y[j]-y[j-1]);

			// см. статью Гарбера 90 года.
			if (De<fabs(Fe)) De=fabs(Fe);
			if (Dw<fabs(Fw)) Dw=fabs(Fw);
			if (Ds<fabs(Fs)) Ds=fabs(Fs);
			if (Dn<fabs(Fn)) Dn=fabs(Fn);

			Real Pe, Pn, Ps, Pw;
			Pe=Fe/De;
			Pn=Fn/Dn;
			Pw=Fw/Dw;
			Ps=Fs/Ds;
			

			
			A[i][j].ae=De*AP_Patankar(fabs(Pe))+maxf(0.0,-Fe);
			A[i][j].aw=Dw*AP_Patankar(fabs(Pw))+maxf(0.0,Fw);
			A[i][j].an=Dn*AP_Patankar(fabs(Pn))+maxf(0.0,-Fn);
			A[i][j].as=Ds*AP_Patankar(fabs(Ps))+maxf(0.0,Fs);
			// именно так :
			A[i][j].ap=De*AP_Patankar(fabs(Pe))+maxf(0.0,Fe)+Dw*AP_Patankar(fabs(Pw))+maxf(0.0,-Fw)+Dn*AP_Patankar(fabs(Pn))+maxf(0.0,Fn)+Ds*AP_Patankar(fabs(Ps))+maxf(0.0,-Fs);
			// и ни в коем случае так, иначе нефизичное решение !!!
			// нефизичность решения состоит в том что под затвором появляется большой
			// потенциал около 25В при напряжении на стоке 10В и на затворе -1В при протяженности кремниевой области 9мкм и высотой 1.8мкм.
			//A[i][j].ap=A[i][j].ae+A[i][j].aw+A[i][j].an+A[i][j].as;
		
		}
}
	
	
	}

    // Условие Дирихле.
	boundaryApproachMesfet(A, my_bound, x, y, m, n);
	

} // constrAPatankarMESFET2AlGaNGaNP



/*
// Создаёт граничное условие для вихря на твёрдой неподвижной стенке.
// пригодно лишь для равномерной расчётной сетки.
void curlbound(Real** &curl, Real** &psi, int ischemeapprox, 
	           int m, int n, Real alpha) {

	// Внимание: Если не применять нижнюю релаксацию к грагничному условию для вихря 
	// то мы будем иметь спустя несколько шагов по времени расходимость всего вычислительного процесса.
	// Это очень важно т.к. возможно это одна из причин неработоспособности AliceFlow_v0_07.

	// alpha - коэффициент релаксации согласованный с псевдовременем или реальным временем.
	// По поводу нижней релаксации смотри Полежаев Пасконов Чудов. alpha не зависит от tau.
	// Возьмём коэффициент 0.1 например. Но!!! организуем дополнительный внутренний цикл. Один внешний цикл 
	// для изменения времени, а другой внутренний для точного выполнения граничного условия для вихря. 
	//Real alpha=0.1;//tau/(1.0+tau); // 1.0 //предполагается что ap в граничной точке равен 1.0.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(m+1));
	Real h2=(Real)(lengthy/(n+1));

	// Внимание ! Формулы для аппроксимации вихря вблизи границы пригодны лишь для равномерной сетки,
	// Поэтому пусть ближайшие три точки к каждой стенке покрыты равномерной сеткой, два ближайших к стенке шага сетки должны быть равны,
	// остальные же узлы могут неравномерно отстоять друг от друга.

	// Условие Дирихле.
	for (int i=1; i<m+1; i++) {
		switch (ischemeapprox) {
		case TOMA : // условие Тома
			        //curl[i][0]=2.0*(psi[i][1]-psi[i][0])/(h2*h2); // Условие ТОМА (тип Дирихле)
		            //curl[i][n+1]=2.0*(psi[i][n]-psi[i][n+1])/(h2*h2);  // Условие ТОМА (тип Дирихле)
					curl[i][0]=curl[i][0]+alpha*(2.0*(psi[i][1]-psi[i][0])/(h2*h2)-curl[i][0]); // Условие ТОМА (тип Дирихле)
		            curl[i][n+1]=curl[i][n+1]+alpha*(2.0*(psi[i][n]-psi[i][n+1])/(h2*h2)-curl[i][n+1]);  // Условие ТОМА (тип Дирихле)
					break;
		case WOODS : // Условие Вудса.
			        // curl[i][0]=-0.5*curl[i][1]+3.0*(psi[i][0]-psi[i][1])/(h2*h2);
                    // curl[i][n+1]=-0.5*curl[i][n]+3.0*(psi[i][n+1]-psi[i][n])/(h2*h2);
			        curl[i][0]=curl[i][0]+alpha*(-0.5*curl[i][1]+3.0*(psi[i][0]-psi[i][1])/(h2*h2)-curl[i][0]);
                    curl[i][n+1]=curl[i][n+1]+alpha*(-0.5*curl[i][n]+3.0*(psi[i][n+1]-psi[i][n])/(h2*h2)-curl[i][n+1]);
			        break;
		case JENSEN : // Условие Йенсена.
			        // нижняя стенка
			        curl[i][0]=curl[i][0]+alpha*((-7.0*psi[i][0]+8.0*psi[i][1]-psi[i][2])/(2.0*h2*h2)-curl[i][0]);
					// верхняя стенка
					curl[i][n+1]=curl[i][n+1]+alpha*((-7.0*psi[i][n+1]+8.0*psi[i][n]-psi[i][n-1])/(2.0*h2*h2)-curl[i][n+1]);
			        break;
		}
	}
	// Условие Дирихле.
	for (int i=1; i<n+1; i++) {
		switch (ischemeapprox) {
		case TOMA : // условие Тома
		            //curl[0][i]=2.0*(psi[1][i]-psi[0][i])/(h1*h1); // Условие ТОМА (тип Дирихле)
		            //curl[m+1][i]=2.0*(psi[m][i]-psi[m+1][i])/(h1*h1); // Условие ТОМА (тип Дирихле)
					curl[0][i]=curl[0][i]+alpha*(2.0*(psi[1][i]-psi[0][i])/(h1*h1)-curl[0][i]); // Условие ТОМА (тип Дирихле)
		            curl[m+1][i]=curl[m+1][i]+alpha*(2.0*(psi[m][i]-psi[m+1][i])/(h1*h1)-curl[m+1][i]); // Условие ТОМА (тип Дирихле)
					break;
        case WOODS : // Условие Вудса.
			        // curl[0][i]=-0.5*curl[1][i]+3.0*(psi[0][i]-psi[1][i])/(h1*h1);
			        // curl[m+1][i]=-0.5*curl[m][i]+3.0*(psi[m+1][i]-psi[m][i])/(h1*h1);
			        curl[0][i]=curl[0][i]+alpha*(-0.5*curl[1][i]+3.0*(psi[0][i]-psi[1][i])/(h1*h1)-curl[0][i]);
			        curl[m+1][i]=curl[m+1][i]+alpha*(-0.5*curl[m][i]+3.0*(psi[m+1][i]-psi[m][i])/(h1*h1)-curl[m+1][i]);
			        break;
        case JENSEN : // Условие Йенсена.
			        // левая стенка
			        curl[0][i]=curl[0][i]+alpha*((-7.0*psi[0][i]+8.0*psi[1][i]-psi[2][i])/(2.0*h1*h1)-curl[0][i]);
					// правая стенка
					curl[m+1][i]=curl[m+1][i]+alpha*((-7.0*psi[m+1][i]+8.0*psi[m][i]-psi[m-1][i])/(2.0*h1*h1)-curl[m+1][i]);
			        break;
		}
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	curl[0][0]=0.5*(curl[0][1]+curl[1][0]);
	curl[m+1][0]=0.5*(curl[m][0]+curl[m+1][1]);
	curl[0][n+1]=0.5*(curl[1][n+1]+curl[0][n]);
	curl[m+1][n+1]=0.5*(curl[m][n+1]+curl[m+1][n]);

} // curlbound
*/


// Создаёт граничное условие для вихря на твёрдой неподвижной стенке.
// пригодно  для квазинеравномерной расчётной сетки.
void curlbound(Real** &curl, Real** &psi, int ischemeapprox, 
	           Real* x, Real* y, int m, int n, Real alpha) {

	// Внимание: Если не применять нижнюю релаксацию к грагничному условию для вихря 
	// то мы будем иметь спустя несколько шагов по времени расходимость всего вычислительного процесса.
	// Это очень важно т.к. возможно это одна из причин неработоспособности AliceFlow_v0_07.

	// alpha - коэффициент релаксации согласованный с псевдовременем или реальным временем.
	// По поводу нижней релаксации смотри Полежаев Пасконов Чудов. alpha не зависит от tau.
	// Возьмём коэффициент 0.1 например. Но!!! организуем дополнительный внутренний цикл. Один внешний цикл 
	// для изменения времени, а другой внутренний для точного выполнения граничного условия для вихря. 
	//Real alpha=0.1;//tau/(1.0+tau); // 1.0 //предполагается что ap в граничной точке равен 1.0.


	// Внимание ! Формулы для аппроксимации вихря вблизи границы пригодны лишь для равномерной сетки,
	// Поэтому пусть ближайшие три точки к каждой стенке покрыты равномерной сеткой, два ближайших к стенке шага сетки должны быть равны,
	// остальные же узлы могут неравномерно отстоять друг от друга.

	// Условие Дирихле.
	for (int i=1; i<m+1; i++) {
		switch (ischemeapprox) {
		case TOMA : // условие Тома
			        //curl[i][0]=2.0*(psi[i][1]-psi[i][0])/(h2*h2); // Условие ТОМА (тип Дирихле)
		            //curl[i][n+1]=2.0*(psi[i][n]-psi[i][n+1])/(h2*h2);  // Условие ТОМА (тип Дирихле)
					curl[i][0]=curl[i][0]+alpha*(2.0*(psi[i][1]-psi[i][0])/((y[1]-y[0])*(y[1]-y[0]))-curl[i][0]); // Условие ТОМА (тип Дирихле)
		            curl[i][n+1]=curl[i][n+1]+alpha*(2.0*(psi[i][n]-psi[i][n+1])/((y[n+1]-y[n])*(y[n+1]-y[n]))-curl[i][n+1]);  // Условие ТОМА (тип Дирихле)
					break;
		case WOODS : // Условие Вудса.
			        // curl[i][0]=-0.5*curl[i][1]+3.0*(psi[i][0]-psi[i][1])/(h2*h2);
                    // curl[i][n+1]=-0.5*curl[i][n]+3.0*(psi[i][n+1]-psi[i][n])/(h2*h2);
			        curl[i][0]=curl[i][0]+alpha*(-0.5*curl[i][1]+3.0*(psi[i][0]-psi[i][1])/((y[1]-y[0])*(y[1]-y[0]))-curl[i][0]);
                    curl[i][n+1]=curl[i][n+1]+alpha*(-0.5*curl[i][n]+3.0*(psi[i][n+1]-psi[i][n])/((y[n+1]-y[n])*(y[n+1]-y[n]))-curl[i][n+1]);
			        break;
		case JENSEN : // Условие Йенсена.
			        // нижняя стенка
			        curl[i][0]=curl[i][0]+alpha*((-7.0*psi[i][0]+8.0*psi[i][1]-psi[i][2])/(2.0*(y[1]-y[0])*(y[1]-y[0]))-curl[i][0]);
					// верхняя стенка
					curl[i][n+1]=curl[i][n+1]+alpha*((-7.0*psi[i][n+1]+8.0*psi[i][n]-psi[i][n-1])/(2.0*(y[n+1]-y[n])*(y[n+1]-y[n]))-curl[i][n+1]);
			        break;
		}
	}
	// Условие Дирихле.
	for (int i=1; i<n+1; i++) {
		switch (ischemeapprox) {
		case TOMA : // условие Тома
		            //curl[0][i]=2.0*(psi[1][i]-psi[0][i])/(h1*h1); // Условие ТОМА (тип Дирихле)
		            //curl[m+1][i]=2.0*(psi[m][i]-psi[m+1][i])/(h1*h1); // Условие ТОМА (тип Дирихле)
					curl[0][i]=curl[0][i]+alpha*(2.0*(psi[1][i]-psi[0][i])/((x[1]-x[0])*(x[1]-x[0]))-curl[0][i]); // Условие ТОМА (тип Дирихле)
		            curl[m+1][i]=curl[m+1][i]+alpha*(2.0*(psi[m][i]-psi[m+1][i])/((x[m+1]-x[m])*(x[m+1]-x[m]))-curl[m+1][i]); // Условие ТОМА (тип Дирихле)
					break;
        case WOODS : // Условие Вудса.
			        // curl[0][i]=-0.5*curl[1][i]+3.0*(psi[0][i]-psi[1][i])/(h1*h1);
			        // curl[m+1][i]=-0.5*curl[m][i]+3.0*(psi[m+1][i]-psi[m][i])/(h1*h1);
			        curl[0][i]=curl[0][i]+alpha*(-0.5*curl[1][i]+3.0*(psi[0][i]-psi[1][i])/((x[1]-x[0])*(x[1]-x[0]))-curl[0][i]);
			        curl[m+1][i]=curl[m+1][i]+alpha*(-0.5*curl[m][i]+3.0*(psi[m+1][i]-psi[m][i])/((x[m+1]-x[m])*(x[m+1]-x[m]))-curl[m+1][i]);
			        break;
        case JENSEN : // Условие Йенсена.
			        // левая стенка
			        curl[0][i]=curl[0][i]+alpha*((-7.0*psi[0][i]+8.0*psi[1][i]-psi[2][i])/(2.0*(x[1]-x[0])*(x[1]-x[0]))-curl[0][i]);
					// правая стенка
					curl[m+1][i]=curl[m+1][i]+alpha*((-7.0*psi[m+1][i]+8.0*psi[m][i]-psi[m-1][i])/(2.0*(x[m+1]-x[m])*(x[m+1]-x[m]))-curl[m+1][i]);
			        break;
		}
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	curl[0][0]=0.5*(curl[0][1]+curl[1][0]);
	curl[m+1][0]=0.5*(curl[m][0]+curl[m+1][1]);
	curl[0][n+1]=0.5*(curl[1][n+1]+curl[0][n]);
	curl[m+1][n+1]=0.5*(curl[m][n+1]+curl[m+1][n]);

} // curlbound



// Экономично находит компоненты скорости по рассчитанной функции тока.
// Пригодно для случая равномерной сетки.
/*
void calcvelocity1(Real** psi, Real** &u, Real** &v, int m, int n) {

	bool buserdefinevelocity=false; // если true то скорости определяются как заданные пользователем это
	// находится в противоречии со способом определяемым с помощью функции тока. Если false то компоненты скорости
	// на границе находятся из вычисления производных от функции тока.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(m+1));
	Real h2=(Real)(lengthy/(n+1));

	// Нахождение производных на равномерной сетке.

	// Внутренность расчётной области.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			// u=diff(psi,y);
			u[i][j]=0.5*(psi[i][j+1]-psi[i][j-1])/h2;
			// v=-diff(psi,x);
			v[i][j]=-0.5*(psi[i+1][j]-psi[i-1][j])/h1;
		}
	}
	/*
	// Внутренность расчётной области.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			// u=diff(psi,y);
			u[i][j]=0.5*(psi[i+1][j]-psi[i-1][j])/h2;
			// v=-diff(psi,x);
			v[i][j]=-0.5*(psi[i][j+1]-psi[i][j-1])/h1;
		}
	}*//*

	// Граничные значения скоростей.
	if (buserdefinevelocity) {
		// Можно конечно просто нули записать и всё (первый вариант),
	    // Граничные условия для компонент скорости.
	    // Горизонтальная скорость:
	    Real ULEFT=0.0;
	    Real URIGHT=0.0;
 	    Real UTOP=0.0;
	    Real UBOTTOM=0.0;
 	    // Вертикальная скорость:
	    Real VLEFT=0.0;
	    Real VRIGHT=0.0;
	    Real VTOP=0.0;
	    Real VBOTTOM=0.0;
	    // Условие Дирихле.
	    for (int i=1; i<m+1; i++) {
		   u[i][0]=UBOTTOM; 
		   u[i][n+1]=UTOP;
		   v[i][0]=VBOTTOM; 
		   v[i][n+1]=VTOP;
	    }
	    // Условие Дирихле.
	    for (int j=1; j<n+1; j++) {
		   u[0][j]=ULEFT; 
		   u[m+1][j]=URIGHT;
           v[0][j]=VLEFT; 
		   v[m+1][j]=VRIGHT;
	    }
	}
	else {
		// а во втором варианте будем искат как положено через производные от функции тока.
	    // Условие Дирихле.
	    for (int i=1; i<m+1; i++) {
			
			// нижняя граница (горизонтальная скорость)
		    u[i][0]=(psi[i][1]-psi[i][0])/h2;
			// верхняя граница (горизонтальная скорость)
		    u[i][n+1]=(psi[i][n+1]-psi[i][n])/h2;
			// нижняя граница (вертикальная скорость)
            v[i][0]=-0.5*(psi[i+1][0]-psi[i-1][0])/h1;
			// верхняя граница (вертикальная скорость)
		    v[i][n+1]=-0.5*(psi[i+1][n+1]-psi[i-1][n+1])/h1;
			/*
			// левая граница (горизонтальная скорость)
		    u[i][0]=0.5*(psi[i+1][0]-psi[i-1][0])/h2;
			// правая граница (горизонтальная скорость)
		    u[i][n+1]=0.5*(psi[i+1][n+1]-psi[i-1][n+1])/h2;
			// левая граница (вертикальная скорость)
            v[i][0]=-(psi[i][1]-psi[i][0])/h1;
			// правая граница (вертикальная скорость)
		    v[i][n+1]=-(psi[i][n+1]-psi[i][n])/h1;*//*
	    }
	    // Условие Дирихле.
	    for (int j=1; j<n+1; j++) {
			
			// горизонтальная скорость (левая граница)
		    u[0][j]=0.5*(psi[0][j+1]-psi[0][j-1])/h2;
			// горизонтальная скорость (правая граница)
		    u[m+1][j]=0.5*(psi[m+1][j+1]-psi[m+1][j-1])/h2;
			// вертикальная скорость (левая граница)
			v[0][j]=-(psi[1][j]-psi[0][j])/h1;
			// вертикальная скорость (правая граница)
		    v[m+1][j]=-(psi[m+1][j]-psi[m][j])/h1;
			/*
			// горизонтальная скорость (нижняя граница)
		    u[0][j]=(psi[1][j]-psi[0][j])/h2;
			// горизонтальная скорость (верхняя граница)
		    u[m+1][j]=(psi[m+1][j]-psi[m][j])/h2;
			// вертикальная скорость (нижняя граница)
			v[0][j]=-0.5*(psi[0][j+1]-psi[0][j-1])/h1;
			// вертикальная скорость (верхняя граница)
		    v[m+1][j]=-0.5*(psi[m+1][j+1]-psi[m+1][j-1])/h1;*//*
	    }
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	u[0][0]=0.5*(u[0][1]+u[1][0]);
	u[m+1][0]=0.5*(u[m][0]+u[m+1][1]);
	u[0][n+1]=0.5*(u[1][n+1]+u[0][n]);
	u[m+1][n+1]=0.5*(u[m][n+1]+u[m+1][n]);
	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	v[0][0]=0.5*(v[0][1]+v[1][0]);
	v[m+1][0]=0.5*(v[m][0]+v[m+1][1]);
	v[0][n+1]=0.5*(v[1][n+1]+v[0][n]);
	v[m+1][n+1]=0.5*(v[m][n+1]+v[m+1][n]);

} // calcvelocity1
*/


// Экономично находит компоненты скорости по рассчитанной функции тока.
// пригодно для неравномерной сетки.
void calcvelocity1(Real** psi, Real** &u, Real** &v, 
	               Real* x, Real* y, int m, int n) {

	bool buserdefinevelocity=false; // если true то скорости определяются как заданные пользователем это
	// находится в противоречии со способом определяемым с помощью функции тока. Если false то компоненты скорости
	// на границе находятся из вычисления производных от функции тока.


	// Нахождение производных на равномерной сетке.

	// Внутренность расчётной области.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			// u=diff(psi,y);
			//u[i][j]=0.5*(psi[i][j+1]-psi[i][j-1])/h2;
			// см. Г.З. Гарбер стр 210.
			u[i][j]=((psi[i][j+1]-psi[i][j])*(y[j]-y[j-1])*(y[j]-y[j-1])-(psi[i][j-1]-psi[i][j])*(y[j+1]-y[j])*(y[j+1]-y[j]))/((y[j+1]-y[j])*(y[j]-y[j-1])*(y[j+1]-y[j-1]));
			// v=-diff(psi,x);
			//v[i][j]=-0.5*(psi[i+1][j]-psi[i-1][j])/h1;
			v[i][j]=-((psi[i+1][j]-psi[i][j])*(x[i]-x[i-1])*(x[i]-x[i-1])-(psi[i-1][j]-psi[i][j])*(x[i+1]-x[i])*(x[i+1]-x[i]))/((x[i+1]-x[i])*(x[i]-x[i-1])*(x[i+1]-x[i-1]));
		}
	}
	/*
	// Внутренность расчётной области.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			// u=diff(psi,y);
			u[i][j]=0.5*(psi[i+1][j]-psi[i-1][j])/h2;
			// v=-diff(psi,x);
			v[i][j]=-0.5*(psi[i][j+1]-psi[i][j-1])/h1;
		}
	}*/

	// Граничные значения скоростей.
	if (buserdefinevelocity) {
		// Можно конечно просто нули записать и всё (первый вариант),
	    // Граничные условия для компонент скорости.
	    // Горизонтальная скорость:
	    Real ULEFT=0.0;
	    Real URIGHT=0.0;
 	    Real UTOP=0.0;
	    Real UBOTTOM=0.0;
 	    // Вертикальная скорость:
	    Real VLEFT=0.0;
	    Real VRIGHT=0.0;
	    Real VTOP=0.0;
	    Real VBOTTOM=0.0;
	    // Условие Дирихле.
	    for (int i=1; i<m+1; i++) {
		   u[i][0]=UBOTTOM; 
		   u[i][n+1]=UTOP;
		   v[i][0]=VBOTTOM; 
		   v[i][n+1]=VTOP;
	    }
	    // Условие Дирихле.
	    for (int j=1; j<n+1; j++) {
		   u[0][j]=ULEFT; 
		   u[m+1][j]=URIGHT;
           v[0][j]=VLEFT; 
		   v[m+1][j]=VRIGHT;
	    }
	}
	else {
		// а во втором варианте будем искат как положено через производные от функции тока.
	    // Условие Дирихле.
	    for (int i=1; i<m+1; i++) {
			
			// нижняя граница (горизонтальная скорость)
		    u[i][0]=(psi[i][1]-psi[i][0])/(y[1]-y[0]);
			// верхняя граница (горизонтальная скорость)
		    u[i][n+1]=(psi[i][n+1]-psi[i][n])/(y[n+1]-y[n]);
			// нижняя граница (вертикальная скорость)
            //v[i][0]=-0.5*(psi[i+1][0]-psi[i-1][0])/h1;
			v[i][0]=-((psi[i+1][0]-psi[i][0])*(x[i]-x[i-1])*(x[i]-x[i-1])-(psi[i-1][0]-psi[i][0])*(x[i+1]-x[i])*(x[i+1]-x[i]))/((x[i+1]-x[i])*(x[i]-x[i-1])*(x[i+1]-x[i-1]));
			// верхняя граница (вертикальная скорость)
		    //v[i][n+1]=-0.5*(psi[i+1][n+1]-psi[i-1][n+1])/h1;
			v[i][n+1]=-((psi[i+1][n+1]-psi[i][n+1])*(x[i]-x[i-1])*(x[i]-x[i-1])-(psi[i-1][n+1]-psi[i][n+1])*(x[i+1]-x[i])*(x[i+1]-x[i]))/((x[i+1]-x[i])*(x[i]-x[i-1])*(x[i+1]-x[i-1]));
			/*
			// левая граница (горизонтальная скорость)
		    u[i][0]=0.5*(psi[i+1][0]-psi[i-1][0])/h2;
			// правая граница (горизонтальная скорость)
		    u[i][n+1]=0.5*(psi[i+1][n+1]-psi[i-1][n+1])/h2;
			// левая граница (вертикальная скорость)
            v[i][0]=-(psi[i][1]-psi[i][0])/h1;
			// правая граница (вертикальная скорость)
		    v[i][n+1]=-(psi[i][n+1]-psi[i][n])/h1;*/
	    }
	    // Условие Дирихле.
	    for (int j=1; j<n+1; j++) {
			
			// горизонтальная скорость (левая граница)
		    //u[0][j]=0.5*(psi[0][j+1]-psi[0][j-1])/h2;
			u[0][j]=((psi[0][j+1]-psi[0][j])*(y[j]-y[j-1])*(y[j]-y[j-1])-(psi[0][j-1]-psi[0][j])*(y[j+1]-y[j])*(y[j+1]-y[j]))/((y[j+1]-y[j])*(y[j]-y[j-1])*(y[j+1]-y[j-1]));
			// горизонтальная скорость (правая граница)
		    //u[m+1][j]=0.5*(psi[m+1][j+1]-psi[m+1][j-1])/h2;
			u[m+1][j]=((psi[m+1][j+1]-psi[m+1][j])*(y[j]-y[j-1])*(y[j]-y[j-1])-(psi[m+1][j-1]-psi[m+1][j])*(y[j+1]-y[j])*(y[j+1]-y[j]))/((y[j+1]-y[j])*(y[j]-y[j-1])*(y[j+1]-y[j-1]));
			// вертикальная скорость (левая граница)
			//v[0][j]=-(psi[1][j]-psi[0][j])/(x[1]-x[0]);
			// Вместо двухточечной формулы первого порядка мы используем трёхточечную формулу второго порядка и находим скорость
			// со вторым порядком в узле отстоящим на один узел от грангуцы. Скорость же в граничном узле определяется снесением значения
			// из вычисленного узла второго от границы в граничный узел. По видимому это будет более правильно чем двухточечная формула.
			v[0][j]=-((psi[2][j]-psi[1][j])*(x[1]-x[0])*(x[1]-x[0])-(psi[0][j]-psi[1][j])*(x[2]-x[1])*(x[2]-x[1]))/((x[2]-x[1])*(x[1]-x[0])*(x[2]-x[0]));
			// вертикальная скорость (правая граница)
		    //v[m+1][j]=-(psi[m+1][j]-psi[m][j])/(x[m+1]-x[m]);
			v[m+1][j]=-((psi[m+1][j]-psi[m][j])*(x[m]-x[m-1])*(x[m]-x[m-1])-(psi[m-1][j]-psi[m][j])*(x[m+1]-x[m])*(x[m+1]-x[m]))/((x[m+1]-x[m])*(x[m]-x[m-1])*(x[m+1]-x[m-1]));
			/*
			// горизонтальная скорость (нижняя граница)
		    u[0][j]=(psi[1][j]-psi[0][j])/h2;
			// горизонтальная скорость (верхняя граница)
		    u[m+1][j]=(psi[m+1][j]-psi[m][j])/h2;
			// вертикальная скорость (нижняя граница)
			v[0][j]=-0.5*(psi[0][j+1]-psi[0][j-1])/h1;
			// вертикальная скорость (верхняя граница)
		    v[m+1][j]=-0.5*(psi[m+1][j+1]-psi[m+1][j-1])/h1;*/
	    }
	}

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	u[0][0]=0.5*(u[0][1]+u[1][0]);
	u[m+1][0]=0.5*(u[m][0]+u[m+1][1]);
	u[0][n+1]=0.5*(u[1][n+1]+u[0][n]);
	u[m+1][n+1]=0.5*(u[m][n+1]+u[m+1][n]);
	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	v[0][0]=0.5*(v[0][1]+v[1][0]);
	v[m+1][0]=0.5*(v[m][0]+v[m+1][1]);
	v[0][n+1]=0.5*(v[1][n+1]+v[0][n]);
	v[m+1][n+1]=0.5*(v[m][n+1]+v[m+1][n]);

} // calcvelocity1

// Экономично находит компоненты скорости по рассчитанному потенциалу.
// пригодно для неравномерной сетки.
// psi - потенциал !!!
void calcvelocityMESFET(Real** psi, Real** &u, Real** &v, 
	               Real* x, Real* y, int m, int n) {


   // Верно.
	// Внутренность расчётной области.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			// u=diff(psi,x);
			//u[i][j]=0.5*(psi[i+1][j]-psi[i-1][j])/h1
			// см. Г.З. Гарбер стр 210.
			u[i][j]=((psi[i+1][j]-psi[i][j])*(x[i]-x[i-1])*(x[i]-x[i-1])-(psi[i-1][j]-psi[i][j])*(x[i+1]-x[i])*(x[i+1]-x[i]))/((x[i+1]-x[i])*(x[i]-x[i-1])*(x[i+1]-x[i-1]));
			// v=diff(psi,y);
			//v[i][j]=0.5*(psi[i][j+1]-psi[i][j-1])/h2;;
			v[i][j]=((psi[i][j+1]-psi[i][j])*(y[j]-y[j-1])*(y[j]-y[j-1])-(psi[i][j-1]-psi[i][j])*(y[j+1]-y[j])*(y[j+1]-y[j]))/((y[j+1]-y[j])*(y[j]-y[j-1])*(y[j+1]-y[j-1]));
		}
	}
	/*
	// Внутренность расчётной области.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			// u=diff(psi,x);
			u[i][j]=0.5*(psi[i+1][j]-psi[i-1][j])/h1;
			// v=-diff(psi,y);
			v[i][j]=0.5*(psi[i][j+1]-psi[i][j-1])/h2;
		}
	}*/

	// Граничные значения скоростей.
		// а во втором варианте будем искать как положено через производные от потенциала.
	    // Условие Дирихле.
	    for (int i=1; i<m+1; i++) {
			// нижняя граница (горизонтальная скорость)
		    u[i][0]=((psi[i+1][0]-psi[i][0])*(x[i]-x[i-1])*(x[i]-x[i-1])-(psi[i-1][0]-psi[i][0])*(x[i+1]-x[i])*(x[i+1]-x[i]))/((x[i+1]-x[i])*(x[i]-x[i-1])*(x[i+1]-x[i-1]));	
			// верхняя граница (горизонтальная скорость)
		    u[i][n+1]=((psi[i+1][n+1]-psi[i][n+1])*(x[i]-x[i-1])*(x[i]-x[i-1])-(psi[i-1][n+1]-psi[i][n+1])*(x[i+1]-x[i])*(x[i+1]-x[i]))/((x[i+1]-x[i])*(x[i]-x[i-1])*(x[i+1]-x[i-1]));	
			// нижняя граница (вертикальная скорость)
			v[i][0]=(psi[i][1]-psi[i][0])/(y[1]-y[0]);
			// верхняя граница (вертикальная скорость)
			v[i][n+1]=(psi[i][n+1]-psi[i][n])/(y[n+1]-y[n]);
	    }
	    // Условие Дирихле.
	    for (int j=1; j<n+1; j++) {
			
			// горизонтальная скорость (левая граница)
			//u[0][j]=((psi[2][j]-psi[1][j])*(x[1]-x[0])*(x[1]-x[0])-(psi[0][j]-psi[1][j])*(x[2]-x[1])*(x[2]-x[1]))/((x[2]-x[1])*(x[1]-x[0])*(x[2]-x[0]));
			u[0][j]=(psi[1][j]-psi[0][j])/(x[1]-x[0]);
			// горизонтальная скорость (правая граница)
			//u[m+1][j]=((psi[m+1][j]-psi[m][j])*(x[m]-x[m-1])*(x[m]-x[m-1])-(psi[m-1][j]-psi[m][j])*(x[m+1]-x[m])*(x[m+1]-x[m]))/((x[m+1]-x[m])*(x[m]-x[m-1])*(x[m+1]-x[m-1]));
			u[m+1][j]=(psi[m+1][j]-psi[m][j])/(x[m+1]-x[m]);
				
			// вертикальная скорость (левая граница)
			// Вместо двухточечной формулы первого порядка мы используем трёхточечную формулу второго порядка и находим скорость
			// со вторым порядком в узле отстоящим на один узел от грангуцы. Скорость же в граничном узле определяется снесением значения
			// из вычисленного узла второго от границы в граничный узел. По видимому это будет более правильно чем двухточечная формула.
			v[0][j]=((psi[0][j+1]-psi[0][j])*(y[j]-y[j-1])*(y[j]-y[j-1])-(psi[0][j-1]-psi[0][j])*(y[j+1]-y[j])*(y[j+1]-y[j]))/((y[j+1]-y[j])*(y[j]-y[j-1])*(y[j+1]-y[j-1]));
			// вертикальная скорость (правая граница)
			v[m+1][j]=((psi[m+1][j+1]-psi[m+1][j])*(y[j]-y[j-1])*(y[j]-y[j-1])-(psi[m+1][j-1]-psi[m+1][j])*(y[j+1]-y[j])*(y[j+1]-y[j]))/((y[j+1]-y[j])*(y[j]-y[j-1])*(y[j+1]-y[j-1]));
	    }
	

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	u[0][0]=(psi[1][0]-psi[0][0])/(x[1]-x[0]);
	u[m+1][0]=(psi[m+1][0]-psi[m][0])/(x[m+1]-x[m]);
	u[0][n+1]=(psi[1][n+1]-psi[0][n+1])/(x[1]-x[0]);
	u[m+1][n+1]=(psi[m+1][n+1]-psi[m][n+1])/(x[m+1]-x[m]);
	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	v[0][0]=(psi[0][1]-psi[0][0])/(y[1]-y[0]);
	v[m+1][0]=(psi[m+1][1]-psi[m+1][0])/(y[1]-y[0]);
	v[0][n+1]=(psi[0][n+1]-psi[0][n])/(y[n+1]-y[n]);
	v[m+1][n+1]=(psi[m+1][n+1]-psi[m+1][n])/(y[n+1]-y[n]);

} // calcvelocityMESFET



// Экономично находит компоненты скорости по рассчитанному потенциалу.
// пригодно для неравномерной сетки.
// psi - потенциал !!!
void calcvelocityMESFET1(Real** psi, Real** &u, Real** &v, 
	               Real* x, Real* y, int m, int n) {


	// Внутренность расчётной области.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			// u=diff(psi,x);
			u[i][j]=(psi[i+1][j]-psi[i-1][j])/(x[i+1]-x[i-1]);
			// см. Г.З. Гарбер стр 210.
			//u[i][j]=((psi[i+1][j]-psi[i][j])*(x[i]-x[i-1])*(x[i]-x[i-1])-(psi[i-1][j]-psi[i][j])*(x[i+1]-x[i])*(x[i+1]-x[i]))/((x[i+1]-x[i])*(x[i]-x[i-1])*(x[i+1]-x[i-1]));
			// v=diff(psi,y);
			v[i][j]=(psi[i][j+1]-psi[i][j-1])/(y[j+1]-y[j-1]);
			//v[i][j]=((psi[i][j+1]-psi[i][j])*(y[j]-y[j-1])*(y[j]-y[j-1])-(psi[i][j-1]-psi[i][j])*(y[j+1]-y[j])*(y[j+1]-y[j]))/((y[j+1]-y[j])*(y[j]-y[j-1])*(y[j+1]-y[j-1]));
		}
	}
	/*
	// Внутренность расчётной области.
	for (int i=1; i<m+1; i++) {
	   	for (int j=1; j<n+1; j++) {
			// u=diff(psi,x);
			u[i][j]=0.5*(psi[i+1][j]-psi[i-1][j])/h1;
			// v=-diff(psi,y);
			v[i][j]=0.5*(psi[i][j+1]-psi[i][j-1])/h2;
		}
	}*/

	// Граничные значения скоростей.
		// а во втором варианте будем искать как положено через производные от потенциала.
	    // Условие Дирихле.
	    for (int i=1; i<m+1; i++) {
			// нижняя граница (горизонтальная скорость)
		    //u[i][0]=((psi[i+1][0]-psi[i][0])*(x[i]-x[i-1])*(x[i]-x[i-1])-(psi[i-1][0]-psi[i][0])*(x[i+1]-x[i])*(x[i+1]-x[i]))/((x[i+1]-x[i])*(x[i]-x[i-1])*(x[i+1]-x[i-1]));	
			u[i][0]=(psi[i+1][0]-psi[i-1][0])/(x[i+1]-x[i-1]);
			// верхняя граница (горизонтальная скорость)
		    //u[i][n+1]=((psi[i+1][n+1]-psi[i][n+1])*(x[i]-x[i-1])*(x[i]-x[i-1])-(psi[i-1][n+1]-psi[i][n+1])*(x[i+1]-x[i])*(x[i+1]-x[i]))/((x[i+1]-x[i])*(x[i]-x[i-1])*(x[i+1]-x[i-1]));	
			u[i][n+1]=(psi[i+1][n+1]-psi[i-1][n+1])/(x[i+1]-x[i-1]);
			// нижняя граница (вертикальная скорость)
			v[i][0]=(psi[i][1]-psi[i][0])/(y[1]-y[0]);
			// верхняя граница (вертикальная скорость)
			v[i][n+1]=(psi[i][n+1]-psi[i][n])/(y[n+1]-y[n]);
	    }
	    // Условие Дирихле.
	    for (int j=1; j<n+1; j++) {
			
			// горизонтальная скорость (левая граница)
			//u[0][j]=((psi[2][j]-psi[1][j])*(x[1]-x[0])*(x[1]-x[0])-(psi[0][j]-psi[1][j])*(x[2]-x[1])*(x[2]-x[1]))/((x[2]-x[1])*(x[1]-x[0])*(x[2]-x[0]));
			u[0][j]=(psi[1][j]-psi[0][j])/(x[1]-x[0]);
			// горизонтальная скорость (правая граница)
			//u[m+1][j]=((psi[m+1][j]-psi[m][j])*(x[m]-x[m-1])*(x[m]-x[m-1])-(psi[m-1][j]-psi[m][j])*(x[m+1]-x[m])*(x[m+1]-x[m]))/((x[m+1]-x[m])*(x[m]-x[m-1])*(x[m+1]-x[m-1]));
			u[m+1][j]=(psi[m+1][j]-psi[m][j])/(x[m+1]-x[m]);
				
			// вертикальная скорость (левая граница)
			// Вместо двухточечной формулы первого порядка мы используем трёхточечную формулу второго порядка и находим скорость
			// со вторым порядком в узле отстоящим на один узел от грангуцы. Скорость же в граничном узле определяется снесением значения
			// из вычисленного узла второго от границы в граничный узел. По видимому это будет более правильно чем двухточечная формула.
			//v[0][j]=((psi[0][j+1]-psi[0][j])*(y[j]-y[j-1])*(y[j]-y[j-1])-(psi[0][j-1]-psi[0][j])*(y[j+1]-y[j])*(y[j+1]-y[j]))/((y[j+1]-y[j])*(y[j]-y[j-1])*(y[j+1]-y[j-1]));
			v[0][j]=(psi[0][j+1]-psi[0][j-1])/(y[j+1]-y[j-1]);
			// вертикальная скорость (правая граница)
			//v[m+1][j]=((psi[m+1][j+1]-psi[m+1][j])*(y[j]-y[j-1])*(y[j]-y[j-1])-(psi[m+1][j-1]-psi[m+1][j])*(y[j+1]-y[j])*(y[j+1]-y[j]))/((y[j+1]-y[j])*(y[j]-y[j-1])*(y[j+1]-y[j-1]));
            v[m+1][j]=(psi[m+1][j+1]-psi[m+1][j-1])/(y[j+1]-y[j-1]);
	    }
	

	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	u[0][0]=(psi[1][0]-psi[0][0])/(x[1]-x[0]);
	u[m+1][0]=(psi[m+1][0]-psi[m][0])/(x[m+1]-x[m]);
	u[0][n+1]=(psi[1][n+1]-psi[0][n+1])/(x[1]-x[0]);
	u[m+1][n+1]=(psi[m+1][n+1]-psi[m][n+1])/(x[m+1]-x[m]);
	// Угловые точки, которые не рассчитываются но визуализируются.
	// среднее арефметическое
	v[0][0]=(psi[0][1]-psi[0][0])/(y[1]-y[0]);
	v[m+1][0]=(psi[m+1][1]-psi[m+1][0])/(y[1]-y[0]);
	v[0][n+1]=(psi[0][n+1]-psi[0][n])/(y[n+1]-y[n]);
	v[m+1][n+1]=(psi[m+1][n+1]-psi[m+1][n])/(y[n+1]-y[n]);

} // calcvelocityMESFET


// вычисление производной по оси х от полевой величины u.
// данная реализация подходит для неравномерной сетки.
// Вблизи границы порядок аппроксимации падает до первого.
void calc_gradx(Real** &gradxu, Real** u, 
	            Real* x, Real* y, int m, int n) {
	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(m+1));

	 // Внутренность расчётной области.
	for (int i=1; i<m+1; i++) {
	   	for (int j=0; j<n+2; j++) {
			// gradxu=diff(u,x);
			//gradxu[i][j]=0.5*(u[i+1][j]-u[i-1][j])/h1;
			gradxu[i][j]=((u[i+1][j]-u[i][j])*(x[i]-x[i-1])*(x[i]-x[i-1])-(u[i-1][j]-u[i][j])*(x[i+1]-x[i])*(x[i+1]-x[i]))/((x[i+1]-x[i])*(x[i]-x[i-1])*(x[i+1]-x[i-1]));
		}
	}

    for (int j=0; j<n+2; j++) {
		// gradxu=diff(u,x);
		//gradxu[0][j]=(u[1][j]-u[0][j])/h1;
		gradxu[0][j]=(u[1][j]-u[0][j])/(x[1]-x[0]);
		//gradxu[m+1][j]=(u[m+1][j]-u[m][j])/h1;
		gradxu[m+1][j]=(u[m+1][j]-u[m][j])/(x[m+1]-x[m]);
	}

} // calc_gradx

// вычисление производной по оси y от полевой величины u.
void calc_grady(Real** &gradyu, Real** u, 
	            Real *x, Real* y, int m, int n) {
	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	// Real h2=(Real)(lengthy/(n+1));

	 // Внутренность расчётной области.
	for (int i=1; i<m+2; i++) {
	   	for (int j=0; j<n+1; j++) {
			// gradyu=diff(u,y);
			//gradyu[i][j]=0.5*(u[i][j+1]-u[i][j-1])/h2;
			gradyu[i][j]=((u[i][j+1]-u[i][j])*(y[j]-y[j-1])*(y[j]-y[j-1])-(u[i][j-1]-u[i][j])*(y[j+1]-y[j])*(y[j+1]-y[j]))/((y[j+1]-y[j])*(y[j]-y[j-1])*(y[j+1]-y[j-1]));
		}
	}

    for (int i=0; i<m+2; i++) {
		// gradyu=diff(u,y);
		gradyu[i][0]=(u[i][1]-u[i][0])/(y[1]-y[0]);
		//gradyu[i][n+1]=(u[i][n+1]-u[i][n])/h2;
		gradyu[i][n+1]=(u[i][n+1]-u[i][n])/(y[n+1]-y[n]);
	}

} // calc_grady

// Вичислим теплопроводность по формуле из книги Рюдегера Квея.
void calcconductivity(Real** &u, Real** &lambda, int m, int n) {
	// u - температура в Кельвинах.
	Real  K300=120.0; // теплопроводность при температуре 300К.
	Real power=-1.85; // показатель степени в формуле.

	for (int i=0; i<m+2; i++) {
	   	for (int j=0; j<n+2; j++) {
			lambda[i][j]=K300*exp(power*(log(u[i][j]/300.0)));
		}
	}

} // calcconductivity

// Граничные условия для электрического потенциала.
// Исток, Затвор и Сток расположены горизонтально на верхней границе.
// Не должно быть никакой привязки к целочисленным индексам, так как мы используем 
// многосеточный метод Федоренко.
// Передаваемые параметры :
// xendsource - вещественная позиция конца истока, начало истока при x==0.
// xstartgate, xendgate - вещественные позиции начала и конца затвора,
// xstartdrain - вещественная позиция начала стока.
// ug, ud - потенциалы на затворе и стоке.
void load_my_bound_potencial_MESFET(TBONCONDOMAIN &my_bound, 
									Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain,
									Real ug, Real ud,
	                    Real* x, Real* y, int m, int n) {

		for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           my_bound.bottom[i].FI_inf=0.0;
		   my_bound.bottom[i].gamma=1.0;
		   my_bound.bottom[i].kappa=0.0;
		   my_bound.bottom[i].qset=0.0;
		   my_bound.bottom[i].ap=-1.0;
		   my_bound.bottom[i].ai=-1.0;
		   // верхняя граница
		   // однородные условия Неймана.
		   if (x[i]<xendsource) {
			   my_bound.top[i].FI_inf=0.0; // source
		       my_bound.top[i].gamma=0.0;
		       my_bound.top[i].kappa=1.0;
		       my_bound.top[i].qset=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   my_bound.top[i].FI_inf=ug; // gate
		       my_bound.top[i].gamma=0.0;
		       my_bound.top[i].kappa=1.0;
		       my_bound.top[i].qset=0.0;
		   }
		   else if (x[i]>xstartdrain) {
               my_bound.top[i].FI_inf=ud; // drain
		       my_bound.top[i].gamma=0.0;
		       my_bound.top[i].kappa=1.0;
		       my_bound.top[i].qset=0.0;
		   }
		   else
		   {
		      my_bound.top[i].FI_inf=0.0;
		      my_bound.top[i].gamma=1.0;
		      my_bound.top[i].kappa=0.0;
		      my_bound.top[i].qset=0.0;
		   }
		   my_bound.top[i].ap=-1.0;
		   my_bound.top[i].ai=-1.0;
        }
	for (int i=1; i<n+1; i++) {
	   // левая граница
	   my_bound.left[i].FI_inf=0.0;
	   my_bound.left[i].gamma=1.0;
	   my_bound.left[i].kappa=0.0;
	   my_bound.left[i].qset=0.0;
	   my_bound.left[i].ap=-1.0;
	   my_bound.left[i].ai=-1.0;
	   // правая граница
	   my_bound.right[i].FI_inf=0.0;
	   my_bound.right[i].gamma=1.0;
	   my_bound.right[i].kappa=0.0;
	   my_bound.right[i].qset=0.0;
	   my_bound.right[i].ap=-1.0;
	   my_bound.right[i].ai=-1.0;
	}
}

/*
// Загружает граничные условия для концентрации электронов
void load_my_bound_n(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel, Real** y_vel, Real Nd, Real* x, Real* y, Real Dn, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           my_bound.bottom[i].FI_inf=0.0;
		   my_bound.bottom[i].gamma=1.0;
		   my_bound.bottom[i].kappa=0.0;
		   my_bound.bottom[i].qset=0.0;
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dn/(y[1]-y[0])+maxf(0.0,y_vel[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dn/(y[1]-y[0])+maxf(0.0,-y_vel[i][0]));
		   // верхняя граница
		   // однородные условия Неймана.
		   if (x[i]<xendsource) {
			   my_bound.top[i].FI_inf=Nd; // source
		       my_bound.top[i].gamma=0.0;
		       my_bound.top[i].kappa=1.0;
		       my_bound.top[i].qset=0.0;
			   my_bound.top[i].ap=-1.0;
			   my_bound.top[i].ai=-1.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   my_bound.top[i].FI_inf=0.0; // gate
		       my_bound.top[i].gamma=1.0;
		       my_bound.top[i].kappa=0.0;
		       my_bound.top[i].qset=0.0;
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dn/(y[n+1]-y[n])+maxf(0.0,-y_vel[i][n+1]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dn/(y[n+1]-y[n])+maxf(0.0,y_vel[i][n+1]));
		   }
		   else if (x[i]>xstartdrain) {
               my_bound.top[i].FI_inf=Nd; // drain
		       my_bound.top[i].gamma=0.0;
		       my_bound.top[i].kappa=1.0;
		       my_bound.top[i].qset=0.0;
			   my_bound.top[i].ap=-1.0;
			   my_bound.top[i].ai=-1.0;
		   }
		   else
		   {
		      my_bound.top[i].FI_inf=0.0;
		      my_bound.top[i].gamma=1.0;
		      my_bound.top[i].kappa=0.0;
		      my_bound.top[i].qset=0.0;
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dn/(y[n+1]-y[n])+maxf(0.0,-y_vel[i][n+1]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dn/(y[n+1]-y[n])+maxf(0.0,y_vel[i][n+1]));
		   }
        }
	for (int i=1; i<n+1; i++) {
	   // левая граница
	   my_bound.left[i].FI_inf=0.0;
	   my_bound.left[i].gamma=1.0;
	   my_bound.left[i].kappa=0.0;
	   my_bound.left[i].qset=0.0;
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dn/(x[1]-x[0])+maxf(0.0,x_vel[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dn/(x[1]-x[0])+maxf(0.0,-x_vel[0][i]));
	   // правая граница
	   my_bound.right[i].FI_inf=0.0;
	   my_bound.right[i].gamma=1.0;
	   my_bound.right[i].kappa=0.0;
	   my_bound.right[i].qset=0.0;
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dn/(x[m+1]-x[m])+maxf(0.0,-x_vel[m+1][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dn/(x[m+1]-x[m])+maxf(0.0,x_vel[m+1][i]));
	}
 

} // load_my_bound_n
*/

// Загружает граничные условия для концентрации электронов
void load_my_bound_n(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel, Real** y_vel, Real Nd, Real* x, Real* y, Real Dn, Real** &rthdsd, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dn/(y[1]-y[0])+maxf(0.0,y_vel[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dn/(y[1]-y[0])+maxf(0.0,-y_vel[i][0]));
		   // верхняя граница
		   // однородные условия Неймана.
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
               rthdsd[i][N+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][N+1]=0.0;
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dn/(y[n+1]-y[n])+maxf(0.0,-y_vel[i][n+1]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dn/(y[n+1]-y[n])+maxf(0.0,y_vel[i][n+1]));
		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][N+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][N+1]=0.0;
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dn/(y[n+1]-y[n])+maxf(0.0,-y_vel[i][n+1]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dn/(y[n+1]-y[n])+maxf(0.0,y_vel[i][n+1]));
		   }
        }
	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dn/(x[1]-x[0])+maxf(0.0,x_vel[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dn/(x[1]-x[0])+maxf(0.0,-x_vel[0][i]));
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[M+1][i]=0.0;
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dn/(x[m+1]-x[m])+maxf(0.0,-x_vel[m+1][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dn/(x[m+1]-x[m])+maxf(0.0,x_vel[m+1][i]));
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[M+1][0]=0.0;
	rthdsd[0][N+1]=0.0;
	rthdsd[M+1][N+1]=0.0;

} // load_my_bound_n


// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
void load_my_bound_n2(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real Nd, Real* x, Real* y, Real Dn, Real** &rthdsd, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		    Real Dnc=maxf(Dn,(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,y_vel_f[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,-y_vel_f[i][0]));
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
               rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   Real Dnc=maxf(Dn,(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
			   if (fabs(Dnc-Dn)>1.0e-7) {
				   printf("izmenenie Dn\n");
			   }
		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			   Real Dnc=maxf(Dn,(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   Real Dnc=maxf(Dn,(x[1]-x[0])*fabs(x_vel_f[0][i]));
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,x_vel_f[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,-x_vel_f[0][i]));
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	    Dnc=maxf(Dn,(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,-x_vel_f[m][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,x_vel_f[m][i]));
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_n2

// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
void load_my_bound_n4(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real Nd, Real* x, Real* y, Real Dn, Real** &rthdsd, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		    Real Dnc=2.0*maxf(Dn,(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,y_vel_f[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,-y_vel_f[i][0]));
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
               rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   Real Dnc=2.0*maxf(Dn,(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
			   if (fabs(Dnc-2.0*Dn)>1.0e-7) {
				   printf("izmenenie Dn\n");
			   }
		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			   Real Dnc=2.0*maxf(Dn,(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   Real Dnc=2.0*maxf(Dn,(x[1]-x[0])*fabs(x_vel_f[0][i]));
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,x_vel_f[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,-x_vel_f[0][i]));
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	    Dnc=2.0*maxf(Dn,(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,-x_vel_f[m][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,x_vel_f[m][i]));
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_n4

// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
void load_my_bound_n3(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real Nd, Real* x, Real* y, Real** Dn, Real** &rthdsd, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		    Real Dnc=2.0*maxf(2.0*Dn[i][0]*Dn[i][1]/(Dn[i][0]+Dn[i][1]),(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,y_vel_f[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,-y_vel_f[i][0]));
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
               rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   Real Dnc=2.0*maxf(2.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
			   /*
			   if (fabs(Dnc-4.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]))>1.0e-7) {
				   printf("izmenenie Dn\n");
				   getchar();
			   }
			   */
			   

		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			  Real Dnc=2.0*maxf(2.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   Real Dnc=2.0*maxf(2.0*Dn[0][i]*Dn[1][i]/(Dn[0][i]+Dn[1][i]),(x[1]-x[0])*fabs(x_vel_f[0][i]));
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,x_vel_f[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,-x_vel_f[0][i]));
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	   Dnc=2.0*maxf(2.0*Dn[m][i]*Dn[m+1][i]/(Dn[m][i]+Dn[m+1][i]),(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,-x_vel_f[m][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,x_vel_f[m][i]));
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_n3


// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
void load_my_bound_n7(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real Nd, Real* x, Real* y, Real** Dn, Real** &rthdsd, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		  //  Real Dnc=2.0*maxf(2.0*Dn[i][0]*Dn[i][1]/(Dn[i][0]+Dn[i][1]),(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   Real Dnc=2.0*Dn[i][0]*Dn[i][1]/(Dn[i][0]+Dn[i][1]);
		   //Dnc*=2.0;
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,y_vel_f[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,-y_vel_f[i][0]));
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
               rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   //Real Dnc=2.0*maxf(2.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
			   Real Dnc=2.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]);
			   //Dnc*=2.0;
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
			   /*
			   if (fabs(Dnc-4.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]))>1.0e-7) {
				   printf("izmenenie Dn\n");
				   getchar();
			   }
			   */
			   

		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			 // Real Dnc=2.0*maxf(2.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
			  Real Dnc=2.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]);
			  //Dnc*=2.0;
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   //Real Dnc=2.0*maxf(2.0*Dn[0][i]*Dn[1][i]/(Dn[0][i]+Dn[1][i]),(x[1]-x[0])*fabs(x_vel_f[0][i]));
	   Real Dnc=2.0*Dn[0][i]*Dn[1][i]/(Dn[0][i]+Dn[1][i]);
	   //Dnc*=2.0;
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,x_vel_f[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,-x_vel_f[0][i]));
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	   //Dnc=2.0*maxf(2.0*Dn[m][i]*Dn[m+1][i]/(Dn[m][i]+Dn[m+1][i]),(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   Dnc=2.0*Dn[m][i]*Dn[m+1][i]/(Dn[m][i]+Dn[m+1][i]);
	   //Dnc*=2.0;
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,-x_vel_f[m][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,x_vel_f[m][i]));
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_n7

// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
void load_my_bound_n5(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real Nd, Real* x, Real* y, Real** Dn, Real** &rthdsd, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		    Real Dnc=2.0*maxf(2.0*Dn[i][0]*Dn[i][1]/(Dn[i][0]+Dn[i][1]),(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+y_vel_f[i][0]);
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])-y_vel_f[i][0]);
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
               rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   Real Dnc=2.0*maxf(2.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])-y_vel_f[i][n]);
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+y_vel_f[i][n]);
			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
			   /*
			   if (fabs(Dnc-4.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]))>1.0e-7) {
				   printf("izmenenie Dn\n");
				   getchar();
			   }
			   */
			   

		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			  Real Dnc=2.0*maxf(2.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])-y_vel_f[i][n]);
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+y_vel_f[i][n]);
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   Real Dnc=2.0*maxf(2.0*Dn[0][i]*Dn[1][i]/(Dn[0][i]+Dn[1][i]),(x[1]-x[0])*fabs(x_vel_f[0][i]));
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+x_vel_f[0][i]);
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])-x_vel_f[0][i]);
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	   Dnc=2.0*maxf(2.0*Dn[m][i]*Dn[m+1][i]/(Dn[m][i]+Dn[m+1][i]),(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])-x_vel_f[m][i]);
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+x_vel_f[m][i]);
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_n5

// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
// Внимание нижняя релаксация для тока равного нулю уже сделана 
// внутри метода startMESFETSiPARIS2.
void load_my_bound_n6(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real Nd, Real* x, Real* y, Real** Dn, Real** &rthdsd, Real alpha, 
					 Real** neg, int m, int n) 
{

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		    Real Dnc=2.0*maxf(2.0*Dn[i][0]*Dn[i][1]/(Dn[i][0]+Dn[i][1]),(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,y_vel_f[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,-y_vel_f[i][0]));
		   my_bound.bottom[i].ap/=alpha;
		   rthdsd[i][0]+=my_bound.bottom[i].ap*(1.0-alpha)*neg[i][0];
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
               rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   Real Dnc=2.0*maxf(2.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			    my_bound.top[i].ap/=alpha;
		   rthdsd[i][n+1]+=my_bound.top[i].ap*(1.0-alpha)*neg[i][n+1];
			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
			   /*
			   if (fabs(Dnc-4.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]))>1.0e-7) {
				   printf("izmenenie Dn\n");
				   getchar();
			   }
			   */
			   

		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=Nd;
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			  Real Dnc=2.0*maxf(2.0*Dn[i][n+1]*Dn[i][n]/(Dn[i][n+1]+Dn[i][n]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			   my_bound.top[i].ap/=alpha;
		   rthdsd[i][n+1]+=my_bound.top[i].ap*(1.0-alpha)*neg[i][n+1];
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   Real Dnc=2.0*maxf(2.0*Dn[0][i]*Dn[1][i]/(Dn[0][i]+Dn[1][i]),(x[1]-x[0])*fabs(x_vel_f[0][i]));
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,x_vel_f[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,-x_vel_f[0][i]));
	   my_bound.left[i].ap/=alpha;
	   rthdsd[0][i]+=my_bound.left[i].ap*(1.0-alpha)*neg[0][i];
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	   Dnc=2.0*maxf(2.0*Dn[m][i]*Dn[m+1][i]/(Dn[m][i]+Dn[m+1][i]),(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,-x_vel_f[m][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,x_vel_f[m][i]));
	   my_bound.right[i].ap/=alpha;
	   rthdsd[m+1][i]+=my_bound.right[i].ap*(1.0-alpha)*neg[m+1][i];
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_n6

// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
void load_my_bound_nu2(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real Nd, Real elementary_q, Real taue, Real** emag, Real** x_vel_face_sn, Real** y_vel_face_we, Real energy_source, Real* x, Real* y, Real Dn, Real** &rthdsd, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		   Real Dnc=maxf(Dn,(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,y_vel_f[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,-y_vel_f[i][0]));
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
			   // u0
			   // Нулевое граничное условие для nu соответствует энергии кристаллической решетки для энергии.
               rthdsd[i][n+1]=0.0; // energy_source; // энергия на истоке равна энергии решетки.
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   Real Dnc=maxf(Dn,(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   // граничное условие для энергии :
			   // u0+taue*elementary_q*emag*drift_vel_mag;
			   //rthdsd[i][n+1]=energy_source+taue*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   // условие для nu
			   // Здесь использована величина neg[i][n+1]==Nd это концентрация электронов на стоке.
               //rthdsd[i][n+1]=neg[i][n+1]*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   rthdsd[i][n+1]=taue*Nd*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			  Real Dnc=maxf(Dn,(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   Real Dnc=maxf(Dn,(x[1]-x[0])*fabs(x_vel_f[0][i]));
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,x_vel_f[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,-x_vel_f[0][i]));
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	    Dnc=maxf(Dn,(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,-x_vel_f[m][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,x_vel_f[m][i]));
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_nu2

// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
void load_my_bound_nu3(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real Nd, Real elementary_q, Real taue, Real** emag, Real** x_vel_face_sn, Real** y_vel_face_we, Real energy_source, Real* x, Real* y, Real** Dn, Real** &rthdsd, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		   Real Dnc=2.0*maxf(2.0*Dn[i][0]*Dn[i][1]/(Dn[i][0]+Dn[i][1]),(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,y_vel_f[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,-y_vel_f[i][0]));
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
			   // u0
			   // Нулевое граничное условие для nu соответствует энергии кристаллической решетки для энергии.
               rthdsd[i][n+1]=0.0; // energy_source; // энергия на истоке равна энергии решетки.
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   Real Dnc=2.0*maxf(2.0*Dn[i][n]*Dn[i][n+1]/(Dn[i][n]+Dn[i][n+1]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   // граничное условие для энергии :
			   // u0+taue*elementary_q*emag*drift_vel_mag;
			   //rthdsd[i][n+1]=energy_source+taue*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   // условие для nu
			   // Здесь использована величина neg[i][n+1]==Nd это концентрация электронов на стоке.
               //rthdsd[i][n+1]=neg[i][n+1]*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   rthdsd[i][n+1]=taue*Nd*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			  Real Dnc=2.0*maxf(2.0*Dn[i][n]*Dn[i][n+1]/(Dn[i][n]+Dn[i][n+1]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   Real Dnc=2.0*maxf(2.0*Dn[1][i]*Dn[0][i]/(Dn[1][i]+Dn[0][i]),(x[1]-x[0])*fabs(x_vel_f[0][i]));
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,x_vel_f[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,-x_vel_f[0][i]));
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	    Dnc=2.0*maxf(2.0*Dn[m+1][i]*Dn[m][i]/(Dn[m+1][i]+Dn[m][i]),(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,-x_vel_f[m][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,x_vel_f[m][i]));
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_nu3

// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
void load_my_bound_nu7(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real Nd, Real elementary_q, Real taue, Real** emag, Real** x_vel_face_sn, Real** y_vel_face_we, Real energy_source, Real* x, Real* y, Real** Dn, Real** &rthdsd, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		   //Real Dnc=2.0*maxf(2.0*Dn[i][0]*Dn[i][1]/(Dn[i][0]+Dn[i][1]),(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   Real Dnc=2.0*Dn[i][0]*Dn[i][1]/(Dn[i][0]+Dn[i][1]);
		   //Dnc*=2.0;
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,y_vel_f[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,-y_vel_f[i][0]));
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
			   // u0
			   // Нулевое граничное условие для nu соответствует энергии кристаллической решетки для энергии.
               rthdsd[i][n+1]=0.0; // energy_source; // энергия на истоке равна энергии решетки.
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   //Real Dnc=2.0*maxf(2.0*Dn[i][n]*Dn[i][n+1]/(Dn[i][n]+Dn[i][n+1]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
               Real Dnc=2.0*Dn[i][n]*Dn[i][n+1]/(Dn[i][n]+Dn[i][n+1]);
			  // Dnc*=2.0;
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   // граничное условие для энергии :
			   // u0+taue*elementary_q*emag*drift_vel_mag;
			   //rthdsd[i][n+1]=energy_source+taue*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   // условие для nu
			   // Здесь использована величина neg[i][n+1]==Nd это концентрация электронов на стоке.
               //rthdsd[i][n+1]=neg[i][n+1]*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   rthdsd[i][n+1]=taue*Nd*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			  //Real Dnc=2.0*maxf(2.0*Dn[i][n]*Dn[i][n+1]/(Dn[i][n]+Dn[i][n+1]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
			  Real Dnc=2.0*Dn[i][n]*Dn[i][n+1]/(Dn[i][n]+Dn[i][n+1]);
			  //Dnc*=2.0;
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   //Real Dnc=2.0*maxf(2.0*Dn[1][i]*Dn[0][i]/(Dn[1][i]+Dn[0][i]),(x[1]-x[0])*fabs(x_vel_f[0][i]));
	   Real Dnc=2.0*Dn[1][i]*Dn[0][i]/(Dn[1][i]+Dn[0][i]);
	   //Dnc*=2.0;
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,x_vel_f[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,-x_vel_f[0][i]));
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	   //Dnc=2.0*maxf(2.0*Dn[m+1][i]*Dn[m][i]/(Dn[m+1][i]+Dn[m][i]),(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   Dnc=2.0*Dn[m+1][i]*Dn[m][i]/(Dn[m+1][i]+Dn[m][i]);
	   //Dnc*=2.0;
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,-x_vel_f[m][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,x_vel_f[m][i]));
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_nu7

// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
// 5 вариант без противопоточной схемы для тока на границе.
void load_my_bound_nu5(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real Nd, Real elementary_q, Real taue, Real** emag, Real** x_vel_face_sn, Real** y_vel_face_we, Real energy_source, Real* x, Real* y, Real** Dn, Real** &rthdsd, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		   Real Dnc=2.0*maxf(2.0*Dn[i][0]*Dn[i][1]/(Dn[i][0]+Dn[i][1]),(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+y_vel_f[i][0]);
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])-y_vel_f[i][0]);
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
			   // u0
			   // Нулевое граничное условие для nu соответствует энергии кристаллической решетки для энергии.
               rthdsd[i][n+1]=0.0; // energy_source; // энергия на истоке равна энергии решетки.
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   Real Dnc=2.0*maxf(2.0*Dn[i][n]*Dn[i][n+1]/(Dn[i][n]+Dn[i][n+1]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])-y_vel_f[i][n]);
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+y_vel_f[i][n]);
			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   // граничное условие для энергии :
			   // u0+taue*elementary_q*emag*drift_vel_mag;
			   //rthdsd[i][n+1]=energy_source+taue*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   // условие для nu
			   // Здесь использована величина neg[i][n+1]==Nd это концентрация электронов на стоке.
               //rthdsd[i][n+1]=neg[i][n+1]*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   rthdsd[i][n+1]=taue*Nd*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			  Real Dnc=2.0*maxf(2.0*Dn[i][n]*Dn[i][n+1]/(Dn[i][n]+Dn[i][n+1]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])-y_vel_f[i][n]);
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+y_vel_f[i][n]);
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   Real Dnc=2.0*maxf(2.0*Dn[1][i]*Dn[0][i]/(Dn[1][i]+Dn[0][i]),(x[1]-x[0])*fabs(x_vel_f[0][i]));
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+x_vel_f[0][i]);
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])-x_vel_f[0][i]);
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	   Dnc=2.0*maxf(2.0*Dn[m+1][i]*Dn[m][i]/(Dn[m+1][i]+Dn[m][i]),(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])-x_vel_f[m][i]);
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+x_vel_f[m][i]);
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_nu5

// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
// Внимание нижняя релаксация для тока равного нулю уже сделана 
// внутри метода startMESFETSiPARIS2.
void load_my_bound_nu6(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real Nd, Real elementary_q, Real taue, Real** emag, Real** x_vel_face_sn,
					 Real** y_vel_face_we, Real energy_source, Real* x, Real* y, Real** Dn, Real** &rthdsd, Real alpha, Real** nu, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		   Real Dnc=2.0*maxf(2.0*Dn[i][0]*Dn[i][1]/(Dn[i][0]+Dn[i][1]),(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,y_vel_f[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,-y_vel_f[i][0]));
my_bound.bottom[i].ap/=alpha;
		   rthdsd[i][0]+=my_bound.bottom[i].ap*(1.0-alpha)*nu[i][0];
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
			   // u0
			   // Нулевое граничное условие для nu соответствует энергии кристаллической решетки для энергии.
               rthdsd[i][n+1]=0.0; // energy_source; // энергия на истоке равна энергии решетки.
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   Real Dnc=2.0*maxf(2.0*Dn[i][n]*Dn[i][n+1]/(Dn[i][n]+Dn[i][n+1]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			   my_bound.top[i].ap/=alpha;
		   rthdsd[i][n+1]+=my_bound.top[i].ap*(1.0-alpha)*nu[i][n+1];

			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   // граничное условие для энергии :
			   // u0+taue*elementary_q*emag*drift_vel_mag;
			   //rthdsd[i][n+1]=energy_source+taue*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   // условие для nu
			   // Здесь использована величина neg[i][n+1]==Nd это концентрация электронов на стоке.
               //rthdsd[i][n+1]=neg[i][n+1]*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   rthdsd[i][n+1]=taue*Nd*elementary_q*emag[i][n+1]*sqrt((x_vel_face_sn[i][n]*x_vel_face_sn[i][n])+(y_vel_f[i][n]*y_vel_f[i][n]));
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			  Real Dnc=2.0*maxf(2.0*Dn[i][n]*Dn[i][n+1]/(Dn[i][n]+Dn[i][n+1]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			  my_bound.top[i].ap/=alpha;
		     rthdsd[i][n+1]+=my_bound.top[i].ap*(1.0-alpha)*nu[i][n+1];
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   Real Dnc=2.0*maxf(2.0*Dn[1][i]*Dn[0][i]/(Dn[1][i]+Dn[0][i]),(x[1]-x[0])*fabs(x_vel_f[0][i]));
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,x_vel_f[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,-x_vel_f[0][i]));
	   my_bound.left[i].ap/=alpha;
	   rthdsd[0][i]+=my_bound.left[i].ap*(1.0-alpha)*nu[0][i];
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	    Dnc=2.0*maxf(2.0*Dn[m+1][i]*Dn[m][i]/(Dn[m+1][i]+Dn[m][i]),(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,-x_vel_f[m][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,x_vel_f[m][i]));
	   my_bound.right[i].ap/=alpha;
	   rthdsd[m+1][i]+=my_bound.right[i].ap*(1.0-alpha)*nu[m+1][i];
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_nu6

// Загружает граничные условия для концентрации электронов
// скорости заданы на фейсах.
// для AlGaNGaN транзистора.
void load_my_bound_n2AlGaNGaN(TBONCONDOMAIN &my_bound, Real xendsource, Real  xstartgate, Real xendgate, Real xstartdrain, 
					 Real** x_vel_f, Real** y_vel_f, Real **Ndprofile, Real* x, Real* y, Real **Dn, Real** &rthdsd, int m, int n) {

		// Dn - постояный безразмерный коэффициент диффузии.

            for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           //my_bound.bottom[i].FI_inf=0.0;
		   //my_bound.bottom[i].gamma=1.0;
		   //my_bound.bottom[i].kappa=0.0;
		   //my_bound.bottom[i].qset=0.0;
		   rthdsd[i][0]=0.0;
		    Real Dnc=maxf(0.5*(Dn[i][0]+Dn[i][1]),(y[1]-y[0])*fabs(y_vel_f[i][0]));
		   my_bound.bottom[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,y_vel_f[i][0]));
		   my_bound.bottom[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[1]-y[0])+maxf(0.0,-y_vel_f[i][0]));
		   // верхняя граница
		   if (x[i]<xendsource) {
			   //my_bound.top[i].FI_inf=Nd; // source
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   //my_bound.top[i].ap=-1.0;
			   //my_bound.top[i].ai=-1.0;
               rthdsd[i][n+1]=Ndprofile[i][N+1];
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else if ((x[i]>xstartgate)&&(x[i]<xendgate)) {
			   //my_bound.top[i].FI_inf=0.0; // gate
		       //my_bound.top[i].gamma=1.0;
		       //my_bound.top[i].kappa=0.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=0.0;
			  // my_bound.top[i].ap=1.0; 
               //my_bound.top[i].ai=0.0;
			   Real Dnc=maxf(0.5*(Dn[i][n+1]+Dn[i][n]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
               my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		       my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
			   if (my_bound.top[i].ap<0.0) {
				   printf("negative gate ap\n"); 
				   getchar();
			   }
		   }
		   else if (x[i]>xstartdrain) {
               //my_bound.top[i].FI_inf=Nd; // drain
		       //my_bound.top[i].gamma=0.0;
		       //my_bound.top[i].kappa=1.0;
		       //my_bound.top[i].qset=0.0;
			   rthdsd[i][n+1]=Ndprofile[i][N+1];
			   my_bound.top[i].ap=1.0;
			   my_bound.top[i].ai=0.0;
		   }
		   else
		   {
		      //my_bound.top[i].FI_inf=0.0;
		      //my_bound.top[i].gamma=1.0;
		      //my_bound.top[i].kappa=0.0;
		      //my_bound.top[i].qset=0.0;
			  rthdsd[i][n+1]=0.0;
			   Real Dnc=maxf(0.5*(Dn[i][n+1]+Dn[i][n]),(y[n+1]-y[n])*fabs(y_vel_f[i][n]));
              my_bound.top[i].ap=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,-y_vel_f[i][n]));
		      my_bound.top[i].ai=0.5*(x[i+1]-x[i-1])*(Dnc/(y[n+1]-y[n])+maxf(0.0,y_vel_f[i][n]));
		   }
        }

	for (int i=1; i<n+1; i++) {
	   // левая граница
	  // my_bound.left[i].FI_inf=0.0;
	  // my_bound.left[i].gamma=1.0;
	  // my_bound.left[i].kappa=0.0;
	   //my_bound.left[i].qset=0.0;
	   rthdsd[0][i]=0.0;
	   Real Dnc=maxf(0.5*(Dn[0][i]+Dn[1][i]),(x[1]-x[0])*fabs(x_vel_f[0][i]));
       my_bound.left[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,x_vel_f[0][i]));
	   my_bound.left[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[1]-x[0])+maxf(0.0,-x_vel_f[0][i]));
	   // правая граница
	   //my_bound.right[i].FI_inf=0.0;
	   //my_bound.right[i].gamma=1.0;
	   //my_bound.right[i].kappa=0.0;
	   //my_bound.right[i].qset=0.0;
	   rthdsd[m+1][i]=0.0;
	    Dnc=maxf(0.5*(Dn[m+1][i]+Dn[m][i]),(x[m+1]-x[m])*fabs(x_vel_f[m][i]));
	   my_bound.right[i].ap=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,-x_vel_f[m][i]));
	   my_bound.right[i].ai=0.5*(y[i+1]-y[i-1])*(Dnc/(x[m+1]-x[m])+maxf(0.0,x_vel_f[m][i]));
	}
 
	rthdsd[0][0]=0.0;
	rthdsd[m+1][0]=0.0;
	rthdsd[0][n+1]=0.0;
	rthdsd[m+1][n+1]=0.0;

} // load_my_bound_n2AlGaNGaN


// задание граничных условий для поля температур.
// подходит для неравномерной сетки.
void load_my_bound_temp0(TBONCONDOMAIN& my_bound, int itask,
	Real* x, Real* y, int m, int n) 
{

	for (int i = 1; i < m + 1; i++) {
		my_bound.bottom[i].ap = 1.0;
		my_bound.bottom[i].ai = 0.0;
		my_bound.top[i].ap = 1.0;
		my_bound.top[i].ai = 0.0;
	}
	for (int i = 1; i < n + 1; i++) {
		my_bound.left[i].ap = 1.0;
		my_bound.left[i].ai = 0.0;
		my_bound.right[i].ap = 1.0;
		my_bound.right[i].ai = 0.0;
	}

	for (int i = 1; i < m + 1; i++) {
		// нижняя граница
		my_bound.bottom[i].FI_inf = 0.0;
		my_bound.bottom[i].gamma = 0.0;
		my_bound.bottom[i].kappa = 1.0;
		my_bound.bottom[i].qset = 0.0;
		// верхняя граница
		my_bound.top[i].FI_inf = 0.0;
		my_bound.top[i].gamma = 0.0;
		my_bound.top[i].kappa = 1.0;
		my_bound.top[i].qset = 0.0;
	}
	for (int i = 1; i < n + 1; i++) {
		// левая граница
		my_bound.left[i].FI_inf = 0.0;
		my_bound.left[i].gamma = 0.0;
		my_bound.left[i].kappa = 1.0;
		my_bound.left[i].qset = 0.0;
		// правая граница
		my_bound.right[i].FI_inf = 0.0;
		my_bound.right[i].gamma = 0.0;
		my_bound.right[i].kappa = 1.0;
		my_bound.right[i].qset = 0.0;
	}

}
// задание граничных условий для поля температур.
// подходит для неравномерной сетки.
void load_my_bound_temp(TBONCONDOMAIN &my_bound, int itask, 
	                    Real* x, Real* y, int m, int n) {
	// itask - номер задачи.
	// my_bound - информация о граничных условиях.

	Real rmarker1;
	Real rmarker2;

	Real templeft=1.0; // температура слева
	Real tempright=0.0; // температура на правой стенке.
	
	for (int i=1; i<m+1; i++) {
		my_bound.bottom[i].ap=-1.0;
        my_bound.bottom[i].ai=-1.0;
		my_bound.top[i].ap=-1.0;
        my_bound.top[i].ai=-1.0;
	}
	for (int i=1; i<n+1; i++) {
		my_bound.left[i].ap=-1.0;
		my_bound.left[i].ai=-1.0;
		my_bound.right[i].ap=-1.0;
		my_bound.right[i].ai=-1.0;
	}
	
	/*
	for (int i=1; i<m+1; i++) {
		my_bound.bottom[i].ap=1.0;
        my_bound.bottom[i].ai=1.0;
		my_bound.top[i].ap=1.0;
        my_bound.top[i].ai=1.0;
	}
	for (int i=1; i<n+1; i++) {
		my_bound.left[i].ap=1.0;
		my_bound.left[i].ai=1.0;
		my_bound.right[i].ap=1.0;
		my_bound.right[i].ai=1.0;
	}
	*/
    switch (itask) {
	case STUDENT :
		// Левое граничное условие при температуре 400К а остальные при температуре 300К.
		for (int i=1; i<m+1; i++) {
		   // нижняя граница
			my_bound.bottom[i].FI_inf = 0.0;// 300.0;
		   my_bound.bottom[i].gamma=0.0;
		   my_bound.bottom[i].kappa=1.0;
		   my_bound.bottom[i].qset=0.0;
		   // верхняя граница
		   my_bound.top[i].FI_inf = 0.0;// 300.0;
		   my_bound.top[i].gamma=0.0;
		   my_bound.top[i].kappa=1.0;
		   my_bound.top[i].qset=0.0;
        }
	    for (int i=1; i<n+1; i++) {
		    // левая граница
			my_bound.left[i].FI_inf = 0.0;//400.0;
		    my_bound.left[i].gamma=0.0;
		    my_bound.left[i].kappa=1.0;
		    my_bound.left[i].qset=0.0;
		    // правая граница
			my_bound.right[i].FI_inf = 0.0;// 300.0;
		    my_bound.right[i].gamma=0.0;
		    my_bound.right[i].kappa=1.0;
		    my_bound.right[i].qset=0.0;
	    }
		break;
	case STUDENTA :
		// Левое граничное условие при температуре 1К а правое при температуре 0К.
		// на остальных стенках однородное условие Неймана.

		for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // однородные условия Неймана.
           my_bound.bottom[i].FI_inf=0.0;
		   my_bound.bottom[i].gamma=1.0;
		   my_bound.bottom[i].kappa=0.0;
		   my_bound.bottom[i].qset=0.0;
		   // верхняя граница
		   // однородные условия Неймана.
		   my_bound.top[i].FI_inf=0.0;
		   my_bound.top[i].gamma=1.0;
		   my_bound.top[i].kappa=0.0;
		   my_bound.top[i].qset=0.0;
        }
	    for (int i=1; i<n+1; i++) {
		    // левая граница
		    my_bound.left[i].FI_inf=templeft;
		    my_bound.left[i].gamma=0.0;
		    my_bound.left[i].kappa=1.0;
		    my_bound.left[i].qset=0.0;
		    // правая граница
		    my_bound.right[i].FI_inf=tempright;
		    my_bound.right[i].gamma=0.0;
		    my_bound.right[i].kappa=1.0;
		    my_bound.right[i].qset=0.0;
	    }
		break;
	case DAVIS :
		// Левое граничное условие при температуре 400К а правое при температуре 300К.
		// на остальных границах стоит однородное условие Неймана.
		for (int i=1; i<m+1; i++) {
		   // нижняя граница
           my_bound.bottom[i].FI_inf=0.0;
		   my_bound.bottom[i].gamma=1.0;
		   my_bound.bottom[i].kappa=0.0;
		   my_bound.bottom[i].qset=0.0;
		   // верхняя граница
		   my_bound.top[i].FI_inf=0.0;
		   my_bound.top[i].gamma=1.0;
		   my_bound.top[i].kappa=0.0;
		   my_bound.top[i].qset=0.0;
        }
	    for (int i=1; i<n+1; i++) {
		    // левая граница
		    my_bound.left[i].FI_inf=400.0;
		    my_bound.left[i].gamma=0.0;
		    my_bound.left[i].kappa=1.0;
		    my_bound.left[i].qset=0.0;
		    // правая граница
		    my_bound.right[i].FI_inf=300.0;
		    my_bound.right[i].gamma=0.0;
		    my_bound.right[i].kappa=1.0;
		    my_bound.right[i].qset=0.0;
	    }
		break;
	case CHOHRAVLSKY :
	   // 2. Печь Чохральского.
	   // верхняя граница.
       rmarker1=lengthx/3.0;
	   rmarker2=2.0*rmarker1;
	   for (int i=1; i<m+1; i++) {
		   // нижняя граница
		   // Тигель.
		   my_bound.bottom[i].FI_inf=400.0;
		   my_bound.bottom[i].gamma=0.0;
		   my_bound.bottom[i].kappa=1.0;
		   my_bound.bottom[i].qset=0.0;
		   // верхняя граница
		   if ((x[i]>=rmarker1)&&(x[i]<=rmarker2)) {
		    	// Условие Дирихле
			    my_bound.top[i].FI_inf=300.0; // Кристалл.
			    my_bound.top[i].gamma=0.0;
			    my_bound.top[i].kappa=1.0; 
			    my_bound.top[i].qset=0.0;
		   }
		   else {
			    // Свободная поверхность.
			    // Однородное условие Неймана.
			    my_bound.top[i].FI_inf=0.0;
			    my_bound.top[i].gamma=1.0;
			    my_bound.top[i].kappa=0.0;
			    my_bound.top[i].qset=0.0;
		   }
	    }
	    for (int i=1; i<n+1; i++) {
		    // левая граница
		    my_bound.left[i].FI_inf=400.0;
		    my_bound.left[i].gamma=0.0;
		    my_bound.left[i].kappa=1.0;
		    my_bound.left[i].qset=0.0;
		    // правая граница
		    my_bound.right[i].FI_inf=400.0;
		    my_bound.right[i].gamma=0.0;
		    my_bound.right[i].kappa=1.0;
		    my_bound.right[i].qset=0.0;
	    }
	    break;
	case BLASIUS :
		// Задача обтекания нагретой плоской пластинки
		// набегающим потоком.
		rmarker1=(5.0/9.0)*lengthx;
		rmarker2=(2.0/3.0)*lengthx;
		for (int i=1; i<m+1; i++) {
		   // нижняя граница
           if ((x[i]>=rmarker1)&&(x[i]<=rmarker2)) {
			  // Пластина 1.0K
			   my_bound.bottom[i].FI_inf=1.0;
		       my_bound.bottom[i].gamma=0.0;
		       my_bound.bottom[i].kappa=1.0;
		       my_bound.bottom[i].qset=0.0;
		   }
		   else
		   {
			    // условие симметрии
               my_bound.bottom[i].FI_inf=0.0;
		       my_bound.bottom[i].gamma=1.0;
		       my_bound.bottom[i].kappa=0.0;
		       my_bound.bottom[i].qset=0.0;
		   }
		   // верхняя граница
		   my_bound.top[i].FI_inf=0.0;
		   my_bound.top[i].gamma=1.0;
		   my_bound.top[i].kappa=0.0;
		   my_bound.top[i].qset=0.0;
        }
	    for (int i=1; i<n+1; i++) {
		    // левая граница 0.0 K
		    my_bound.left[i].FI_inf=0.0;
		    my_bound.left[i].gamma=0.0;
		    my_bound.left[i].kappa=1.0;
		    my_bound.left[i].qset=0.0;
		    // правая граница
		    my_bound.right[i].FI_inf=0.0;
		    my_bound.right[i].gamma=1.0;
		    my_bound.right[i].kappa=0.0;
		    my_bound.right[i].qset=0.0;
	    }
		break;
	case RALEYBENAR :
		// Задача лорда Релея.
		// Нижняя граница горячая, верхняя холодная, а по бокам однородные условия Неймана.
		for (int i=1; i<m+1; i++) {
		   // нижняя граница
           my_bound.bottom[i].FI_inf=400.0;
		   my_bound.bottom[i].gamma=0.0;
		   my_bound.bottom[i].kappa=1.0;
		   my_bound.bottom[i].qset=0.0;
		   // верхняя граница
		   my_bound.top[i].FI_inf=300.0;
		   my_bound.top[i].gamma=0.0;
		   my_bound.top[i].kappa=1.0;
		   my_bound.top[i].qset=0.0;
        }
	    for (int i=1; i<n+1; i++) {
		    // левая граница
		    my_bound.left[i].FI_inf=0.0;
		    my_bound.left[i].gamma=1.0;
		    my_bound.left[i].kappa=0.0;
		    my_bound.left[i].qset=0.0;
		    // правая граница
		    my_bound.right[i].FI_inf=0.0;
		    my_bound.right[i].gamma=1.0;
		    my_bound.right[i].kappa=0.0;
		    my_bound.right[i].qset=0.0;
	    }
		break;
	case RALEYBENAR_SYMMETRY:
		// Задача лорда Релея.
		// Нижняя граница горячая, верхняя холодная, а по бокам однородные условия Неймана.
		for (int i = 1; i < m + 1; i++) {
			// нижняя граница
			my_bound.bottom[i].FI_inf = 400.0;
			my_bound.bottom[i].gamma = 0.0;
			my_bound.bottom[i].kappa = 1.0;
			my_bound.bottom[i].qset = 0.0;
			// верхняя граница
			my_bound.top[i].FI_inf = 300.0;
			my_bound.top[i].gamma = 0.0;
			my_bound.top[i].kappa = 1.0;
			my_bound.top[i].qset = 0.0;
		}
		for (int i = 1; i < n + 1; i++) {
			// левая граница
			my_bound.left[i].FI_inf = 0.0;
			my_bound.left[i].gamma = 1.0;
			my_bound.left[i].kappa = 0.0;
			my_bound.left[i].qset = 0.0;
			// правая граница
			my_bound.right[i].FI_inf = 0.0;
			my_bound.right[i].gamma = 1.0;
			my_bound.right[i].kappa = 0.0;
			my_bound.right[i].qset = 0.0;
		}
		break;
	}


} // load_my_bound_temp

void load_my_bound_conc(TBONCONDOMAIN &my_bound, int itask, 
	                    Real* x, Real* y, int m, int n) {
	// itask - номер задачи.
	// my_bound - информация о граничных условиях.

	//Real rmarker1;
	//Real rmarker2;


	Real concleft=1.0;
	Real concright=0.0;

	for (int i=1; i<m+1; i++) {
		my_bound.bottom[i].ap=-1.0;
        my_bound.bottom[i].ai=-1.0;
		my_bound.top[i].ap=-1.0;
        my_bound.top[i].ai=-1.0;
	}
	for (int i=1; i<n+1; i++) {
		my_bound.left[i].ap=-1.0;
		my_bound.left[i].ai=-1.0;
		my_bound.right[i].ap=-1.0;
		my_bound.right[i].ai=-1.0;
	}

    switch (itask) {
	case STUDENTA :
		// Левое граничное условие при концентрации 1 а правое при концентрации 0.
		// на остальных однородное условие Неймана.

		for (int i=1; i<m+1; i++) {
		   // нижняя граница
           my_bound.bottom[i].FI_inf=0.0;
		   my_bound.bottom[i].gamma=1.0;
		   my_bound.bottom[i].kappa=0.0;
		   my_bound.bottom[i].qset=0.0;
		   // верхняя граница
		   my_bound.top[i].FI_inf=0.0;
		   my_bound.top[i].gamma=1.0;
		   my_bound.top[i].kappa=0.0;
		   my_bound.top[i].qset=0.0;
        }
	    for (int i=1; i<n+1; i++) {
		    // левая граница
		    my_bound.left[i].FI_inf=concleft;
		    my_bound.left[i].gamma=0.0;
		    my_bound.left[i].kappa=1.0;
		    my_bound.left[i].qset=0.0;
		    // правая граница
		    my_bound.right[i].FI_inf=concright;
		    my_bound.right[i].gamma=0.0;
		    my_bound.right[i].kappa=1.0;
		    my_bound.right[i].qset=0.0;
	    }
		break;
	default :
		// на всех границах однородные условия Дирихле.

		for (int i=1; i<m+1; i++) {
		   // нижняя граница
           my_bound.bottom[i].FI_inf=0.0;
		   my_bound.bottom[i].gamma=0.0;
		   my_bound.bottom[i].kappa=1.0;
		   my_bound.bottom[i].qset=0.0;
		   // верхняя граница
		   my_bound.top[i].FI_inf=0.0;
		   my_bound.top[i].gamma=0.0;
		   my_bound.top[i].kappa=1.0;
		   my_bound.top[i].qset=0.0;
        }
	    for (int i=1; i<n+1; i++) {
		    // левая граница
		    my_bound.left[i].FI_inf=0.0;
		    my_bound.left[i].gamma=0.0;
		    my_bound.left[i].kappa=1.0;
		    my_bound.left[i].qset=0.0;
		    // правая граница
		    my_bound.right[i].FI_inf=0.0;
		    my_bound.right[i].gamma=0.0;
		    my_bound.right[i].kappa=1.0;
		    my_bound.right[i].qset=0.0;
	    }
		break;
	}
} // load_my_bound_conc

// Граничные условия для функции тока.
// данный код пригоден и для неравномерной сетки.
void load_my_bound_stream_function(TBONCONDOMAIN &my_bound, int itask, Real time, 
	                               Real* x, Real* y, int m, int n) {
	// itask - номер задачи.
	// my_bound - информация о граничных условиях.

	Real rmarker1;
	Real rmarker2;

	for (int i=1; i<m+1; i++) {
		my_bound.bottom[i].ap=-1.0;
        my_bound.bottom[i].ai=-1.0;
		my_bound.top[i].ap=-1.0;
        my_bound.top[i].ai=-1.0;
	}
	for (int i=1; i<n+1; i++) {
		my_bound.left[i].ap=-1.0;
		my_bound.left[i].ai=-1.0;
		my_bound.right[i].ap=-1.0;
		my_bound.right[i].ai=-1.0;
	}

	 switch (itask) {
	 case DAVIS : case STUDENTA : case CHOHRAVLSKY :
			 // Vah`l Davis Test
			 // Всюду однородные условия Дирихле для функции тока
		     for (int i=1; i<m+1; i++) {
		         // нижняя граница
                 my_bound.bottom[i].FI_inf=0.0;
		         my_bound.bottom[i].gamma=0.0;
		         my_bound.bottom[i].kappa=1.0;
		         my_bound.bottom[i].qset=0.0;
		         // верхняя граница
		         my_bound.top[i].FI_inf=0.0;
		         my_bound.top[i].gamma=0.0;
		         my_bound.top[i].kappa=1.0;
		         my_bound.top[i].qset=0.0;
              }
	          for (int i=1; i<n+1; i++) {
		         // левая граница
		         my_bound.left[i].FI_inf=0.0;
		         my_bound.left[i].gamma=0.0;
		         my_bound.left[i].kappa=1.0;
		         my_bound.left[i].qset=0.0;
		         // правая граница
		         my_bound.right[i].FI_inf=0.0;
		         my_bound.right[i].gamma=0.0;
		         my_bound.right[i].kappa=1.0;
		         my_bound.right[i].qset=0.0;
	         }
			 break;
		case BLASIUS :
			// На входной границе, а также на поверхности пластины вибрирующей поперёк своей плоскости
			// мы задаём условие Роуча, Мюллера (см. Роуч) состоящее в том что мы фиксируемфункцию тока,
			// фиксируем тангенсальную (касательную производную) от скорости набегающего потока и саму скорость и её вторую производную тоже.
			// Здесь скорость набегающего потока на всей границе неизменна поэтому касательная производная от скорости набегающего потока равна нулю.

		     // Задача обтекания нагретой плоской пластинки
		     // набегающим потоком.
		     rmarker1=(5.0/9.0)*lengthx;
			 rmarker2=(2.0/3.0)*lengthx;
		     for (int i=1; i<m+1; i++) {
		         // нижняя граница 
                 if ((x[i]>=rmarker1)&&(x[i]<=rmarker2)) {
			        // нижняя граница 
					 // вибрирующая поперёк своей плоскости пластинка
			        my_bound.bottom[i].FI_inf=amplitude0*(x[i]-rmarker1)*sin(Omega*time);
		            my_bound.bottom[i].gamma=0.0;
		            my_bound.bottom[i].kappa=1.0;
		            my_bound.bottom[i].qset=0.0;
		         }
		         else if (x[i]<rmarker1) 
		         {
                    // ось симметрии слева
                    my_bound.bottom[i].FI_inf=0.0;
		            my_bound.bottom[i].gamma=0.0;
		            my_bound.bottom[i].kappa=1.0;
		            my_bound.bottom[i].qset=0.0;			        
		         }
				 else if (x[i]>rmarker2) {
					 // ось симметрии справа
                    my_bound.bottom[i].FI_inf=amplitude0*(rmarker2-rmarker1)*sin(Omega*time);
		            my_bound.bottom[i].gamma=0.0;
		            my_bound.bottom[i].kappa=1.0;
		            my_bound.bottom[i].qset=0.0;	
				 }
		         // верхняя открытая граница
		         my_bound.top[i].FI_inf=y[n+1];//1.0; // безразмерная скорость набегающего потока равна 1.0
		         my_bound.top[i].gamma=0.0;
		         my_bound.top[i].kappa=1.0;
		         my_bound.top[i].qset=0.0;
             }
	         for (int i=1; i<n+1; i++) {
		         // левая входная граница
		         my_bound.left[i].FI_inf=y[i]*1.0;//1.0 скорость набегающего потока.
		         my_bound.left[i].gamma=0.0;
		         my_bound.left[i].kappa=1.0;
		         my_bound.left[i].qset=0.0;
		         // правая выходная граница (Однородное условие Неймана).
		         my_bound.right[i].FI_inf=0.0;
		         my_bound.right[i].gamma=1.0;
		         my_bound.right[i].kappa=0.0;
		         my_bound.right[i].qset=0.0;
	         }
		     break;
		case RALEYBENAR :
		     // Задача лорда Релея.
		     // Всюду однородные условия Дирихле для функции тока
		     for (int i=1; i<m+1; i++) {
		        // нижняя граница
                my_bound.bottom[i].FI_inf=0.0;
		        my_bound.bottom[i].gamma=0.0;
		        my_bound.bottom[i].kappa=1.0;
		        my_bound.bottom[i].qset=0.0;
		        // верхняя граница
		        my_bound.top[i].FI_inf=0.0;
		        my_bound.top[i].gamma=0.0;
		        my_bound.top[i].kappa=1.0;
		        my_bound.top[i].qset=0.0;
             }
	         for (int i=1; i<n+1; i++) {
		        // левая граница
		        my_bound.left[i].FI_inf=0.0;
		        my_bound.left[i].gamma=0.0;
		        my_bound.left[i].kappa=1.0;
		        my_bound.left[i].qset=0.0;
		        // правая граница
		        my_bound.right[i].FI_inf=0.0;
		        my_bound.right[i].gamma=0.0;
		        my_bound.right[i].kappa=1.0;
		        my_bound.right[i].qset=0.0;
	         }
		break;
		case RALEYBENAR_SYMMETRY:
			// Задача лорда Релея.
			// Всюду однородные условия Дирихле для функции тока
			for (int i = 1; i < m + 1; i++) {
				// нижняя граница
				my_bound.bottom[i].FI_inf = 0.0;
				my_bound.bottom[i].gamma = 0.0;
				my_bound.bottom[i].kappa = 1.0;
				my_bound.bottom[i].qset = 0.0;
				// верхняя граница
				my_bound.top[i].FI_inf = 0.0;
				my_bound.top[i].gamma = 0.0;
				my_bound.top[i].kappa = 1.0;
				my_bound.top[i].qset = 0.0;
			}
			for (int i = 1; i < n + 1; i++) {
				// левая граница
				my_bound.left[i].FI_inf = 0.0;
				my_bound.left[i].gamma = 0.0;
				my_bound.left[i].kappa = 1.0;
				my_bound.left[i].qset = 0.0;
				// правая граница
				my_bound.right[i].FI_inf = 0.0;
				my_bound.right[i].gamma = 0.0;
				my_bound.right[i].kappa = 1.0;
				my_bound.right[i].qset = 0.0;
			}
			break;
	 }


} // load_my_bound_stream_function

// Граничные условия для функции Gpot.
// данный код пригоден и для неравномерной сетки.
void load_my_bound_Gpot(TBONCONDOMAIN &my_bound, int itask, Real time, 
	                               Real* x, Real* y, int m, int n) {
	// itask - номер задачи.
	// my_bound - информация о граничных условиях.

	//Real rmarker1;
	//Real rmarker2;

	for (int i=1; i<m+1; i++) {
		my_bound.bottom[i].ap=-1.0;
        my_bound.bottom[i].ai=-1.0;
		my_bound.top[i].ap=-1.0;
        my_bound.top[i].ai=-1.0;
	}
	for (int i=1; i<n+1; i++) {
		my_bound.left[i].ap=-1.0;
		my_bound.left[i].ai=-1.0;
		my_bound.right[i].ap=-1.0;
		my_bound.right[i].ai=-1.0;
	}

	 switch (itask) {
	 case DAVIS : case CHOHRAVLSKY : case RALEYBENAR : case RALEYBENAR_SYMMETRY :
			 // Vah`l Davis Test
			 // Всюду однородные условия Дирихле для функции Gpot
			 // что соответствует твёрдой непроницаемой стенке.
		     for (int i=1; i<m+1; i++) {
		         // нижняя граница
                 my_bound.bottom[i].FI_inf=0.0;
		         my_bound.bottom[i].gamma=0.0;
		         my_bound.bottom[i].kappa=1.0;
		         my_bound.bottom[i].qset=0.0;
		         // верхняя граница
		         my_bound.top[i].FI_inf=0.0;
		         my_bound.top[i].gamma=0.0;
		         my_bound.top[i].kappa=1.0;
		         my_bound.top[i].qset=0.0;
              }
	          for (int i=1; i<n+1; i++) {
		         // левая граница
		         my_bound.left[i].FI_inf=0.0;
		         my_bound.left[i].gamma=0.0;
		         my_bound.left[i].kappa=1.0;
		         my_bound.left[i].qset=0.0;
		         // правая граница
		         my_bound.right[i].FI_inf=0.0;
		         my_bound.right[i].gamma=0.0;
		         my_bound.right[i].kappa=1.0;
		         my_bound.right[i].qset=0.0;
	         }
			 break;
	 default :
		 // Vah`l Davis Test
		 // Всюду однородные условия Дирихле для функции Gpot
		 // что соответствует твёрдой непроницаемой стенке.
		 for (int i = 1; i < m + 1; i++) {
			 // нижняя граница
			 my_bound.bottom[i].FI_inf = 0.0;
			 my_bound.bottom[i].gamma = 0.0;
			 my_bound.bottom[i].kappa = 1.0;
			 my_bound.bottom[i].qset = 0.0;
			 // верхняя граница
			 my_bound.top[i].FI_inf = 0.0;
			 my_bound.top[i].gamma = 0.0;
			 my_bound.top[i].kappa = 1.0;
			 my_bound.top[i].qset = 0.0;
		 }
		 for (int i = 1; i < n + 1; i++) {
			 // левая граница
			 my_bound.left[i].FI_inf = 0.0;
			 my_bound.left[i].gamma = 0.0;
			 my_bound.left[i].kappa = 1.0;
			 my_bound.left[i].qset = 0.0;
			 // правая граница
			 my_bound.right[i].FI_inf = 0.0;
			 my_bound.right[i].gamma = 0.0;
			 my_bound.right[i].kappa = 1.0;
			 my_bound.right[i].qset = 0.0;
		 }
		 break;
	 }
} // load_my_bound_Gpot


// Граничные условия для вихря.
// По видимому граничные условия для вихря это основная сложность
// при работе в терминах вихрь функция тока.
// данный метод пригоден для квази нравномерной сетки (сетка должна быть равномерной вблизи стенки хотя бы в пределах двух шагов.).
void load_my_bound_curl(TBONCONDOMAIN &my_bound, int itask, 
	                    Real** &curl, Real** &psi,
						Real** &u, Real** &v, // текущее поле скорости.
						int ischemeapprox, Real alpha,
	                    Real time,
						Real *x, Real *y, // неравномерная расчётная сетка.
						int m, int n) {
	// itask - номер задачи.
	// my_bound - информация о граничных условиях.
	// alpha - коэффициент нижней релаксации (Н.Г. Бураго рекомендует alpha=1.0/8.0; иначе возникают осцилляции).
	// ischemeapprox - схема аппроксимации условия для вихря TOMA, WOODS, JENSEN.
	// curl, psi - вихрь и функция тока с предыдущего временного слоя.

    // Расчётная сетка должна быть такова чтобы ближайшие к стенке три узла были покрыты равномерной расчётной сеткой.


	Real rmarker1;
	Real rmarker2;

	for (int i=1; i<m+1; i++) {
		my_bound.bottom[i].ap=-1.0;
        my_bound.bottom[i].ai=-1.0;
		my_bound.top[i].ap=-1.0;
        my_bound.top[i].ai=-1.0;
	}
	for (int i=1; i<n+1; i++) {
		my_bound.left[i].ap=-1.0;
		my_bound.left[i].ai=-1.0;
		my_bound.right[i].ap=-1.0;
		my_bound.right[i].ai=-1.0;
	}

	switch (itask) {
	case DAVIS : case STUDENTA : case CHOHRAVLSKY :
			 // Vah`l Davis Test
		     for (int i=1; i<m+1; i++) {
				 switch (ischemeapprox) {
		             case TOMA : // условие Тома
						 // нижняя граница
                         my_bound.bottom[i].FI_inf=curl[i][0]+alpha*(2.0*(psi[i][1]-psi[i][0])/((y[1]-y[0])*(y[1]-y[0]))-curl[i][0]);
						 //if (my_bound.bottom[i].FI_inf != my_bound.bottom[i].FI_inf) {
							// std::cout << "y[0] y[1] "<< y[0] << " " << y[1] << psi[i][1]  << psi[i][0]  << curl[i][0] << std::endl;
							 //getchar();
						 //}
		                 my_bound.bottom[i].gamma=0.0;
		                 my_bound.bottom[i].kappa=1.0;
		                 my_bound.bottom[i].qset=0.0;
		                 // верхняя граница
		                 my_bound.top[i].FI_inf=curl[i][n+1]+alpha*(2.0*(psi[i][n]-psi[i][n+1])/((y[n+1]-y[n])*(y[n+1]-y[n]))-curl[i][n+1]);
						 //if (my_bound.top[i].FI_inf != my_bound.top[i].FI_inf) {
							// std::cout << "y[n] y[n+1] " << y[n] << " " << y[n+1] << std::endl;
							 //getchar();
						 //}
		                 my_bound.top[i].gamma=0.0;
		                 my_bound.top[i].kappa=1.0;
		                 my_bound.top[i].qset=0.0;
						 break;
					 case WOODS : // условие Вудса
						 // нижняя граница
                         my_bound.bottom[i].FI_inf=curl[i][0]+alpha*(-0.5*curl[i][1]+3.0*(psi[i][0]-psi[i][1])/((y[1]-y[0])*(y[1]-y[0]))-curl[i][0]);
						 if (my_bound.bottom[i].FI_inf != my_bound.bottom[i].FI_inf) {
							 std::cout << y[0] << " " << y[1] << std::endl;
						 }
						 my_bound.bottom[i].gamma=0.0;
		                 my_bound.bottom[i].kappa=1.0;
		                 my_bound.bottom[i].qset=0.0;
		                 // верхняя граница
		                 my_bound.top[i].FI_inf=curl[i][n+1]+alpha*(-0.5*curl[i][n]+3.0*(psi[i][n+1]-psi[i][n])/((y[n+1]-y[n])*(y[n+1]-y[n]))-curl[i][n+1]);
						 if (my_bound.top[i].FI_inf != my_bound.top[i].FI_inf) {
							 std::cout << y[n] << " " << y[n + 1] << std::endl;
						 }
						 my_bound.top[i].gamma=0.0;
		                 my_bound.top[i].kappa=1.0;
		                 my_bound.top[i].qset=0.0;
						 break;
					 case JENSEN : // условие Йенсена
						 // нижняя граница
                         my_bound.bottom[i].FI_inf=curl[i][0]+alpha*((-7.0*psi[i][0]+8.0*psi[i][1]-psi[i][2])/(2.0*(y[1]-y[0])*(y[1]-y[0]))-curl[i][0]);
						 if (my_bound.bottom[i].FI_inf != my_bound.bottom[i].FI_inf) {
							 std::cout << y[0] << " " << y[1] << std::endl;
						 }
						 //my_bound.bottom[i].FI_inf=curl[i][0]+alpha*((-7.0*psi[i][2]+8.0*psi[i][1]-psi[i][0])/(2.0*(y[1]-y[0])*(y[1]-y[0]))-curl[i][0]); // неверно
		                 my_bound.bottom[i].gamma=0.0;
		                 my_bound.bottom[i].kappa=1.0;
		                 my_bound.bottom[i].qset=0.0;
		                 // верхняя граница
		                 my_bound.top[i].FI_inf=curl[i][n+1]+alpha*((-7.0*psi[i][n+1]+8.0*psi[i][n]-psi[i][n-1])/(2.0*(y[n+1]-y[n])*(y[n+1]-y[n]))-curl[i][n+1]);
						 if (my_bound.top[i].FI_inf != my_bound.top[i].FI_inf) {
							 std::cout << y[n] << " " << y[n + 1] << std::endl;
						 }
						 my_bound.top[i].gamma=0.0;
		                 my_bound.top[i].kappa=1.0;
		                 my_bound.top[i].qset=0.0;
						 break;
				 }
		         
              }
	          for (int i=1; i<n+1; i++) {
				  switch (ischemeapprox) {
		             case TOMA : // условие Тома
		                  // левая граница
		                  my_bound.left[i].FI_inf=curl[0][i]+alpha*(2.0*(psi[1][i]-psi[0][i])/((x[1]-x[0])*(x[1]-x[0]))-curl[0][i]);
						  //if (my_bound.left[i].FI_inf != my_bound.left[i].FI_inf) {
							//  std::cout << x[0] << " " << x[1] << std::endl;
							  //getchar();
						  //}
						  my_bound.left[i].gamma=0.0;
		                  my_bound.left[i].kappa=1.0;
		                  my_bound.left[i].qset=0.0;
		                  // правая граница
		                  my_bound.right[i].FI_inf=curl[m+1][i]+alpha*(2.0*(psi[m][i]-psi[m+1][i])/((x[m+1]-x[m])*(x[m+1]-x[m]))-curl[m+1][i]);
						  //if (my_bound.right[i].FI_inf != my_bound.right[i].FI_inf) {
							//  std::cout << x[m] << " " << x[m + 1] << std::endl;
							  //getchar();
						  //}
						  my_bound.right[i].gamma=0.0;
		                  my_bound.right[i].kappa=1.0;
		                  my_bound.right[i].qset=0.0;
				     break;
					 case WOODS : // условие Вудса
						 // левая граница
		                  my_bound.left[i].FI_inf=curl[0][i]+alpha*(-0.5*curl[1][i]+3.0*(psi[0][i]-psi[1][i])/((x[1]-x[0])*(x[1]-x[0]))-curl[0][i]);
						  if (my_bound.left[i].FI_inf != my_bound.left[i].FI_inf) {
							  std::cout << x[0] << " " << x[1] << std::endl;
						  }
						  my_bound.left[i].gamma=0.0;
		                  my_bound.left[i].kappa=1.0;
		                  my_bound.left[i].qset=0.0;
		                  // правая граница
		                  my_bound.right[i].FI_inf=curl[m+1][i]+alpha*(-0.5*curl[m][i]+3.0*(psi[m+1][i]-psi[m][i])/((x[m+1]-x[m])*(x[m+1]-x[m]))-curl[m+1][i]);
						  if (my_bound.right[i].FI_inf != my_bound.right[i].FI_inf) {
							  std::cout << x[m] << " " << x[m + 1] << std::endl;
						  }
						  my_bound.right[i].gamma=0.0;
		                  my_bound.right[i].kappa=1.0;
		                  my_bound.right[i].qset=0.0;
						 break;
					 case JENSEN : // условие Йенсена
						 // левая граница
		                  my_bound.left[i].FI_inf=curl[0][i]+alpha*((-7.0*psi[0][i]+8.0*psi[1][i]-psi[2][i])/(2.0*(x[1]-x[0])*(x[1]-x[0]))-curl[0][i]);
						 //my_bound.left[i].FI_inf=curl[0][i]+alpha*((-7.0*psi[2][i]+8.0*psi[1][i]-psi[0][i])/(2.0*(x[1]-x[0])*(x[1]-x[0]))-curl[0][i]); // неверно
						  if (my_bound.left[i].FI_inf != my_bound.left[i].FI_inf) {
							  std::cout << x[0] << " " << x[1] << std::endl;
						  }
						  my_bound.left[i].gamma=0.0;
		                  my_bound.left[i].kappa=1.0;
		                  my_bound.left[i].qset=0.0;
		                  // правая граница
		                  my_bound.right[i].FI_inf=curl[m+1][i]+alpha*((-7.0*psi[m+1][i]+8.0*psi[m][i]-psi[m-1][i])/(2.0*(x[m+1]-x[m])*(x[m+1]-x[m]))-curl[m+1][i]);
						  if (my_bound.right[i].FI_inf != my_bound.right[i].FI_inf) {
							  std::cout << x[m] << " " << x[m + 1] << std::endl;
						  }
						  my_bound.right[i].gamma=0.0;
		                  my_bound.right[i].kappa=1.0;
		                  my_bound.right[i].qset=0.0;
						 break;
				  }
	         }
			 break;
			 case BLASIUS :
		     // Задача обтекания нагретой плоской пластинки
		     // набегающим потоком.
		     rmarker1=(5.0/9.0)*lengthx;
			 rmarker2=(2.0/3.0)*lengthx;
		     for (int i=1; i<m+1; i++) {
		         // нижняя граница 
                 if ((x[i]>=rmarker1)&&(x[i]<=rmarker2)) {
			       

					// нижняя граница пластинка
					 if (fabs(amplitude0)<1e-40) {

						 // нулевая скорость поперечных вибраций.
						 switch (ischemeapprox) {
		                    case TOMA : // условие Тома
						        // нижняя граница
                                my_bound.bottom[i].FI_inf=curl[i][0]+alpha*(2.0*(psi[i][1]-psi[i][0])/((y[1]-y[0])*(y[1]-y[0]))-curl[i][0]);
		                        my_bound.bottom[i].gamma=0.0;
		                        my_bound.bottom[i].kappa=1.0;
		                        my_bound.bottom[i].qset=0.0;
						    break;
					        case WOODS : // условие Вудса
						        // нижняя граница
                                my_bound.bottom[i].FI_inf=curl[i][0]+alpha*(-0.5*curl[i][1]+3.0*(psi[i][0]-psi[i][1])/((y[1]-y[0])*(y[1]-y[0]))-curl[i][0]);
		                        my_bound.bottom[i].gamma=0.0;
		                        my_bound.bottom[i].kappa=1.0;
		                        my_bound.bottom[i].qset=0.0;
		                    break;
					        case JENSEN : // условие Йенсена
						        // нижняя граница
                                my_bound.bottom[i].FI_inf=curl[i][0]+alpha*((-7.0*psi[i][0]+8.0*psi[i][1]-psi[i][2])/(2.0*(y[1]-y[0])*(y[1]-y[0]))-curl[i][0]);
		                        my_bound.bottom[i].gamma=0.0;
		                        my_bound.bottom[i].kappa=1.0;
		                        my_bound.bottom[i].qset=0.0;
		                    break;
				         }
					 }
					 else {
                        // присутствует заданная скорость поперечных вибраций.

			            //my_bound.bottom[i].FI_inf=curl[i][0]+alpha*((u[i][1]-u[i][0])/((y[1]-y[0]))-curl[i][0]);
						// Будем использовать условие Роуча и Мюллера.
                        my_bound.bottom[i].FI_inf=curl[i][0]+alpha*(((2.0*((psi[i][2]-psi[i][1])*(y[1]-y[0])+(psi[i][0]-psi[i][1])*(y[2]-y[1])))/((y[1]-y[0])*(y[2]-y[1])*(y[2]-y[0])))-curl[i][0]);
						my_bound.bottom[i].gamma=0.0;
		                my_bound.bottom[i].kappa=1.0;
		                my_bound.bottom[i].qset=0.0;
					 }	            

		         }
		         else
		         {
					 // нулевое значение завихрённости (вихря).

			         // ось симметрии
                    my_bound.bottom[i].FI_inf=0.0;
		            my_bound.bottom[i].gamma=0.0;
		            my_bound.bottom[i].kappa=1.0;
		            my_bound.bottom[i].qset=0.0;
		         }

		         // верхняя открытая граница
				 // ось симметрии (нулевое значение завихрённости)
		         my_bound.top[i].FI_inf=0.0; 
		         my_bound.top[i].gamma=0.0; // Вопрос : можно ли использовать однородное условие Неймана для вихря ?
		         my_bound.top[i].kappa=1.0;
		         my_bound.top[i].qset=0.0;
             }
	         for (int j=1; j<n+1; j++) {
		         // левая входная граница
				 // вторая производная от функции тока во втором узле. 
				 // условие Роуча, Мюллера см. книгу Роуча. Также дополнительно добавлена нижняя релаксация.
		         my_bound.left[j].FI_inf=curl[0][j]+alpha*((2.0*((psi[2][j]-psi[1][j])*(x[1]-x[0])+(psi[0][j]-psi[1][j])*(x[2]-x[1])))/((x[2]-x[1])*(x[1]-x[0])*(x[2]-x[0]))-curl[0][j]);
		         my_bound.left[j].gamma=0.0;
		         my_bound.left[j].kappa=1.0;
		         my_bound.left[j].qset=0.0;
		         // правая выходная граница (Однородное условие Неймана).
		         my_bound.right[j].FI_inf=0.0;
		         my_bound.right[j].gamma=1.0;
		         my_bound.right[j].kappa=0.0;
		         my_bound.right[j].qset=0.0;
	         }
		     break;
			 case RALEYBENAR :
		     // Задача лорда Релея.
				 for (int i=1; i<m+1; i++) {
				 switch (ischemeapprox) {
		             case TOMA : // условие Тома
						 // нижняя граница
                         my_bound.bottom[i].FI_inf=curl[i][0]+alpha*(2.0*(psi[i][1]-psi[i][0])/((y[1]-y[0])*(y[1]-y[0]))-curl[i][0]);
		                 my_bound.bottom[i].gamma=0.0;
		                 my_bound.bottom[i].kappa=1.0;
		                 my_bound.bottom[i].qset=0.0;
		                 // верхняя граница
		                 my_bound.top[i].FI_inf=curl[i][n+1]+alpha*(2.0*(psi[i][n]-psi[i][n+1])/((y[n+1]-y[n])*(y[n+1]-y[n]))-curl[i][n+1]); 
		                 my_bound.top[i].gamma=0.0;
		                 my_bound.top[i].kappa=1.0;
		                 my_bound.top[i].qset=0.0;
						 break;
					 case WOODS : // условие Вудса
						 // нижняя граница
                         my_bound.bottom[i].FI_inf=curl[i][0]+alpha*(-0.5*curl[i][1]+3.0*(psi[i][0]-psi[i][1])/((y[1]-y[0])*(y[1]-y[0]))-curl[i][0]);
		                 my_bound.bottom[i].gamma=0.0;
		                 my_bound.bottom[i].kappa=1.0;
		                 my_bound.bottom[i].qset=0.0;
		                 // верхняя граница
		                 my_bound.top[i].FI_inf=curl[i][n+1]+alpha*(-0.5*curl[i][n]+3.0*(psi[i][n+1]-psi[i][n])/((y[n+1]-y[n])*(y[n+1]-y[n]))-curl[i][n+1]);
		                 my_bound.top[i].gamma=0.0;
		                 my_bound.top[i].kappa=1.0;
		                 my_bound.top[i].qset=0.0;
						 break;
					 case JENSEN : // условие Йенсена
						 // нижняя граница
                         my_bound.bottom[i].FI_inf=curl[i][0]+alpha*((-7.0*psi[i][0]+8.0*psi[i][1]-psi[i][2])/(2.0*(y[1]-y[0])*(y[1]-y[0]))-curl[i][0]);
		                 my_bound.bottom[i].gamma=0.0;
		                 my_bound.bottom[i].kappa=1.0;
		                 my_bound.bottom[i].qset=0.0;
		                 // верхняя граница
		                 my_bound.top[i].FI_inf=curl[i][n+1]+alpha*((-7.0*psi[i][n+1]+8.0*psi[i][n]-psi[i][n-1])/(2.0*(y[n+1]-y[n])*(y[n+1]-y[n]))-curl[i][n+1]);
		                 my_bound.top[i].gamma=0.0;
		                 my_bound.top[i].kappa=1.0;
		                 my_bound.top[i].qset=0.0;
						 break;
				 }
		         
              }
	          for (int i=1; i<n+1; i++) {
				  switch (ischemeapprox) {
		             case TOMA : // условие Тома
		                  // левая граница
		                  my_bound.left[i].FI_inf=curl[0][i]+alpha*(2.0*(psi[1][i]-psi[0][i])/((x[1]-x[0])*(x[1]-x[0]))-curl[0][i]);
		                  my_bound.left[i].gamma=0.0;
		                  my_bound.left[i].kappa=1.0;
		                  my_bound.left[i].qset=0.0;
		                  // правая граница
		                  my_bound.right[i].FI_inf=curl[m+1][i]+alpha*(2.0*(psi[m][i]-psi[m+1][i])/((x[m+1]-x[m])*(x[m+1]-x[m]))-curl[m+1][i]);
		                  my_bound.right[i].gamma=0.0;
		                  my_bound.right[i].kappa=1.0;
		                  my_bound.right[i].qset=0.0;
				     break;
					 case WOODS : // условие Вудса
						 // левая граница
		                  my_bound.left[i].FI_inf=curl[0][i]+alpha*(-0.5*curl[1][i]+3.0*(psi[0][i]-psi[1][i])/((x[1]-x[0])*(x[1]-x[0]))-curl[0][i]);
		                  my_bound.left[i].gamma=0.0;
		                  my_bound.left[i].kappa=1.0;
		                  my_bound.left[i].qset=0.0;
		                  // правая граница
		                  my_bound.right[i].FI_inf=curl[m+1][i]+alpha*(-0.5*curl[m][i]+3.0*(psi[m+1][i]-psi[m][i])/((x[m+1]-x[m])*(x[m+1]-x[m]))-curl[m+1][i]);
		                  my_bound.right[i].gamma=0.0;
		                  my_bound.right[i].kappa=1.0;
		                  my_bound.right[i].qset=0.0;
						 break;
					 case JENSEN : // условие Йенсена
						 // левая граница
		                  my_bound.left[i].FI_inf=curl[0][i]+alpha*((-7.0*psi[0][i]+8.0*psi[1][i]-psi[2][i])/(2.0*(x[1]-x[0])*(x[1]-x[0]))-curl[0][i]);
		                  my_bound.left[i].gamma=0.0;
		                  my_bound.left[i].kappa=1.0;
		                  my_bound.left[i].qset=0.0;
		                  // правая граница
		                  my_bound.right[i].FI_inf=curl[m+1][i]+alpha*((-7.0*psi[m+1][i]+8.0*psi[m][i]-psi[m-1][i])/(2.0*(x[m+1]-x[m])*(x[m+1]-x[m]))-curl[m+1][i]);
		                  my_bound.right[i].gamma=0.0;
		                  my_bound.right[i].kappa=1.0;
		                  my_bound.right[i].qset=0.0;
						 break;
				  }
	         }
			 break;

			 case RALEYBENAR_SYMMETRY:
				 // Задача лорда Релея.
				 for (int i = 1; i < m + 1; i++) {
					 switch (ischemeapprox) {
					 case TOMA: // условие Тома
						 // нижняя граница
						 my_bound.bottom[i].FI_inf = curl[i][0] + alpha * (2.0 * (psi[i][1] - psi[i][0]) / ((y[1] - y[0]) * (y[1] - y[0])) - curl[i][0]);
						 my_bound.bottom[i].gamma = 0.0;
						 my_bound.bottom[i].kappa = 1.0;
						 my_bound.bottom[i].qset = 0.0;
						 // верхняя граница
						 my_bound.top[i].FI_inf = curl[i][n + 1] + alpha * (2.0 * (psi[i][n] - psi[i][n + 1]) / ((y[n + 1] - y[n]) * (y[n + 1] - y[n])) - curl[i][n + 1]);
						 my_bound.top[i].gamma = 0.0;
						 my_bound.top[i].kappa = 1.0;
						 my_bound.top[i].qset = 0.0;
						 break;
					 case WOODS: // условие Вудса
						 // нижняя граница
						 my_bound.bottom[i].FI_inf = curl[i][0] + alpha * (-0.5 * curl[i][1] + 3.0 * (psi[i][0] - psi[i][1]) / ((y[1] - y[0]) * (y[1] - y[0])) - curl[i][0]);
						 my_bound.bottom[i].gamma = 0.0;
						 my_bound.bottom[i].kappa = 1.0;
						 my_bound.bottom[i].qset = 0.0;
						 // верхняя граница
						 my_bound.top[i].FI_inf = curl[i][n + 1] + alpha * (-0.5 * curl[i][n] + 3.0 * (psi[i][n + 1] - psi[i][n]) / ((y[n + 1] - y[n]) * (y[n + 1] - y[n])) - curl[i][n + 1]);
						 my_bound.top[i].gamma = 0.0;
						 my_bound.top[i].kappa = 1.0;
						 my_bound.top[i].qset = 0.0;
						 break;
					 case JENSEN: // условие Йенсена
						 // нижняя граница
						 my_bound.bottom[i].FI_inf = curl[i][0] + alpha * ((-7.0 * psi[i][0] + 8.0 * psi[i][1] - psi[i][2]) / (2.0 * (y[1] - y[0]) * (y[1] - y[0])) - curl[i][0]);
						 my_bound.bottom[i].gamma = 0.0;
						 my_bound.bottom[i].kappa = 1.0;
						 my_bound.bottom[i].qset = 0.0;
						 // верхняя граница
						 my_bound.top[i].FI_inf = curl[i][n + 1] + alpha * ((-7.0 * psi[i][n + 1] + 8.0 * psi[i][n] - psi[i][n - 1]) / (2.0 * (y[n + 1] - y[n]) * (y[n + 1] - y[n])) - curl[i][n + 1]);
						 my_bound.top[i].gamma = 0.0;
						 my_bound.top[i].kappa = 1.0;
						 my_bound.top[i].qset = 0.0;
						 break;
					 }

				 }
				 for (int i = 1; i < n + 1; i++) {
					 switch (ischemeapprox) {
					 case TOMA:  case WOODS: case JENSEN:
						 // Условие симметрии по бокам.
						  // левая граница
						 my_bound.left[i].FI_inf = 0.0;
						 my_bound.left[i].gamma = 0.0;
						 my_bound.left[i].kappa = 1.0;
						 my_bound.left[i].qset = 0.0;
						 // правая граница
						 my_bound.right[i].FI_inf = 0.0;
						 my_bound.right[i].gamma = 0.0;
						 my_bound.right[i].kappa = 1.0;
						 my_bound.right[i].qset = 0.0;
						 break;
					 
					 }
				 }
				 break;
	}

} // load_my_bound_curl


/* Находит обратную матрицу для
*  квадратной матрицы A nodes*nodes с
*  ненулевыми элементами на главной диагонали.
*  Решение производится путём метода исключения
*  Гаусса, а именно решая nodes СЛАУ.
*          A*inv=e
*  Приведение  к треугольному виду делается
*  только один раз.
* Если flag==true, то матрица уже приведена к верхнетреугольному виду.
*/
void inverse_matrix_simple(doublereal**& A, integer nodes, bool flag) {

	const doublereal epsilon = 1e-100;

	doublereal** e = nullptr; // единичная матрица правых частей.
	doublereal** inv = nullptr; // будущая обратная матрица

	doublereal** acopy = nullptr; // копия матрицы А

	acopy = new doublereal * [nodes];
	for (integer i1 = 0; i1 < nodes; i1++) acopy[i1] = new doublereal[nodes];


	if (acopy != nullptr) {

		integer i1 = 0, j1 = 0, k1 = 0;
		e = new doublereal * [nodes];
		for (i1 = 0; i1 < nodes; i1++) e[i1] = new doublereal[nodes];
		inv = new doublereal * [nodes];
		for (i1 = 0; i1 < nodes; i1++) inv[i1] = new doublereal[nodes];

		// инициализация
		for (i1 = 0; i1 < nodes; i1++) for (j1 = 0; j1 < nodes; j1++) {
			inv[i1][j1] = 0.0; // обратная матрица
			e[i1][j1] = 0.0; // правые части
			acopy[i1][j1] = A[i1][j1];
		}
		for (i1 = 0; i1 < nodes; i1++) e[i1][i1] = 1.0;




		if (!flag) { // если матрица ещё не приведена к верхнетреугольному виду
			doublereal M;
			// приведение к верхне треугольному виду:
			for (k1 = 0; k1 < nodes; k1++) {
				for (i1 = k1 + 1; i1 < nodes; i1++) {
					// Если на диагонали ноль:
					if (fabs(A[k1][k1]) < epsilon) {
						// решение не может быть получено, т.к.
						// на диагонали находится ноль.
						printf("\n inverse matrix simple ERROR !!! may be diagonal value is zero...\n");
						printf("\nSolution is not exist.\n");
						for (integer irow = 0; irow < nodes; irow++) {
							for (integer icol = 0; icol < nodes; icol++) {
								printf("%1.4e ", acopy[irow][icol]);
								//printf("%1.4e ", A[irow][icol]);

							}
							printf("\n");
						}
						//getchar();
						system("pause");
						exit(0);
					}
					M = A[i1][k1] / A[k1][k1];
					for (j1 = k1; j1 < nodes; j1++) {
						A[i1][j1] -= M * A[k1][j1];
					}
					// преобразование правых частей:
					for (j1 = 0; j1 < nodes; j1++) e[i1][j1] -= M * e[k1][j1];
				}
			}
		}
		doublereal* sum = nullptr;
		sum = new doublereal[nodes];

		// процесс обратного исключения
		for (i1 = nodes - 1; i1 >= 0; i1--) {
			// инициализация
			for (k1 = 0; k1 < nodes; k1++) sum[k1] = 0.0;

			for (j1 = i1 + 1; j1 < nodes; j1++) {
				for (k1 = 0; k1 < nodes; k1++) {
					sum[k1] += A[i1][j1] * inv[j1][k1];
				}
			}
			for (k1 = 0; k1 < nodes; k1++) {
				inv[i1][k1] = (e[i1][k1] - sum[k1]) / A[i1][i1];
			}
		}
		if (e != nullptr) {
			for (i1 = nodes - 1; i1 >= 0; i1--) {
				if (e[i1] != nullptr) {
					delete[] e[i1];
				}
			}
			delete[] e;
			e = nullptr;
		}



		for (k1 = 0; k1 < nodes; k1++) {
			for (i1 = 0; i1 < nodes; i1++) {
				A[k1][i1] = inv[k1][i1];
			}
		}
		if (inv != nullptr) {
			for (i1 = nodes - 1; i1 >= 0; i1--) {
				if (inv[i1] != nullptr) {
					delete[] inv[i1];
				}
			}
			delete[] inv;
			inv = nullptr;
		}

		if (acopy != nullptr) {
			for (i1 = nodes - 1; i1 >= 0; i1--) {
				if (acopy[i1] != nullptr) {
					delete[] acopy[i1];
				}
			}
			delete[] acopy;
			acopy = nullptr;
		}

		if (sum != nullptr) {
			delete[] sum;
		}
	}
	else {
		printf("no allocate memory for acopy\n");
		printf("in function inverse_matrix_simple\n");
		system("pause");
		exit(1);
	}
} // inverse_matrix_simple


// 15.05.2021
// Параллельная версия DTF на OpenMP.
// Проект -> Свойства -> C/C++ -> Язык -> поддержка OpenMP-> ДА (/openmp) включить
// сетка 1000*1000 узлов потребление памяти 101Мб, время нахождения решения 2с 775мс (2*intel xeon 2630v4 ).
// Работает только на равномерной сетке.
// Только с нулевыми граничными условиями Дирихле.
// Discret Furjer Transform stream function solver.
// Коэффициент диффузии всюду единица. Шаг сетки h1 может быть не равен шагу сеткии h2.
void DFTq(int m1, int n1, Real**& u, Real**& rthdsd) {

	// Замер времени.
	unsigned int calculation_start_time = 0; // начало счёта мс.
	unsigned int calculation_end_time = 0; // окончание счёта мс.
	unsigned int calculation_seach_time = 0; // время выполнения участка кода в мс.

	calculation_start_time = clock();

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1 = (Real)(lengthx / (m1 + 1));
	Real h2 = (Real)(lengthy / (n1 + 1));

	//  (0,Ny)==(0,n1+1)  
	//   ___________________ 
	//  |                  |
	//  |      fluid       |
	//  |__________________|
	//(0,0)              (Nx,0)==(m1+1,0)

	int Nx = m1 + 1; // < M+2
	int Ny = n1 + 1; // < N+2

	double** a = new double* [Nx + 1];
	double** b = new double* [Nx + 1];

	for (int i = 0; i < Nx + 1; i++) {
		a[i] = new double[Ny + 1];
		b[i] = new double[Ny + 1];
	}

#pragma omp parallel for
	for (int i = 0; i < Nx + 1; i++) {
		for (int j = 0; j < Ny + 1; j++) {
			a[i][j] = 0.0;
			b[i][j] = 0.0;
		}
	}

	

	//double maxr = -1.0e30;
	//double maxb = -1.0e30;

	int NxF = Nx;
	
#pragma omp parallel for
	for (int k = 1; k <= Nx - 1; k++) {
		for (int j = 1; j <= Ny - 1; j++) {
			// j
			b[k][j] = 0.0;
			for (int i = 1; i <= Nx - 1; i++) {
				b[k][j] +=  (2.0/Nx)* rthdsd[i][j] * sin(M_PI * k * i / Nx);
			}

			//b[k][j] /= ((M_PI * M_PI) / (2.0 * 2.0 * NxF * NxF));
			//b[k][j] /= ((M_PI * M_PI*k*k) / (1.0* lengthx * lengthx));
			//b[k][j] /= ((M_PI * M_PI*k*k ) / (1.0 * lengthx * lengthx));

		}
	}
	//std::cout << "maxb= " << maxb << "   maxr= " << maxr << std::endl;

	
	
	
		
#pragma omp parallel for
	for (int k = 1; k <= Nx - 1; k++) {

		double* P = new double[Ny + 1];
		double* Q = new double[Ny + 1];

		double beta = (h1 / h2), beta2 = beta * beta;

		// Для фиксированного k решение системы  с трёх диагональной матрицей:
		double b1 = beta2;
		double a1 = 2.0 + 2.0 * beta2 - 2.0 * cos(M_PI * k / Nx);
		P[1] = b1 / a1;
		double d1 = -h1 * h1 * b[k][1];
		Q[1] = d1 / a1;

		for (int i = 2; i <= Ny/*-1*/; i++) {
			double bi = beta2;
			double ci = beta2;
			double ai = 2.0 + 2.0 * beta2 - 2.0 * cos(M_PI * k / Nx);
			double di = -h1 * h1 * b[k][i];

			P[i] = bi / (ai - ci * P[i - 1]);
			Q[i] = (di + ci * Q[i - 1]) / (ai - ci * P[i - 1]);
		}
		a[k][Ny] = Q[Ny];
	
		for (int i = Ny - 1; i >= 1; i--) {
			a[k][i] = P[i] * a[k][i + 1] + Q[i];
		}

		delete[] P;
		delete[] Q;
	}

	
	


#pragma omp parallel for
	for (int i = 1; i <= Nx - 1; i++) {
		for (int j = 1; j <= Ny - 1; j++) {
			u[i][j] = 0.0;
			// j
			for (int k = 1; k <= Nx - 1; k++) {
				u[i][j] -= a[k][j] * sin(M_PI * k * i / Nx);
			}
		}
	}

	for (int i = 0; i < Nx + 1; i++) {
		delete[] a[i];
		delete[] b[i];
	}
	delete[] a;
	delete[] b;

	calculation_end_time = clock(); // момент начала счёта.
	calculation_seach_time += calculation_end_time - calculation_start_time;

	int im = 0, is = 0, ims = 0;
	im = (int)(calculation_seach_time / 60000); // минуты
	is = (int)((calculation_seach_time - 60000 * im) / 1000); // секунды
	ims = (int)((calculation_seach_time - 60000 * im - 1000 * is)); // /10 миллисекунды делённые на 10
	printf("DFT time %1d:%2d:%3d \n", im, is, ims);

}

// 13.05.2021
// Работает только на равномерной сетке.
// Только с нулевыми граничными условиями.
// Discret Furjer Transform stream function solver.
void DFT(int m1, int n1, Real**& u, Real**& rthdsd) {

	// Замер времени.
	unsigned int calculation_start_time = 0; // начало счёта мс.
	unsigned int calculation_end_time = 0; // окончание счёта мс.
	unsigned int calculation_seach_time = 0; // время выполнения участка кода в мс.

	calculation_start_time = clock();

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1 = (Real)(lengthx / (m1 + 1));
	Real h2 = (Real)(lengthy / (n1 + 1));

	int Nx = m1 + 1; // < M+2
	int Ny = n1 + 1; // < N+2

	double** a = new double*[Nx + 1];
	double** b = new double*[Nx + 1];

	for (int i = 0; i < Nx + 1; i++) {
		a[i] = new double[Ny + 1];
		b[i]= new double[Ny + 1];
	}

	for (int i = 0; i < Nx + 1; i++) {
		for (int j = 0; j < Ny + 1; j++) {
			a[i][j] = 0.0;
			b[i][j] = 0.0;
		}
	}

	//const double M_PI = 3.14159265;

	double maxr = -1.0e30;
	double maxb = -1.0e30;

	for (int k = 1; k <= Nx - 1; k++) {
		for (int j = 1; j <= Ny - 1; j++) {
			// j
			for (int i = 1; i <= Nx - 1; i++) {
				b[k][j] += ((M_PI *M_PI) / (2.0*2.0*Nx*Nx)) * rthdsd[i][j] * sin(M_PI*k*i/Nx);
			}
			if (b[k][j] > maxb) {
				maxb = b[k][j];
			}
			if (rthdsd[k][j] > maxr) {
				maxr = rthdsd[k][j];
			}
		}
	}
	std::cout << "maxb=" << maxb << "maxr" << maxr << std::endl;

	double* P = new double[Ny + 1];
	double* Q = new double[Ny + 1];
	double* S = new double[Ny + 1];
	double* y = new double[Ny + 1];
	double* z = new double[Ny + 1];
	
/*
	for (int k = 1; k <= Nx - 1; k++) {
		// Для фиксированного k решение системы  с трёх диагональной матрицей:
		double b1 = (h1 / h2) * (h1 / h2);
		double a1 = 2.0 - 2.0 * (h1 / h2) * (h1 / h2) + 2.0 * cos(M_PI * k / Nx);
		P[1] = b1 / a1;
		double d1 = h1 * h1 * b[k][1];
		Q[1] = d1 / a1;

		for (int i = 2; i <= Ny - 1; i++) {
			double bi = (h1 / h2) * (h1 / h2);
			double ci = (h1 / h2) * (h1 / h2);
			double ai = 2.0 - 2.0 * (h1 / h2) * (h1 / h2) + 2.0 * cos(M_PI * k / Nx);
			double di = h1 * h1 * b[k][i];
			P[i] = bi / (ai - ci * P[i - 1]);
			Q[i] = (di + ci * Q[i - 1]) / (a1 - ci * P[i - 1]);
		}
		//a[k][Ny] = 0.0;
		for (int i = Ny - 1; i >= 1; i--) {
			a[k][i] = P[i] * a[k][i + 1] + Q[i];
		}
	}
	*/

	// Верно.
	for (int k = 1; k <= Nx - 1; k++) {
		// Для фиксированного k решение системы  с трёх диагональной матрицей:
		double b1= (h1 / h2) * (h1 / h2);
		double a1 = 2.0 - 2.0 * (h1 / h2) * (h1 / h2) + 2.0 * cos(M_PI*k/Nx);
		P[1] = b1/a1; 
		double d1 = - h1 * h1 * b[k][1];
		Q[1] = d1 / a1;

		for (int i = 2; i <= Ny/*-1*/; i++) {
			double bi =  (h1 / h2) * (h1 / h2);
			double ci = (h1 / h2) * (h1 / h2);
			double ai = 2.0 - 2.0 * (h1 / h2) * (h1 / h2) + 2.0 * cos(M_PI * k / Nx);
			double di = - h1 * h1 * b[k][i];

			P[i] = bi/(ai-ci*P[i-1]);
			Q[i] = (di + ci*Q[i-1]) / (ai - ci * P[i - 1]);
		}
		a[k][Ny] = Q[Ny];
		/*double bend = (h1 / h2) * (h1 / h2);
		double cend = (h1 / h2) * (h1 / h2);
		double aend = 2.0 - 2.0 * (h1 / h2) * (h1 / h2) + 2.0 * cos(M_PI * k / Nx);
		double dend = -h1 * h1 * b[k][Ny-1];

		a[k][Ny - 1] = (dend + cend * Q[N - 1]) / (aend - cend * P[N - 1]);
		*/
		for (int i = Ny - 1; i >= 1; i--) {
			a[k][i] = P[i] * a[k][i + 1] + Q[i];
		}
	}
	
	/*
	int i_start = 1;
	int iend = Ny-1;
	// Циклическая прогонка из книжки Гарбера Г.З.
	for (int k = 1; k <= Nx - 1; k++) {
		// Для фиксированного k решение системы  с трёх диагональной матрицей:

		
		P[i_start] = 0.0;
		Q[i_start] = 0.0;
		S[i_start] = 1.0;

		for (int i = i_start+1; i <= Ny - 1; i++) {

			double bi = (h1 / h2) * (h1 / h2);
			double ci = (h1 / h2) * (h1 / h2);
			double ai = -2.0 + 2.0 * (h1 / h2) * (h1 / h2) + 2.0 * cos(M_PI * k / Nx);
			double di = h1 * h1 * b[k][i];
			P[i] = -bi / (ai + ci * P[i - 1]);
			Q[i] = (di - ci * Q[i - 1]) / (ai + ci * P[i - 1]);
			S[i] = -ci * S[i - 1] / (ai + ci * P[i - 1]);
		}
		//a[k][Ny] = 0.0;
		y[iend] = 0.0;
		z[iend] = 1.0;
		for (int i = iend; i >= 1; i--) {
			y[i - 1] = P[i] * y[i] + Q[i];
			z[i - 1] = P[i] * z[i] + S[i];
		}
		double b1 = (h1 / h2) * (h1 / h2);
		double c1 = (h1 / h2) * (h1 / h2);
		double a1 = -2.0 + 2.0 * (h1 / h2) * (h1 / h2) + 2.0 * cos(M_PI * k / Nx);
		double d1 = h1 * h1 * b[k][1];
		// 2->1, 1->0
		a[k][1] = (d1-c1*y[Ny-2]-b1*y[2]) / (a1+c1*z[Ny-2]+b1*z[2]);

		for (int i = 2; i <= Ny-1; i++) {
			a[k][i] = y[i] + a[k][1] * z[i];
		}
	}
	*/
	delete[] P;
	delete[] Q;
	delete[] S;
	delete[] y;
	delete[] z;

	for (int i = 1; i <= Nx - 1; i++) {
		for (int j = 1; j <= Ny - 1; j++) {
			u[i][j] = 0.0;
			// j
			for (int k = 1; k <= Nx - 1; k++) {
				u[i][j] +=  a[k][j] * sin(M_PI * k * i / Nx);
			}
		}
	}

	calculation_end_time = clock(); // момент начала счёта.
	calculation_seach_time += calculation_end_time - calculation_start_time;

	int im = 0, is = 0, ims = 0;
	im = (int)(calculation_seach_time / 60000); // минуты
	is = (int)((calculation_seach_time - 60000 * im) / 1000); // секунды
	ims = (int)((calculation_seach_time - 60000 * im - 1000 * is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

}

// 04.05.2021
// Работает только на равномерной сетке. Только с граничными условиями Дирихле.
// Только при h1=h2 в квадрате, с единичным коэффициентом диффузии.
void R_Bellman(int m1, int n1, Real**& u, Real**& rthdsd) {

	// Замер времени.
	unsigned int calculation_start_time=0; // начало счёта мс.
	unsigned int calculation_end_time=0; // окончание счёта мс.
	unsigned int calculation_seach_time=0; // время выполнения участка кода в мс.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1 = (Real)(lengthx / (m1 + 1));
	Real h2 = (Real)(lengthy / (n1 + 1));

	/*

	Нахождение обратной матрицы работает верно, проверено.
	// 04.05.2021
	
	double** AI1 = new double* [3];
	for (int i = 0; i < 3; i++) {
		AI1[i] = new double[3];
	}
	AI1[0][0] = 3;
	AI1[0][1] = 0;
	AI1[0][2] = 1;
	AI1[1][0] = 1;
	AI1[1][1] = 4;
	AI1[1][2] = 0;
	AI1[2][0] = 0;
	AI1[2][1] = 0;
	AI1[2][2] = 2;
	
	inverse_matrix_simple(AI1, 3, false);
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			std::cout << AI1[i][j] << " ";
		}
		std::cout << std::endl;
	}
	std::cout << std::endl;
	getchar();
	*/

	int m = m1 + 1;
	int n = n1 + 1;// вертикальная
	/*
	* Верная инициализация гран условий происходит в вызывающей функции.
	for (int i = 0; i <= m; i++) {
		for (int j = 0; j <= n; j++) {
			if (i == 0) {
				u[i][j] = 1.0;
			}
			else {
				u[i][j] = 0.0;
			}
		}
	}
	*/

	Real** Q = new Real*[n+1];
	for (int i = 0; i < n+1; i++) Q[i] = new Real[n+1];

	Real** rR = new Real*[m+1];
	for (int i = 0; i < m+1; i++) rR[i] = new Real[n+1];
	//Real* sR = new Real[m];

	Real** psiR = new Real * [m + 1];
	for (int i = 0; i < m + 1; i++) psiR[i] = new Real[n + 1];

	Real beta = (h1 / h2);
	Real beta2 = beta * beta;

	for (int i = 1; i <= n-1; i++) {
		for (int j = 1; j <= n-1; j++) {
			if (i == j) {
				Q[i][i] = 2.0* beta2;
			}
			else if (abs(i - j) == 1) {
				Q[i][j] = -1.0* beta2;
			}
			else {
				Q[i][j] = 0.0;
			}
		}
	}
	for (int R = 1; R <= m-1; R++) {
		//sR[R] = u[R][0] * u[R][0] + u[R][n] * u[R][n];
		for (int j = 1; j <= n-1; j++) {
			if (j == 1) {
				rR[R][j] = u[R][0];
			}
			else if (j == n-1) {
				rR[R][j] = u[R][n];
			}
			else rR[R][j] = 0.0;

			psiR[R][j] = rthdsd[R][j]*h1*h2*beta/*h2*h2/(3.14159*h1)*/;
		}
	}


	Real*** AR = new Real**[m+1];
	for (int i = 0; i <= m; i++) AR[i] = new Real*[n+1];
	for (int i = 0; i <= m; i++) {
		for (int j = 0; j <= n; j++) AR[i][j] = new Real[n+1];
	}
	Real** bR = new Real*[m+1];
	for (int i = 0; i <= m; i++) bR[i] = new Real[n+1];


	for (int i = 1; i <= n-1; i++) {
		bR[m][i] = u[m][i];
		for (int j = 1; j <= n-1; j++) {
			if (i == j) {
				AR[m][i][i] = 1.0;
			}
			else {
				AR[m][i][j] = 0.0;
			}
		}
	}


	Real** A = new Real*[n+1];
	for (int i = 0; i < n+1; i++) A[i] = new Real[n+1];
	Real* b = new Real[n+1];

	Real** AI = new Real * [n+1];
	for (int i = 0; i < n+1; i++) AI[i] = new Real[n+1];


	// Прямой ход.
	for (int k = m-1 ; k >= 1; k--) {

		for (int i = 1; i <= n-1; i++) {
			for (int j = 1; j <= n-1; j++) {
				if (i == j) {
					A[i][j] = 1.0 + Q[i][i] + AR[k + 1][i][j];
				}
				else {
					A[i][j]= Q[i][j] + AR[k + 1][i][j];
				}
			}
		}

		for (int i = 1; i <= n-1; i++) {
			for (int j = 1; j <= n-1; j++) {
				AI[i-1][j-1] = A[i][j];
			}
		}

		inverse_matrix_simple(AI, n - 1, false);

		for (int i = 1; i <= n-1; i++) {
			for (int j = 1; j <= n-1; j++) {
				if (i == j) {
					AR[k][i][j] = 1.0 - AI[i-1][j-1];
				}
				else {
					AR[k][i][j] = -AI[i-1][j-1];
				}
			}
		}

		calculation_start_time = clock(); // момент начала счёта.

		/*if (k == n - 1) {
			for (int i = 0; i <= n; i++) {
				b[i] = u[m][i];
			}
		}
		else {*/

			for (int i = 1; i <= n-1; i++) {
				b[i] = bR[k + 1][i] + rR[k][i] + psiR[k][i];
				
			}
		//}
		for (int i = 1; i <= n-1; i++) {
			bR[k][i] = 0;
		}


		for (int i = 1; i <= n-1; i++) {
			for (int j = 1; j <= n-1; j++) {
				bR[k][i] += AI[i-1][j-1] * b[j];
			}
		}
		calculation_end_time = clock(); // момент начала счёта.
		calculation_seach_time += calculation_end_time - calculation_start_time;
	}

	// Обратный проход.+
	calculation_start_time = clock(); // момент начала счёта.

	for (int k = 1; k <= m - 1; k++) {
		for (int i = 1; i <= n-1; i++) {
			for (int j = 1; j <= n-1; j++) {
				if (i == j) {
					A[i][j] = 1.0 -  AR[k][i][j];
				}
				else {
					A[i][j] = -AR[k][i][j];
				}
			}
		}

		for (int i = 1; i <= n-1; i++) {
				u[k][i] = 0.0;
				for (int j = 1; j <= n-1; j++) {
					u[k][i] += A[i][j] * u[k - 1][j];
				}
				u[k][i] += bR[k][i];
		}
	}
	calculation_end_time = clock(); // момент начала счёта.
	calculation_seach_time += calculation_end_time - calculation_start_time;

	int im = 0, is = 0, ims = 0;
	im = (int)(calculation_seach_time / 60000); // минуты
	is = (int)((calculation_seach_time - 60000 * im) / 1000); // секунды
	ims = (int)((calculation_seach_time - 60000 * im - 1000 * is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	for (int i = 0; i < n+1; i++) delete[] Q[i];
	delete[] Q;
	for (int i = 0; i < m+1; i++) delete[] rR[i];
	delete[] rR;
	//delete[] sR;
	for (int i = 0; i < m + 1; i++) delete[] psiR[i];
	delete[] psiR;

	for (int i = 0; i < m+1; i++) {
		for (int j = 0; j < n+1; j++) delete[] AR[i][j];
	}
	for (int i = 0; i < m+1; i++) delete[] AR[i];
	delete[] AR;
	for (int i = 0; i < m+1; i++) delete[] bR[i];
	delete[] bR;

	for (int i = 0; i < n+1; i++) delete[] A[i];
	delete[] A;
	for (int i = 0; i < n+1; i++) delete[] AI[i];
	delete[] AI;
	delete[] b;
}


bool bfirstBellman = true;
Real*** ARq = nullptr;


// 04.05.2021
// Работает только на равномерной сетке. Только с граничными условиями Дирихле.
// Только при h1=h2 в квадрате, с единичным коэффициентом диффузии.
void R_Bellmanq(int m1, int n1, Real**& u, Real**& rthdsd) {

	/*

	Нахождение обратной матрицы работает верно, проверено.
	// 04.05.2021

	double** AI1 = new double* [3];
	for (int i = 0; i < 3; i++) {
		AI1[i] = new double[3];
	}
	AI1[0][0] = 3;
	AI1[0][1] = 0;
	AI1[0][2] = 1;
	AI1[1][0] = 1;
	AI1[1][1] = 4;
	AI1[1][2] = 0;
	AI1[2][0] = 0;
	AI1[2][1] = 0;
	AI1[2][2] = 2;

	inverse_matrix_simple(AI1, 3, false);
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			std::cout << AI1[i][j] << " ";
		}
		std::cout << std::endl;
	}
	std::cout << std::endl;
	getchar();
	*/

	int m = m1 + 1;
	int n = n1 + 1;// вертикальная
	/*
	* Верная инициализация гран условий происходит в вызывающей функции.
	for (int i = 0; i <= m; i++) {
		for (int j = 0; j <= n; j++) {
			if (i == 0) {
				u[i][j] = 1.0;
			}
			else {
				u[i][j] = 0.0;
			}
		}
	}
	*/

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1 = (Real)(lengthx / (m1 + 1));
	Real h2 = (Real)(lengthy / (n1 + 1));

	Real** Q;
	if (bfirstBellman) {
		Q = new Real * [n + 1];
		for (int i = 0; i < n + 1; i++) Q[i] = new Real[n + 1];
	}

	Real** rR = new Real * [m + 1];
	for (int i = 0; i < m + 1; i++) rR[i] = new Real[n + 1];
	//Real* sR = new Real[n];

	Real** psiR = new Real * [m + 1];
	for (int i = 0; i < m + 1; i++) psiR[i] = new Real[n + 1];


	Real beta = (h1 / h2);
	Real beta2 = beta * beta;

	if (bfirstBellman) {
		for (int i = 1; i <= n - 1; i++) {
			for (int j = 1; j <= n - 1; j++) {
				if (i == j) {
					Q[i][i] = 2.0* beta2;
				}
				else if (abs(i - j) == 1) {
					Q[i][j] = -1.0* beta2;
				}
				else {
					Q[i][j] = 0.0;
				}
			}
		}
	}
	for (int R = 1; R <= m - 1; R++) {
		//sR[R] = u[R][0] * u[R][0] + u[R][n] * u[R][n];
		for (int j = 1; j <= n - 1; j++) {
			if (j == 1) {
				rR[R][j] = u[R][0];
			}
			else if (j == n - 1) {
				rR[R][j] = u[R][n];
			}
			else rR[R][j] = 0.0;

			psiR[R][j] = rthdsd[R][j]*h1*h2*beta;
		}
	}


	if (bfirstBellman) {
		ARq = new Real**[m + 1];
		for (int i = 0; i <= m; i++) ARq[i] = new Real*[n + 1];
		for (int i = 0; i <= m; i++) {
			for (int j = 0; j <= n; j++) ARq[i][j] = new Real[n + 1];
		}
	}
		
	Real** bR = new Real*[m + 1];
	for (int i = 0; i <= m; i++) bR[i] = new Real[n + 1];


	for (int i = 1; i <= n - 1; i++) {
		bR[m][i] = u[m][i];
	}
	

	if (bfirstBellman) {
	    for (int i = 1; i <= n - 1; i++) {
			for (int j = 1; j <= n - 1; j++) {
				if (i == j) {
					ARq[m][i][i] = 1.0;
				}
				else {
					ARq[m][i][j] = 0.0;
				}
			}
		}
	}


	Real** A = new Real*[n + 1];
	for (int i = 0; i < n + 1; i++) A[i] = new Real[n + 1];
	Real* b = new Real[n + 1];

	Real** AI = new Real*[n + 1];
	for (int i = 0; i < n + 1; i++) AI[i] = new Real[n + 1];


	// Прямой ход.
	for (int k = m - 1; k >= 1; k--) {

		if (bfirstBellman) {
			for (int i = 1; i <= n - 1; i++) {
				for (int j = 1; j <= n - 1; j++) {
					if (i == j) {
						A[i][j] = 1.0 + Q[i][i] + ARq[k + 1][i][j];
					}
					else {
						A[i][j] = Q[i][j] + ARq[k + 1][i][j];
					}
				}
			}

			for (int i = 1; i <= n - 1; i++) {
				for (int j = 1; j <= n - 1; j++) {
					AI[i - 1][j - 1] = A[i][j];
				}
			}

			inverse_matrix_simple(AI, n - 1, false);

			for (int i = 1; i <= n - 1; i++) {
				for (int j = 1; j <= n - 1; j++) {
					if (i == j) {
						ARq[k][i][j] = 1.0 - AI[i - 1][j - 1];
					}
					else {
						ARq[k][i][j] = -AI[i - 1][j - 1];
					}
				}
			}
		}
		else {
#pragma omp parallel for
			for (int i = 1; i <= n - 1; i++) {
				for (int j = 1; j <= n - 1; j++) {
					AI[i - 1][j - 1] = -ARq[k][i][j];
				}
			}

#pragma omp parallel for
			for (int i = 0; i <= n - 2; i++) AI[i][i]+= 1.0;
		}

		
#pragma omp parallel for
		for (int i = 1; i <= n - 1; i++)
		{
			b[i] = bR[k + 1][i] + rR[k][i] + psiR[k][i];
		}

#pragma omp parallel for
		for (int i = 1; i <= n - 1; i++) 
		{
			bR[k][i] = 0;
			const int iminus1 = i - 1;

			for (int j = 1; j <= n - 1; j++) {
				bR[k][i] += AI[iminus1][j - 1] * b[j];
			}
		}
	}

	// Обратный проход.+
	for (int k = 1; k <= m - 1; k++) {

#pragma omp parallel for
		for (int i = 1; i <= n - 1; i++) {
			for (int j = 1; j <= n - 1; j++) {
				A[i][j] = -ARq[k][i][j];
			}
		}

#pragma omp parallel for
		for (int i = 1; i <= n - 1; i++) {
			A[i][i] += 1.0;
		}

#pragma omp parallel for
		for (int i = 1; i <= n - 1; i++) {
			u[k][i] = bR[k][i];
			for (int j = 1; j <= n - 1; j++) {
				u[k][i] += A[i][j] * u[k - 1][j];
			}
		}
	}

	if (bfirstBellman) {
		for (int i = 0; i < n + 1; i++) delete[] Q[i];
		delete[] Q;
	}
	for (int i = 0; i < m + 1; i++) delete[] rR[i];
	delete[] rR;
	//delete[] sR;
	for (int i = 0; i < m + 1; i++) delete[] psiR[i];
	delete[] psiR;

	/*
	for (int i = 0; i < m + 1; i++) {
		for (int j = 0; j < n + 1; j++) delete[] ARq[i][j];
	}
	for (int i = 0; i < m + 1; i++) delete[] ARq[i];
	delete[] ARq;
	*/
	for (int i = 0; i < m + 1; i++) delete[] bR[i];
	delete[] bR;	

	for (int i = 0; i < n + 1; i++) {
		delete[] A[i];
	}
	delete[] A;
	for (int i = 0; i < n + 1; i++) {
		delete[] AI[i];
	}
	delete[] AI;
	delete[] b;

	bfirstBellman = false;
}



// Преобразует путём сплайновой интерполяции значения с грубой сетки
// на подробную для всех подробных точек.
// возврааемое значение f_fine[0..m+1][0..n+1]
void my_splain_interpol_func_table2(int m, int n, int mc, int nc, // c - coarse
	Real* xc, Real* yc, Real* xf, Real* yf, // c - coarse, f - fine
	Real** f_coarse, Real**& f_fine);

// усредняет невязку по ближайшему постранственному окружению.
// вычисляет среднее по объёму значение.
Real resavgVol(Real**& r, Real* x, Real* y, int m, int n,
	int idist, int ip, int jp) {

	//Real rcol=0.0;
	Real rsVol = 0.0;
	Real rsum = 0.0;

	for (int i = 0; i < m + 2; i++) {
		for (int j = 0; j < n + 2; j++) {
			if ((i >= ip - idist) && (i <= ip + idist) && (j >= jp - idist) && (j <= jp + idist)) {
				Real rVol = 0.0;
				if ((i > 0) && (j > 0) && (i < m + 1) && (j < n + 1))
				{
					rVol = 0.25 * (x[i + 1] - x[i - 1]) * (y[j + 1] - y[j - 1]);
				}
				else if (i == 0) {
					if ((j > 0) && (j < n + 1)) {
						rVol = 0.25 * (x[i + 1] - x[i]) * (y[j + 1] - y[j - 1]);
					}
					else if (j == 0) {
						rVol = 0.25 * (x[i + 1] - x[i]) * (y[j + 1] - y[j]);
					}
					else if (j == n + 1) {
						rVol = 0.25 * (x[i + 1] - x[i]) * (y[j] - y[j - 1]);
					}
				}
				else if (i == m + 1) {
					if ((j > 0) && (j < n + 1)) {
						rVol = 0.25 * (x[i] - x[i - 1]) * (y[j + 1] - y[j - 1]);
					}
					else if (j == 0) {
						rVol = 0.25 * (x[i] - x[i - 1]) * (y[j + 1] - y[j]);
					}
					else if (j == n + 1) {
						rVol = 0.25 * (x[i] - x[i - 1]) * (y[j] - y[j - 1]);
					}
				}
				else if (j == 0) {
					if ((i > 0) && (i < m + 1)) {
						rVol = 0.25 * (x[i + 1] - x[i - 1]) * (y[j + 1] - y[j]);
					}
					else if (i == 0) {
						rVol = 0.25 * (x[i + 1] - x[i]) * (y[j + 1] - y[j]);
					}
					else if (i == m + 1) {
						rVol = 0.25 * (x[i] - x[i - 1]) * (y[j + 1] - y[j]);
					}
				}
				else if (j == n + 1) {
					if ((i > 0) && (i < m + 1)) {
						rVol = 0.25 * (x[i + 1] - x[i - 1]) * (y[j] - y[j - 1]);
					}
					else if (i == 0) {
						rVol = 0.25 * (x[i + 1] - x[i]) * (y[j] - y[j - 1]);
					}
					else if (i == m + 1) {
						rVol = 0.25 * (x[i] - x[i - 1]) * (y[j] - y[j - 1]);
					}
				}
				rsVol += rVol;
				rsum += r[i][j] * rVol;
				//rcol+=1.0;
			}
		}
	}

	rsum = rsum / rsVol;

	return rsum; // среднее значение.
} // resavgVol

void my_restriction1(Real**& r, Real**& r_coarse,
	int m, int n) {

	int ic = 0, jc = 0; // c- coarse.

	for (int i = 0; i < m + 2; i++) {
		for (int j = 0; j < n + 2; j++) {
			if ((i % q == 0) && (j % q == 0)) {
				ic = (int)(i / q);
				jc = (int)(j / q);
				//printf("%d,%d",ic,jc);
				//getchar();

				r_coarse[ic][jc] = r[i][j];

			}
		}
	}

} // RESTRICTION

// Берёт среднюю невязку.
// Усреднение по объёму.
void my_restriction2(Real**& r, Real**& r_coarse,
	Real* x, Real* y, int m, int n) {

	int idist = (int)(floor(0.5 * q)); // наибольшее целое число в формате Real, не превосходящее x=0.5*q;

	int ic = 0, jc = 0; // c- coarse.

	for (int i = 0; i < m + 2; i++) {
		for (int j = 0; j < n + 2; j++) {
			if ((i % q == 0) && (j % q == 0)) {
				ic = (int)(i / q);
				jc = (int)(j / q);

				r_coarse[ic][jc] = resavgVol(r, x, y, m, n, idist, i, j);

			}
		}
	}

} // RESTRICTION

// 17 мая 2013
// ВНИМАНИЕ !!! только для q==5 и idist=2;
// препроцессинг для операции restriction AVGR
// усредняет невязку по ближайшему постранственному окружению.
// вычисляет среднее по объёму значение.
void resavgVolpreprocessing(Real* x, Real* y, int m, int n,
	int idist, int ip, int jp, RESTRICT_AVG_S& myrq) {


	for (int i = ip - idist; i <= ip + idist; i++) {
		for (int j = jp - idist; j <= jp + idist; j++) {

			int ipos = i - (ip - idist);
			int jpos = j - (jp - idist);

			if ((i >= 0) && (i <= m + 1) && (j >= 0) && (j <= n + 1)) {

#if MY_FLOAT

				myrq.Vol[ipos][jpos] = 0.0f;
				if ((i > 0) && (j > 0) && (i < m + 1) && (j < n + 1))
				{
					myrq.Vol[ipos][jpos] = 0.25f * (x[i + 1] - x[i - 1]) * (y[j + 1] - y[j - 1]);
				}
				else if (i == 0) {
					if ((j > 0) && (j < n + 1)) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i + 1] - x[i]) * (y[j + 1] - y[j - 1]);
					}
					else if (j == 0) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i + 1] - x[i]) * (y[j + 1] - y[j]);
					}
					else if (j == n + 1) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i + 1] - x[i]) * (y[j] - y[j - 1]);
					}
				}
				else if (i == m + 1) {
					if ((j > 0) && (j < n + 1)) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i] - x[i - 1]) * (y[j + 1] - y[j - 1]);
					}
					else if (j == 0) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i] - x[i - 1]) * (y[j + 1] - y[j]);
					}
					else if (j == n + 1) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i] - x[i - 1]) * (y[j] - y[j - 1]);
					}
				}
				else if (j == 0) {
					if ((i > 0) && (i < m + 1)) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i + 1] - x[i - 1]) * (y[j + 1] - y[j]);
					}
					else if (i == 0) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i + 1] - x[i]) * (y[j + 1] - y[j]);
					}
					else if (i == m + 1) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i] - x[i - 1]) * (y[j + 1] - y[j]);
					}
				}
				else if (j == n + 1) {
					if ((i > 0) && (i < m + 1)) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i + 1] - x[i - 1]) * (y[j] - y[j - 1]);
					}
					else if (i == 0) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i + 1] - x[i]) * (y[j] - y[j - 1]);
					}
					else if (i == m + 1) {
						myrq.Vol[ipos][jpos] = 0.25f * (x[i] - x[i - 1]) * (y[j] - y[j - 1]);
					}
				}
				myrq.SumVol += myrq.Vol[ipos][jpos];
				myrq.ix[ipos][jpos] = i;
				myrq.iy[ipos][jpos] = j;

#else

				myrq.Vol[ipos][jpos] = 0.0;
				if ((i > 0) && (j > 0) && (i < m + 1) && (j < n + 1))
				{
					myrq.Vol[ipos][jpos] = 0.25 * (x[i + 1] - x[i - 1]) * (y[j + 1] - y[j - 1]);
				}
				else if (i == 0) {
					if ((j > 0) && (j < n + 1)) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i + 1] - x[i]) * (y[j + 1] - y[j - 1]);
					}
					else if (j == 0) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i + 1] - x[i]) * (y[j + 1] - y[j]);
					}
					else if (j == n + 1) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i + 1] - x[i]) * (y[j] - y[j - 1]);
					}
				}
				else if (i == m + 1) {
					if ((j > 0) && (j < n + 1)) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i] - x[i - 1]) * (y[j + 1] - y[j - 1]);
					}
					else if (j == 0) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i] - x[i - 1]) * (y[j + 1] - y[j]);
					}
					else if (j == n + 1) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i] - x[i - 1]) * (y[j] - y[j - 1]);
					}
				}
				else if (j == 0) {
					if ((i > 0) && (i < m + 1)) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i + 1] - x[i - 1]) * (y[j + 1] - y[j]);
					}
					else if (i == 0) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i + 1] - x[i]) * (y[j + 1] - y[j]);
					}
					else if (i == m + 1) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i] - x[i - 1]) * (y[j + 1] - y[j]);
					}
				}
				else if (j == n + 1) {
					if ((i > 0) && (i < m + 1)) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i + 1] - x[i - 1]) * (y[j] - y[j - 1]);
					}
					else if (i == 0) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i + 1] - x[i]) * (y[j] - y[j - 1]);
					}
					else if (i == m + 1) {
						myrq.Vol[ipos][jpos] = 0.25 * (x[i] - x[i - 1]) * (y[j] - y[j - 1]);
					}
				}
				myrq.SumVol += myrq.Vol[ipos][jpos];
				myrq.ix[ipos][jpos] = i;
				myrq.iy[ipos][jpos] = j;
#endif
			}
		}
	}

} // resavgVolpreprocesing

// 17 мая 2013
// ВНИМАНИЕ !!! только для q==5 и idist=2;
// Берёт среднюю невязку.
// Усреднение по объёму.
// На основе процедуры препроцессинга, для ускорения вычислений.
void my_restriction3(Real**& r, Real**& r_coarse,
	int mc, int nc, RESTRICT_AVG_S** myrq) {

	for (int i = 0; i < mc + 2; i++) {
		for (int j = 0; j < nc + 2; j++) {

#if MY_FLOAT
			Real rsum = 0.0f;
#else
			Real rsum = 0.0;
#endif

			// Вспомогательная сумма из 25 значений.
			for (int i1 = 0; i1 < 5; i1++) {
				for (int j1 = 0; j1 < 5; j1++) {
					rsum += r[myrq[i][j].ix[i1][j1]][myrq[i][j].iy[i1][j1]] * myrq[i][j].Vol[i1][j1];
				}
			}

			r_coarse[i][j] = rsum / myrq[i][j].SumVol;

		}
	}

} // RESTRICTION


// Алгоритм Р.П. Федоренко 1961.
int itsolve_Fedor(Real**& u, Real**& u_old, Real**& r, Real**& rthdsd,
	int m, int n,
	Real**& v, Real**& v_old, Real**& r_coarse, Real**& rthdsd_c,
	int mc, int nc, int ialg, MATRNODE**& A, MATRNODE**& Al,
	Real epsilon, Real*& residual_history) {

	// epsilon - точность с которой решается уравнение.
	int irestriction_type = AVGRP;// AVGRP; // STANDART AVGR AVGRP
	int idist = (int)(floor(0.5 * q)); // наибольшее целое число в формате Real, не превосходящее x=0.5*q;

	 // инициализировано без релаксации.
	Real URF = 1.0; // параметр релаксации на подробной сетке.
	Real URFl = 1.0; // оптимальный параметр релаксации на грубой сетке.
	if (ialg == SORDIRICHLET) {
		// постоянные шаги сетки h1 по оси x и h2 по оси y.
		// Real h1=(Real)(lengthx/(m+1));
		// Real h2=(Real)(lengthy/(n+1));
		// Внимание оптимальный параметр релаксации верен только в случае краевых условий Дирихле.
		//const Real M_PI = 3.1415; // Число ПИ.
		//Real b=0.5*cos(MPI*h1)+0.5*cos(MPI*h2);
		Real b = 0.5 * cos(M_PI / (m + 1)) + 0.5 * cos(M_PI / (n + 1));
		URF = 2.0 / (1.0 + sqrt(1.0 - b * b)); // Оптимальный параметр верхней релаксации для граничных условий Дирихле.
		// см. Е.Н.Бондарев, А.С.Кокорев МАИ Численные методы решения уравнений Навье-Стокса М. 1992.
		// Оптимальное значение коэффициента релаксации известно лишь для прямоугольной области и граничных условий Дирихле.
		// Чтобы узнать оптимальное значение параметра релаксации нужно знать : уравнение, форму области, сетку.
		// Т.е. спектральные характеристики матрицы. 
		// Данное значение параметра релаксации подходит лишь для решения уравнения типа уравнения для функции тока (коэффициент диффузии 1.0)
		// граничные условия Дирихле.
		Real bl = 0.5 * cos(M_PI / (mc + 1)) + 0.5 * cos(M_PI / (nc + 1));
		URFl = 2.0 / (1.0 + sqrt(1.0 - bl * bl)); // Оптимальный параметр верхней релаксации для граничных условий Дирихле.
		//printf("URF=%e, URFl=%e\n",URF,URFl);
		//getchar();
	}

	Real** ksi;
	Real** etta;
	Real** gamma;
	Real** d;
	Real theta; // параметр в диапазоне от нуля до 1.0
	Real** ksil;
	Real** ettal;
	Real** gammal;
	Real** dl;
	Real thetal;

	if (ialg == ZVER) {
		// Выделение оперативной памяти.
		my_alloc_zver(ksi, etta, gamma, d, m, n);
		theta = 1.0;
		// Тоже самое для грубой сетки.
		my_alloc_zver(ksil, ettal, gammal, dl, mc, nc);
		thetal = 1.0;
	}

	// проинтерполированное значение v на подробную сетку.
	Real** v_fine = new Real * [m + 2];
	for (int i = 0; i < m + 2; i++) v_fine[i] = new Real[n + 2];

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1 = (Real)(lengthx / (M + 1));
	Real h2 = (Real)(lengthy / (N + 1));
	// Координаты узлов для интерполляции.
	Real* xf = new Real[m + 2];
	Real* xc = new Real[mc + 2];
	int ic = 0;
	for (int i = 0; i < m + 2; i++) {
		xf[i] = (Real)(i * h1);
		if (i % q == 0) {
			xc[ic] = (Real)(ic * h1 * q);
			ic++;
		}
	}
	Real* yf = new Real[n + 2];
	Real* yc = new Real[nc + 2];
	ic = 0;
	for (int i = 0; i < n + 2; i++) {
		yf[i] = (Real)(i * h2);
		if (i % q == 0) {
			yc[ic] = (Real)(ic * h2 * q);
			ic++;
		}
	}

	//printf(" iter  residual\n");

	// Вспомогательные данные для операции проецирования 
	// с подробной сетки на грубую.
	RESTRICT_AVG_S** myrq = new RESTRICT_AVG_S * [mc + 2];
	for (int i = 0; i < mc + 2; i++) {
		myrq[i] = new RESTRICT_AVG_S[nc + 2];
	}
	// инициализация !
#if MY_FLOAT
	for (int i1 = 0; i1 < mc + 2; i1++) {
		for (int j1 = 0; j1 < nc + 2; j1++) {
			myrq[i1][j1].SumVol = 0.0f;
			for (int i = 0; i < 5; i++) {
				for (int j = 0; j < 5; j++) {
					myrq[i1][j1].ix[i][j] = 0;
					myrq[i1][j1].iy[i][j] = 0;
					myrq[i1][j1].Vol[i][j] = 0.0f;
				}
			}
		}
	}
#else
	for (int i1 = 0; i1 < mc + 2; i1++) {
		for (int j1 = 0; j1 < nc + 2; j1++) {
			myrq[i1][j1].SumVol = 0.0;
			for (int i = 0; i < 5; i++) {
				for (int j = 0; j < 5; j++) {
					myrq[i1][j1].ix[i][j] = 0;
					myrq[i1][j1].iy[i][j] = 0;
					myrq[i1][j1].Vol[i][j] = 0.0;
				}
			}
		}
	}
#endif



	// Сам препроцессинг.
	for (int i = 0; i < mc + 2; i++) {
		for (int j = 0; j < nc + 2; j++) {
			resavgVolpreprocessing(xf, yf, m, n, idist, i * q, j * q, myrq[i][j]);
		}
	}

	for (int i = 0; i < mc + 2; i++) {
		for (int j = 0; j < nc + 2; j++) {
			v_fine[i][j]=0.0;
		}
	}



	Real norm = 10.0;
	int it = 1; // счётчик количества итераций
	int i = 0;
	while ((i < 300/*37*/) && (norm > epsilon)) {
		i++;

		int iend = 7; // число итераций сглаживающего метода
		switch (ialg) {
		case STANDART: iend = 4; break;
		case SEIDEL: iend = 4; break;
		case LR: iend = 2; break; // Оптимальное на сетке 50x50 q5 значение 2. 
		case SORDIRICHLET: iend = 4; break;
		case ZVER: iend = 2; break; // Оптимальное на сетке 50x50 q5 значение 2. 
		}

		/* Мысли. Как видно из эксперимента ZVER в качестве базового метода для алгоритма Федоренко уступает полинейному методу
		* в качестве базового в алгоритме Федоренко. Безусловно применение данных методов в сочеании с алгоритмом Федоренко даёт
		* более быструю сходимость по сравнению со случает когда алгоритмы ZVER и LR применяются отдельно без алгоритма Федоренко.
		* То что алгоритм ZVER уступает алгоритму LR когда они применяются внутри алгоритма Федоренко возможно из-за того что в алгоритме
		* ZVER ослаблен диагональный член и усредняющее (сглаживающее) действие алгоритма ZVER хуже чем сглаживающее действие алгоритма LR
		* (т.к. в алгоритме LR очень большая главная диагональ).
		* Однако если применять методы LR и ZVER без связки с идеей Федоренко то алгоритм ZVER очень сильно выигрывает на SPD задачах у алгоритма LR.
		*/

		// PRE SMOOTING and POST SMOOTING
		for (int j = 0; j < iend; j++) {
			switch (ialg) {
			case STANDART: solve(0.125, u, u_old, rthdsd, A, m, n); break;
			case SEIDEL: // запоминаем поле с предыдущей итерации.
						  // данный итерационный процесс не требует в два раза больше памяти.
				for (int i1 = 0; i1 < m + 2; i1++) {
					for (int j1 = 0; j1 < n + 2; j1++) {
						u_old[i1][j1] = u[i1][j1];
					}
				}
				Seidel(u, rthdsd, A, m, n);
				break;
			case LR: // запоминаем поле с предыдущей итерации.
				 // данный итерационный процесс не требует в два раза больше памяти.
				for (int i1 = 0; i1 < m + 2; i1++) {
					for (int j1 = 0; j1 < n + 2; j1++) {
						u_old[i1][j1] = u[i1][j1];
					}
				}
				LRsolve(u, rthdsd, A, m, n); break;
			case SORDIRICHLET: for (int i1 = 0; i1 < m + 2; i1++) {
				for (int j1 = 0; j1 < n + 2; j1++) {
					u_old[i1][j1] = u[i1][j1];
				}
			}
							 // Метод верхней релаксации только в случае условий Дирихле 
							 // С оптимальным параметром релаксации.
							 // Подходит только для функции тока и более не для чего.
							 SORDirichlet(u, rthdsd, A, URF, m, n);
							 break;
			case ZVER: // запоминаем поле с предыдущей итерации.
						// данный итерационный процесс требует в два раза больше памяти.
				for (int i1 = 0; i1 < m + 2; i1++) {
					for (int j1 = 0; j1 < n + 2; j1++) {
						u_old[i1][j1] = u[i1][j1];
					}
				}
				ZVERsolve(u, rthdsd, A, ksi, etta, gamma, d, theta, m, n);
				break;
			default: solve(0.125, u, u_old, rthdsd, A, m, n); break;
			}
			//residual(r, u_old, rthdsd, A, m, n);
			residual(r, u, rthdsd, A, m, n);
			norm = normar(r, m, n);
			residual_history[it - 1] = norm;
			//printf("  %d   %1.4e  \n",it,norm);
			it++;
		}
		//printf("u");
		//exporttecplot(u, xf, yf, m, n);
		//getchar();
		//printf("r");
		//exporttecplot(r, xf, yf,  m,  n);
		//getchar();
		// Решение вспомогательной системы на грубой сетке.
		//if (i%2==0) printf(" iter  residual\n");
		//exporttecplot(r, xf, yf,  m,  n);


		// RESTRICTION
		switch (irestriction_type) {
		case STANDART: my_restriction1(r, r_coarse, m, n); break; // просто взяты значения в совподающих узлах.
		case AVGR: my_restriction2(r, r_coarse, xf, yf, m, n); break; // на основе осреднённого значения сходится лучше.
		case AVGRP: my_restriction3(r, r_coarse, mc, nc, myrq); break; // на основе осреднённого значения сходится лучше. Тяжёловесные операции вынесены в стадию препроцессинга.
		}

		//printf("r_coarse");
		//exporttecplot(r_coarse, xc, yc, mc, nc);
		//getchar();

		//exporttecplot(r_coarse, xc, yc,  mc,  nc);
		norm = normar(r_coarse, mc, nc);
		//printf("  restriction norm =  %1.4e  \n",norm);
		//getchar();
		// INIT COARSE
		// Для вспомогательной системы имеем однородные граничные условия.
		my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, mc, nc);
		// вычисление правой части
		// для вспомогательной системы.
		for (int i1 = 0; i1 < mc + 2; i1++) {
			for (int j1 = 0; j1 < nc + 2; j1++) {
				//rthdsd_c[i1][j1]=q*q*r_coarse[i1][j1]; при h1==h2==1.0 в версии Fedorenko1
				rthdsd_c[i1][j1] = -r_coarse[i1][j1]; // именно минус, т.к. мы следуем записи дискретного аналога по Патанкару.

				//rthdsd_c[i1][j1] = -r_coarse[i1][j1];

				// Мы решаем вспомогательную СЛАУ с невязкой в качестве правой части. Данный факт не зависит от способа получения СЛАУ.
				// Это может быть метод контрольного объёма или метод конечных разностей.

			}
		}

		// Однородные граничные условия !!!!!!
		constrrthdsdzero(rthdsd_c, mc, nc); // однородные граничные условия !!!


		int iend2 = q * q; // число итераций сглаживающего метода
		//Сходимость метода Зейделя в два раза более быстрая чем у стандартного метода.
		// Сходимость полинейного метода в два раза более быстрая чем у Зейделя, однако он
		// требует на одну итерацию существенно больше флопов.
		switch (ialg) {
		case STANDART: iend2 = q * q; break;
		case SEIDEL: iend2 = (int)(floor(0.5 * q * q)); break;
		case LR: iend2 = (int)(floor(0.25 * q * q)); break;
		case SORDIRICHLET: iend2 = (int)(floor(0.5 * q * q)); break;
		case ZVER: iend2 = (int)(floor(0.25 * q * q)); break; // Алгоритм В.Г. Зверева.
		}

		// решение вспомогательной СЛАУ.
		for (int j = 0; j <  iend2; j++) {
			switch (ialg) {
			case STANDART: solve(0.125, v, v_old, rthdsd_c, Al, mc, nc); break;
			case SEIDEL: // запоминаем поле с предыдущей итерации.
						  // данный итерационный процесс не требует в два раза больше памяти.
				for (int i1 = 0; i1 < mc + 2; i1++) {
					for (int j1 = 0; j1 < nc + 2; j1++) {
						v_old[i1][j1] = v[i1][j1];
						v[i1][j1] = 0.0;//Начинаем с нулевого приближения
					}
				}
				Seidel(v, rthdsd_c, Al, mc, nc);
				break;
			case LR: // запоминаем поле с предыдущей итерации.
					  // данный итерационный процесс не требует в два раза больше памяти.
				for (int i1 = 0; i1 < mc + 2; i1++) {
					for (int j1 = 0; j1 < nc + 2; j1++) {
						v_old[i1][j1] = v[i1][j1];
					}
				}
				LRsolve(v, rthdsd_c, Al, mc, nc);
				break;
			case SORDIRICHLET: for (int i1 = 0; i1 < mc + 2; i1++) {
				for (int j1 = 0; j1 < nc + 2; j1++) {
					v_old[i1][j1] = v[i1][j1];
				}
			}
							 // Метод верхней релаксации только в случае условий Дирихле 
							 // С оптимальным параметром релаксации.
							 // Подходит только для функции тока и более не для чего.
							 SORDirichlet(v, rthdsd_c, Al, URFl, mc, nc);
							 break;
			case ZVER: // запоминаем поле с предыдущей итерации.
						 // данный итерационный процесс требует в два раза больше памяти.
				for (int i1 = 0; i1 < mc + 2; i1++) {
					for (int j1 = 0; j1 < nc + 2; j1++) {
						v_old[i1][j1] = v[i1][j1];
					}
				}
				ZVERsolve(v, rthdsd_c, Al, ksil, ettal, gammal, dl, thetal, mc, nc);
				break;
			default: solve(0.125, v, v_old, rthdsd_c, Al, mc, nc); break;
			}
			residual(r_coarse, v, rthdsd_c, Al, mc, nc);
			norm = normar(r_coarse, mc, nc);
			//printf("  %d   %1.4e  \n",it++,norm);
		}
		//getchar();

		//printf("v");
		//exporttecplot(v, xc, yc, mc, nc);
		//getchar();

		// проинтерполлировать v на подробную сетку (v_fine) (например с помощью сплайна)
		my_splain_interpol_func_table2(m, n, mc, nc, xc, yc, xf, yf, v, v_fine);
		// 
		/*for (int i1 = 0; i1 < m + 2; i1++) {
			for (int j1 = 0; j1 < n + 2; j1++) {
				v_fine[i1][j1] = 0.0;
				if ((i1 % q == 0) && (j1 % q == 0)) {
					v_fine[i1][j1] = v[i1/q][j1/q];
				}
			}
		}*/
		// вычесть v_fine из u 
		for (int i1 = 0; i1 < m + 2; i1++) {
			for (int j1 = 0; j1 < n + 2; j1++) {
				u[i1][j1] -= v_fine[i1][j1];
			}
		}

		//printf("u");
		//exporttecplot(u, xf, yf, m, n);
		//getchar();


		// PRE SMOOTING and POST SMOOTING
		for (int j = 0; j < iend; j++) {
			switch (ialg) {
			case STANDART: solve(0.125, u, u_old, rthdsd, A, m, n); break;
			case SEIDEL: // запоминаем поле с предыдущей итерации.
						  // данный итерационный процесс не требует в два раза больше памяти.
				for (int i1 = 0; i1 < m + 2; i1++) {
					for (int j1 = 0; j1 < n + 2; j1++) {
						u_old[i1][j1] = u[i1][j1];
					}
				}
				Seidel(u, rthdsd, A, m, n);
				break;
			case LR: // запоминаем поле с предыдущей итерации.
				 // данный итерационный процесс не требует в два раза больше памяти.
				for (int i1 = 0; i1 < m + 2; i1++) {
					for (int j1 = 0; j1 < n + 2; j1++) {
						u_old[i1][j1] = u[i1][j1];
					}
				}
				LRsolve(u, rthdsd, A, m, n); break;
			case SORDIRICHLET: for (int i1 = 0; i1 < m + 2; i1++) {
				for (int j1 = 0; j1 < n + 2; j1++) {
					u_old[i1][j1] = u[i1][j1];
				}
			}
							 // Метод верхней релаксации только в случае условий Дирихле 
							 // С оптимальным параметром релаксации.
							 // Подходит только для функции тока и более не для чего.
							 SORDirichlet(u, rthdsd, A, URF, m, n);
							 break;
			case ZVER: // запоминаем поле с предыдущей итерации.
					   // данный итерационный процесс требует в два раза больше памяти.
				for (int i1 = 0; i1 < m + 2; i1++) {
					for (int j1 = 0; j1 < n + 2; j1++) {
						u_old[i1][j1] = u[i1][j1];
					}
				}
				ZVERsolve(u, rthdsd, A, ksi, etta, gamma, d, theta, m, n);
				break;
			default: solve(0.125, u, u_old, rthdsd, A, m, n); break;
			}
			residual(r, u, rthdsd, A, m, n);
			norm = normar(r, m, n);
			residual_history[it - 1] = norm;
			//printf("  %d   %1.4e  \n",it,norm);
			it++;
		}

	}

	printf("u");
	exporttecplot(u, xf, yf,  m,  n);
	getchar();

	int iret = i;


	// Освобождение оперативной памяти.
	for (int i = 0; i < m + 2; i++) delete[] v_fine[i];
	delete[] v_fine;
	delete[] xf; delete[] yf; delete[] xc; delete[] yc;
	if (ialg == ZVER) {
		// Освобождение памяти из под вспомогательных структур используемых в алгоритме В.Г. Зверева.
		my_free_zver(ksi, etta, gamma, d, m, n);
		my_free_zver(ksil, ettal, gammal, dl, mc, nc);
	}

	// Уничтожение памяти из под вспомогательной структуры данных
	// использующейся в операции restriction типа AVG.
	for (int i = 0; i < mc + 2; i++) {
		delete[] myrq[i];
	}
	delete[] myrq;

	return iret;

} // itsolve_Fedor

// очень медленно сходящееся решение.
// уравнение конвекции-диффузии.
void start3() {

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	// Рассмотрим несколько задач для уравнения конвекции-диффузии
	// которые отличаются друг от друга лишь полем скоростей,
	// на всей границе стоит однородное условие Дирихле, 
	// правая часть также тождественно равна нулю.
	// Рассмотрение ведётся на основе статьи о переменно треугольном методе.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	Real bleft=400.0;
	Real bright=300.0;
	Real btop=300.0;
	Real bbottom=300.0;
	// Постоянный коэффициент динамической вязкости при 300К
	Real Renolds=10.0; // Число Ренольдса.
	Real MU300=1.0/Renolds;

	// вариант поля скоростей.
	const int VARVEL1=0; // 1.0, -1.0
	const int VARVEL2=1; // 1.0-2.0*x, 2.0*y-1.0
	const int VARVEL3=2; // x+y, x-y
	const int VARVEL4=3; // sin(2*MPI*x), -2.0*MPI*y*cos(2*MPI*x)
	int ivarvelocity=VARVEL4;

	calculation_start_time=clock(); // момент начала счёта.

	Real** u; // рассчитываемый потенциал.
	Real** xvel; // горизонтальная скорость
	Real** yvel; // вертикальная скорость.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть
	MATRNODE** A; // матрица СЛАУ

	Real** v1;
	Real** v1_old;
	Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	Real** ul;
	Real** vl;
	MATRNODE** Al; // матрица СЛАУ

    // постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(M+1));
	Real h2=(Real)(lengthy/(N+1));

	int MC, NC; // C - coarse
	MC = (int)((M + 1) / q) - 1;
	NC = (int)((N + 1) / q) - 1;

	Real* xf=new Real[M+2];
	for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}
	Real* yf=new Real[N+2];
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}

	// координаты на грубой сетке.
	Real* xc = new Real[MC + 2];
	int ic = 0;
	for (int i = 0; i < M + 2; i++) {
		if (i % q == 0) {
			xc[ic++] = xf[i];
		}
	}
	Real* yc = new Real[NC + 2];
	ic = 0;
	for (int i = 0; i < N + 2; i++) {
		if (i % q == 0) {
			yc[ic++] = yf[i];
		}
	}

	TBONCONDOMAIN my_bound; // Граничные условия
	TBONCONDOMAIN my_bound_0;
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_bound_0, MC, NC);
	my_alloc_universal(rthdsd_internal, M, N);

	// Шаблоны для граничных условий.
	int itask=STUDENT; // STUDENT DAVIS CHOHRAVLSKY BLASIUS RALEYBENAR

	load_my_bound_temp(my_bound, itask, xf, yf, M,N);

	printf("naivnji algorithm \n");

	my_alloc(v1, v1_old, r_coarse, rthdsd_c, Al, MC, NC);
	// Выделение памяти под компоненты скорости на грубой сетке.
	my_alloc_vel_loc(ul, vl, MC, NC);

	my_alloc(u, u_old, r, rthdsd, A, M, N);
	my_alloc_universal(xvel,M,N); // горизонтальная скорость
	my_alloc_universal(yvel,M,N); // вертикальная скорость
	my_init_zero(bleft, bright, bbottom, btop, 0.0, u, M, N);
	// Задание поля скоростей
	for (int i=0; i<M+2; i++) {
		for (int j=0; j<N+2; j++) {
			Real r1, r2;
			switch (ivarvelocity) {
			  case VARVEL1 : r1=1.0; r2=-1.0;	break;
			  case VARVEL2 : r1=1.0-2.0*xf[i]; r2=2.0*yf[j]-1.0; break;
			  case VARVEL3 : r1=xf[i]+yf[j]; r2=xf[i]-yf[j]; break;
			  case VARVEL4 : r1=(2.0*3.141/lengthy)*(sin(3.141*xf[i]/lengthx)* sin(3.141 * xf[i] / lengthx))*(sin(3.141 * yf[j] / lengthy) * cos(3.141 * yf[j] / lengthy));
				  r2=-(2.0*3.141 / lengthx) * (sin(3.141 * xf[i] / lengthx) * cos(3.141 * xf[i] / lengthx)) * (sin(3.141 * yf[j] / lengthy) * sin(3.141 * yf[j] / lengthy));
				  break;
			}
			xvel[i][j]=r1;
			yvel[i][j]=r2;
		}
	}
	Real dzeta1=1.0, dzeta2=1.0; // монотонная аппроксимация Самарского.
	if (!bnonlinear) {
		// свойства материалов постоянны.
		// геометрия тоже неизменна поэтому матрица 
		// собирается лишь единожды перед началом счёта.
		constrASamarskii(A, my_bound, xvel, yvel, MU300, dzeta1, dzeta2, xf, yf, M, N); // сборка матрицы.
	}
	for (int i=0; i<M+2; i++) {
		for (int j=0; j<N+2; j++) {
			rthdsd_internal[i][j]=0.0;
		}
	}
	constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
	// Внимание. Алгоритм В.Г. Зверева по видимому пригоден лишь для задач чистой диффузии и более того
	// только для краевых условий Дирихле. Поэтому настоятельно рекомендуется использовать LR.
	// Хотя возможно алгоритм Зверева и допускает модификацию позволяющую ему работать с условиями Неймана
	// но как реализовать эту модификацию пока неизвестно.
	int ialg=LR; // STANDART SEIDEL LR SORDIRICHLET ZVER

	if (1) {
		///-----------------------

		

		

		int iconstrA = SAMARSKII;

		// Для вспомогательной системы имеем однородные граничные условия.
		my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
		// передача компонент скорости на грубую сетку.
		my_restriction1(xvel, ul, M, N);
		my_restriction1(yvel, vl, M, N);
		load_my_bound_temp0(my_bound_0, itask, xc, yc, MC, NC);
		switch (iconstrA) {
		case SAMARSKII:
			constrASamarskii(Al, my_bound_0, ul, vl, MU300, dzeta1, dzeta2, xc, yc, MC, NC); // сборка матрицы.
			break;
		case PATANKAR:
			// безразмерные
			constrAPatankar(Al, my_bound_0, ul, vl, 1.0, MU300, xc, yc, MC, NC);
			break;
		}

		for (int i = 0; i < MC + 2; i++) {
			for (int j = 0; j < NC + 2; j++) {
				r_coarse[i][j] = 0.0;
				rthdsd_c[i][j] = 0.0;
			}
		}
		// По видимому эллиптическое уравнение для функции тока требуется решать достаточно точно и здесь необойтись без быстросходящегося алгоритма.
		int iendt = 330000;
		Real* residual_historyt = new Real[iendt + 1];
		for (int i = 0; i < iendt; i++) {
			residual_historyt[i] = 1.0; // инициализация.
		}
		int iendit1 = 1;


		// 0.1   0.01 0.001
		// 55    38
		// 32.7  14.5 14.1
		iendit1 = itsolve_Fedor(u, u_old, r, rthdsd, M, N, v1, v1_old, r_coarse, rthdsd_c, MC, NC, ialg, A, Al, 5.0e-8, residual_historyt);

		// нормированная октаэдрическая норма (сумма модулей).
		for (int i = 1; i < iendit1; i++) {
			residual_historyt[i] = residual_historyt[i] / residual_historyt[0];
		}
		residual_historyt[0] = 1.0;

		for (int i=0; i<iendit1; i++) {
		    printf("  %d   %1.4e  \n",i+1,residual_historyt[i]);
		}
		delete[] residual_historyt;
		//getchar();
	}
	else {
		// 1700 итераций LR достаточно на сетке 200*200.время расчёта равно 6.3с .
		// 48 итераций 0.9с врямя расчёта двухуровневый алгоритм Радия Петровича. на сетке 200*200.
		itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, 1700);
		//for (int i6=0; i6<6; i6++) {
			//Ilyin1985(u, rthdsd, A, M, N, 300);
		//}
	}

	

	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");

	//exporttecplot(u, xf, yf,  M,  N);
	exporttecplot2(u, xvel, yvel, xf, yf, M, N);
} // start3

// сильное ограничение на шаг по времени в полностью явной схеме.
// теперь данный код пригоден и для неравномерной сетки.
Real time_limiter_all_explicit(Real D, Real** u, Real** v, 
	                           Real *x, Real *y, int m, int n) 
{

	Real rmax=-1.0;

	for (int i=0; i<m+2; i++) {
	   	for (int j=0; j<n+2; j++) {
			if (((2.0/(fabs(u[i][j])*lengthx*D))*(1.0/(0.25*(x[i+1]-x[i-1])*(x[i+1]-x[i-1])))+(2.0/(fabs(v[i][j])*lengthy*D))*(1.0/(0.25*(y[j+1]-y[j-1])*(y[j+1]-y[j-1])))+fabs(u[i][j])/(0.5*(x[i+1]-x[i-1]))+fabs(v[i][j])/(0.5*(y[j+1]-y[j-1])))>rmax) {
				rmax=(2.0/(fabs(u[i][j])*lengthx*D))*(1.0/(0.25*(x[i+1]-x[i-1])*(x[i+1]-x[i-1])))+(2.0/(fabs(v[i][j])*lengthy*D))*(1.0/(0.25*(y[j+1]-y[j-1])*(y[j+1]-y[j-1])))+fabs(u[i][j])/(0.5*(x[i+1]-x[i-1]))+fabs(v[i][j])/(0.5*(y[j+1]-y[j-1]));
			}
		}
	}

	return (1.0/rmax); // сильное ограничение на шаг по времен в полностью явной схеме.

} // time_limiter_all_explicit

// сильное ограничение на шаг по времени в схеме Бураго Н.Г.
// метод пока пригоден лишь для равномерной расчётной сетки.
Real time_limiter_Burago(Real D, Real** u, Real** v, 
	                     Real* x, Real* y, int m, int n) {
	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(m+1));
	Real h2=(Real)(lengthy/(n+1));

	// 1e-6 предполагаемый модуль скороси когда течения нет.
	Real rDiffusitive=(2.0/(1e-6*lengthx*D))*(1.0/(h1*h1)+1.0/(h2*h2));
	Real rmax=-1.0;

	for (int i=0; i<m+2; i++) {
	   	for (int j=0; j<n+2; j++) {
			if ((fabs(u[i][j])/h1+fabs(v[i][j])/h2)>rmax) {
				rmax=fabs(u[i][j])/(0.5*(x[i+1]-x[i-1]))+fabs(v[i][j])/(0.5*(y[j+1]-y[j-1]));
			}
		}
	}

	if (rmax<FLT_MIN) {
		// первый шаг по времени когда поле скорости полностью нулевое.
		rmax=rDiffusitive;
	}

	return (1.0/rmax); // сильное ограничение на шаг по времен в полностью явной схеме.

} // time_limiter_Burago



// Вспомогательные функции для алгоритма Федоренко 1961.



/*
// усредняет невязку по ближайшему постранственному окружению.
Real resavgVol(Real** &r, int m, int n, int idist, int ip, int jp) {
	
	Real rcol=0;
	Real rsum=0.0;

	for (int i=0; i<m+2; i++) {
	    for (int j=0; j<n+2; j++) {
			if ((i>=ip-idist)&&(i<=ip+idist)&&(j>=jp-idist)&&(j<=jp+idist)) {
				rsum+=r[i][j];
				rcol+=1.0;
			}
		}
	}

	rsum=rsum/rcol;

	return rsum; // среднее значение.
} // resavgVol
*/




// Сплайновый PROLONGATION

// Для операции PROLONGATION будем использовать сплайновую интерполяцию.
// Г.З. Гарбер стр. 395.
// moments of spline.
// функция полностью заимствована.
void mosG(int k, int r, Real* x, Real* func,
	     Real GAMMAK, Real DELTAK, Real ALPHAR, Real DELTAR,
		 Real* &mom) {

	/* k,r - номера левого и правого граничных узлов сетки;
	* примеры : (k,r) : (0,M+1) или (0,N+1) или (0,MC+1) или (0,NC+1);
	*  x - массив узлов сетки;
	*  func - массив значений функции в узлах сетки;
	* GAMMAK, DELTAK - коэффициенты левого грангичного условия;
	* ALPHAR, DELTAR - коэффициенты правого граничного условия;
	* mom - массив моментов сплайна.
	*/

     Real alpha, gamma, delta;
	 int i;
	 Real w;
	 Real *H, *P, *Q;
	 
	 H=new Real[r+1];
	 P=new Real[r+1];
	 Q=new Real[r+1];

	 for (i=k+1; i<=r; i++) {
		 H[i]=x[i]-x[i-1];
	 } // next i

	 // Прямая прогонка.
	 P[k+1]=-0.5*GAMMAK;
	 Q[k+1]=0.5*DELTAK;
	 for (i=k+1; i<r; i++) {
		 w=H[i]+H[i+1];
		 alpha=H[i]/w;
		 gamma=1.0-alpha;
		 delta=6.0*((func[i+1]-func[i])/H[i+1]-(func[i]-func[i-1])/H[i])/w;
		 w=alpha*P[i]+2.0;
		 P[i+1]=-gamma/w;
		 Q[i+1]=(delta-alpha*Q[i])/w;
	 } // next i
	 // Обратная прогонка.
	 mom[r]=(DELTAR-ALPHAR*Q[r])/(ALPHAR*P[r]+2.0);
	 for (i=r; i>=k+1; i--) {
		 mom[i-1]=P[i]*mom[i]+Q[i];
	 } // next i

	 // Освобождение памяти.
	 delete H; delete P; delete Q;

} // mosG

// вычисление моментов сплайна по книге Г.З.Гарбера.
// стр. 238-246. "Основы программирования на VBA Exel и численных методов."
void mos(int n, Real* x, Real* f, Real gamma_left, Real delta_left,
	     Real alpha_right, Real delta_right, Real* &mom) {
	  // имеем одномерную таблично заданную функцию одного вещественного
	  // аргумента.
	  // n - количество дискретных значений функции,
	  // x - значения аргументов функции,
	  // f - соответствующие значения функции.
	  // mom - соответствующие моменты сплайна.
	  // Для нахождения моментов имеем СЛАУ с трёх диагональной матрицей :
	  // alpha[i]*mom[i-1]+2.0*mom[i]+gamma[i]*mom[i+1]=delta[i]; // i - ое уравнение 3-х диагональной СЛАУ.
	  // с граничными условиями:
	  // 2*mom[0]+gamma_left*mom[1]=delta_left; // левое граничное условие.
	  // alpha_right*mom[n-2]+2.0*mom[n-1]=delta_right; // правое граничное условие.

	  Real ralpha, rgamma, rdelta, rw; // r - Real;
	  int i;
	  Real* rH=new Real[n];
	  for (i=1; i<n; i++) rH[i]=x[i]-x[i-1]; // шаги сетки
	  Real* rP=new Real[n];
	  Real* rQ=new Real[n];

	  // Прямая прогонка:
	  rP[1]=-0.5*gamma_left;
	  rQ[1]=0.5*delta_left;
	  for (i=1; i<n-1; i++) {
		  rw=rH[i]+rH[i+1];
		  ralpha=rH[i]/rw;
		  rgamma=1.0-ralpha;
		  rdelta=6.0*(((f[i+1]-f[i])/rH[i+1])-((f[i]-f[i-1])/rH[i]))/rw;
		  rw=ralpha*rP[i]+2.0;
		  rP[i+1]=-rgamma/rw;
		  rQ[i+1]=(rdelta-ralpha*rQ[i])/rw;
	  } // end for i

	  // Обратная прогонка:
	  mom[n-1]=(delta_right-alpha_right*rQ[n-1])/(alpha_right*rP[n-1]+2.0);
	  for (i=n-1; i>0; i--) {
		  mom[i-1]=rP[i]*mom[i]+rQ[i];
	  } // end for i

	  // Освобождение оперативной памяти:
	  delete rH; delete rP; delete rQ;
} // mos

// подпрограмма сплайновой интерполяции.
// Вычисляет значение сплайна в заданной точке.
// реализовано по книге Г.З.Гарбера.
// стр. 238-246. "Основы программирования на VBA Exel и численных методов."
void si(int n, Real* x, Real* f, Real* mom, Real chi,
	    Real &s, Real &s1, Real &s2) {
	 // n - количество дискретных точек по которым построен сплайн,
     // x - массив значений аргументов функции,
     // f - массив значений функции,
	 // mom - массив моментов сплайна,
	 // chi - координата точки из области определения сплайна в которой нужно вычислить значение сплайна,
	 // s - рассчитываемое значение сплайна,
	 // s1, s2 - рассчитываемые значения первой и второй производных сплайна.

	int i;
	Real rh, rhh, rh1, rh1h1, rh2, rh2h2; // r - Real
	// Нахождение элементарного отрезка, содержащего chi:
	for (i=1; i<n; i++) {
		if (x[i]>chi) break; // принудительный выход из цикла
	}
	if (i>n-1) i=n-1;
	// Расчёт значения сплайна в точке chi :
	rh=x[i]-x[i-1];
	rhh=rh*rh;
	rh1=chi-x[i-1];
	rh1h1=rh1*rh1;
	rh2=x[i]-chi;
	rh2h2=rh2*rh2;
	s=(mom[i-1]*rh2h2*rh2+mom[i]*rh1h1*rh1)/(6.0*rh)+((f[i-1]-mom[i-1]*rhh/6.0)*rh2+(f[i]-mom[i]*rhh/6.0)*rh1)/rh;
	// Расчёт первой производной сплайна в точке chi :
	s1=(-mom[i-1]*rh2h2+mom[i]*rh1h1)/(2.0*rh)+(f[i]-f[i-1])/rh-rh*(mom[i]-mom[i-1])/6.0;
	// Расчёт второй производной сплайна в точке chi :
	s2=(mom[i-1]*rh2+mom[i]*rh1)/rh;
} // si


// Данную операцию неэкономично применять поточечно для всех точек подробной сетки, неэкономичность из-за
// того что на каждую такую точку (xC,yC) требуется масса прогонок (все горизонтальные и одна вертикальная несчитая
// флопов нужных для вычисления значений сплайна). Лучше применить более экономичный вариант : my_splain_interpol_func_table2.
// по заданной по точкам таблице (соответствует грубой сетке), восстанавливается значение функции
// в произвольной точке(xC, yC) путём 
// сплайновой интерполляции.
// Количество арефметических операций для восстановления значения в одной точке
// равно затратам на все горизонтальные прогонки н грубой сетке плюс одна вертикальная
// прогонка и ещё немного флопов для вычисления значений сплайна и его производных.
Real my_splain_interpol_func_table(int m, int n, 
	                     Real* x, Real* y, Real** f_coarse, 
						 Real xC, Real yC)  
{

	// Алгоритм:
	// сначала строятся сплайны для каждой строки таблицы (фиксированное значение y).
	// Зная сплайн для строки таблицы производится вычисление значения сплайна
	// для заданного значения аргумента xC в рамках данной строки, т.е. при заданном значении y.
	// проделая это для всех строк мы получем столбец соответствующий заданному значению xC.
	// Проделав сплайновую интерполяцию для полученного столбца можно без труда вычислить значение
	// сплайна построенного по этому столбцу для заданного значения yC - это и будет искомое значение f_val.

	Real f_val;

	Real* m2=new Real[m+2];
	Real** mm=new Real*[n+1];
	for (int i=0; i<n+2; i++) mm[i]=new Real[m+2];
	Real* f2=new Real[m+2];

	// Расчёт двумерного массива моментов по значениям аргумента x для всех строк таблицы
	// последовательно сверху вниз.
	for (int i=0; i<n+2; i++) {
		for (int j=0; j<m+2; j++) {
			// запоминаем строку мощностей в векторе f2:
			f2[j]=f_coarse[i][j];
		}  // end for j
		mos(m+2,x,f2,0.0,0.0,0.0,0.0,m2);
		for (int j=0; j<m+2; j++) {
			mm[i][j]=m2[j];
		} // end for j
	}


	Real* f1=new Real[n+2];
	for (int i=0; i<n+2; i++) {
		// для всех значений y построчно
		// соответствующих заданному значению аргумента x:
		for (int j=0; j<m+2; j++) {
			f2[j]=f_coarse[i][j];
			m2[j]=mm[i][j];
		}
		// вычисление стобца соответствующего заданному значению аргумента x.
		Real s1, s2;
		si(m+2, x, f2, m2, xC,  f1[i], s1, s2); 
	}
	Real* m1=new Real[n+2];
	mos(n+2,y,f1,0.0,0.0,0.0,0.0,m1);
	Real s1, s2;
	// Вычисление искомого значения мощности путём повторной сплайновой интерполяции по 
	// столбцу, полученному в результате интерполяции первого прохода.
    si(n+2, y, f1, m1, yC,  f_val, s1, s2);

	// Освобождение оперативной памяти:
	delete m2;
	delete f2;
	for (int i=0; i<n+2; i++) delete mm[i];
	delete mm;
	delete f1; 
	delete m1;

	return f_val;
} // my_splain_interpol_func_table

// Преобразует путём сплайновой интерполяции значения с грубой сетки
// на подробную для всех подробных точек.
// возврааемое значение f_fine[0..m+1][0..n+1]
void my_splain_interpol_func_table2(int m, int n, int mc, int nc, // c - coarse
	                     Real* xc, Real* yc, Real* xf, Real* yf, // c - coarse, f - fine
						 Real** f_coarse,   Real** &f_fine)  
{

	// Алгоритм:
	// сначала строятся сплайны для каждой строки таблицы (фиксированное значение y).
	// Зная сплайн для строки таблицы производится вычисление значения сплайна
	// для заданного значения аргумента xC в рамках данной строки, т.е. при заданном значении y.
	// проделая это для всех строк мы получем столбец соответствующий заданному значению xC.
	// Проделав сплайновую интерполяцию для полученного столбца можно без труда вычислить значение
	// сплайна построенного по этому столбцу для заданного значения yC - это и будет искомое значение f_val.

	Real f_val;

	Real* m2=new Real[nc+2];
	Real** mm=new Real*[mc+2];
	for (int i=0; i<mc+2; i++) mm[i]=new Real[nc+2];
	Real* f2=new Real[nc+2];

	// Расчёт двумерного массива моментов по значениям аргумента x для всех строк таблицы
	// последовательно сверху вниз.
	for (int i=0; i<mc+2; i++) {
		for (int j=0; j<nc+2; j++) {
			// запоминаем строку мощностей в векторе f2:
			f2[j]=f_coarse[i][j];
		}  // end for j
		mos(nc+2,yc,f2,0.0,0.0,0.0,0.0,m2);
		for (int j=0; j<nc+2; j++) {
			mm[i][j]=m2[j];
		} // end for j
	}


	Real* f1=new Real[mc+2];
	Real* m1=new Real[mc+2];
	

	for (int i1=0; i1<n+2; i1++) {
		Real yC=yf[i1];
	    for (int i=0; i<mc+2; i++) {
			// для всех значений y построчно
		    // соответствующих заданному значению аргумента x:
		    for (int j=0; j<nc+2; j++) {
				f2[j]=f_coarse[i][j];
			    m2[j]=mm[i][j];
		    }
		    // вычисление стобца соответствующего заданному значению аргумента x.
		    Real s1, s2;
		    si(nc+2, yc, f2, m2, yC,  f1[i], s1, s2); 
	    }
	    mos(mc+2,xc,f1,0.0,0.0,0.0,0.0,m1);
	    // Вычисление искомого значения мощности путём повторной сплайновой интерполяции по 
	    // столбцу, полученному в результате интерполяции первого прохода.
		for (int j1=0; j1<m+2; j1++) {
			Real xC=xf[j1];
			Real s1, s2;
            si(mc+2, xc, f1, m1, xC,  f_val, s1, s2);
			f_fine[j1][i1]=f_val;
		}
	}

	// Освобождение оперативной памяти:
	delete[] m2;
	delete[] f2;
	for (int i=0; i<mc+2; i++) delete[] mm[i];
	delete[] mm;
	delete[] f1; 
	delete[] m1;

} // my_splain_interpol_func_table2

/*
// Преобразует путём сплайновой интерполяции значения с грубой сетки
// на подробную для всех подробных точек.
// возврааемое значение f_fine[0..m+1][0..n+1]
void my_splain_interpol_func_table2(int m, int n, int mc, int nc, // c - coarse
	                     Real* xc, Real* yc, Real* xf, Real* yf, // c - coarse, f - fine
						 Real** f_coarse,   Real** &f_fine)  
{

	// Алгоритм:
	// сначала строятся сплайны для каждой строки таблицы (фиксированное значение y).
	// Зная сплайн для строки таблицы производится вычисление значения сплайна
	// для заданного значения аргумента xC в рамках данной строки, т.е. при заданном значении y.
	// проделая это для всех строк мы получем столбец соответствующий заданному значению xC.
	// Проделав сплайновую интерполяцию для полученного столбца можно без труда вычислить значение
	// сплайна построенного по этому столбцу для заданного значения yC - это и будет искомое значение f_val.

	Real f_val;

	Real* m2=new Real[nc+2];
	Real** mm=new Real*[mc+2];
	for (int i=0; i<mc+2; i++) mm[i]=new Real[nc+2];
	Real* f2=new Real[nc+2];

	// Расчёт двумерного массива моментов по значениям аргумента x для всех строк таблицы
	// последовательно сверху вниз.
	for (int i=0; i<mc+2; i++) {
		for (int j=0; j<nc+2; j++) {
			// запоминаем строку мощностей в векторе f2:
			f2[j]=f_coarse[i][j];
		}  // end for j
		mos(nc+2,yc,f2,0.0,0.0,0.0,0.0,m2);
		for (int j=0; j<nc+2; j++) {
			mm[i][j]=m2[j];
		} // end for j
	}


	Real* f1=new Real[nc+2];
	Real* m1=new Real[nc+2];
	

	for (int i1=0; i1<n+2; i1++) {
		Real yC=yf[i1];
	    for (int i=0; i<mc+2; i++) {
			// для всех значений y построчно
		    // соответствующих заданному значению аргумента x:
		    for (int j=0; j<nc+2; j++) {
				f2[j]=f_coarse[i][j];
			    m2[j]=mm[i][j];
		    }
		    // вычисление стобца соответствующего заданному значению аргумента x.
		    Real s1, s2;
		    si(nc+2, yc, f2, m2, yC,  f1[i], s1, s2); 
	    }
	    mos(mc+2,xc,f1,0.0,0.0,0.0,0.0,m1);
	    // Вычисление искомого значения мощности путём повторной сплайновой интерполяции по 
	    // столбцу, полученному в результате интерполяции первого прохода.
		for (int j1=0; j1<m+2; j1++) {
			Real xC=xf[j1];
			Real s1, s2;
            si(mc+2, xc, f1, m1, xC,  f_val, s1, s2);
			f_fine[j1][i1]=f_val;
		}
	}

	// Освобождение оперативной памяти:
	delete m2;
	delete f2;
	for (int i=0; i<mc+2; i++) delete mm[i];
	delete mm;
	delete f1; 
	delete m1;

} // my_splain_interpol_func_table2
*/




// Алгоритм Р.П. Федоренко 1961.
// Два уровня вложенности.
int itsolve_Fedor1(Real** &u, Real** &u_old, Real** &r, Real** &rthdsd,
	               int m, int n, 
				   Real** &v, Real** &v_old, Real** &r_coarse, Real** &rthdsd_c,
				   int mc, int nc, 
				    Real** &v1, Real** &v_old1, Real** &r_coarse1, Real** &rthdsd_c1,
				   int mc1, int nc1, 
				   int ialg, MATRNODE** &A, MATRNODE** &Al, MATRNODE** &Al1,
				   Real epsilon, Real* &residual_history) {

    // epsilon - точность с которой решается уравнение.
	int irestriction_type=AVGRP; // STANDART AVGR
	int idist=(int)(floor(0.5*q)); // наибольшее целое число в формате Real, не превосходящее x=0.5*q;

	 // инициализировано без релаксации.
	Real URF=1.0; // параметр релаксации на подробной сетке.
	Real URFl=1.0; // оптимальный параметр релаксации на грубой сетке.
	if (ialg==SORDIRICHLET) {
		// постоянные шаги сетки h1 по оси x и h2 по оси y.
	    // Real h1=(Real)(lengthx/(m+1));
	    // Real h2=(Real)(lengthy/(n+1));
        // Внимание оптимальный параметр релаксации верен только в случае краевых условий Дирихле.
	    const Real MPI=3.1415; // Число ПИ.
	    //Real b=0.5*cos(MPI*h1)+0.5*cos(MPI*h2);
        Real b=0.5*cos(MPI/(m+1))+0.5*cos(MPI/(n+1));
	    URF=2.0/(1.0+sqrt(1.0-b*b)); // Оптимальный параметр верхней релаксации для граничных условий Дирихле.
		// см. Е.Н.Бондарев, А.С.Кокорев МАИ Численные методы решения уравнений Навье-Стокса М. 1992.
        // Оптимальное значение коэффициента релаксации известно лишь для прямоугольной области и граничных условий Дирихле.
		// Чтобы узнать оптимальное значение параметра релаксации нужно знать : уравнение, форму области, сетку.
		// Т.е. спектральные характеристики матрицы. 
		// Данное значение параметра релаксации подходит лишь для решения уравнения типа уравнения для функции тока (коэффициент диффузии 1.0)
		// граничные условия Дирихле.
		Real bl=0.5*cos(MPI/(mc+1))+0.5*cos(MPI/(nc+1));
	    URFl=2.0/(1.0+sqrt(1.0-bl*bl)); // Оптимальный параметр верхней релаксации для граничных условий Дирихле.
		//printf("URF=%e, URFl=%e\n",URF,URFl);
		//getchar();
	}

	Real** ksi;
	Real** etta;
	Real** gamma;
	Real** d;
	Real theta; // параметр в диапазоне от нуля до 1.0
	Real** ksil;
	Real** ettal;
	Real** gammal;
	Real** dl;
	Real thetal;	
	Real** ksil1;
	Real** ettal1;
	Real** gammal1;
	Real** dl1;
	Real thetal1;	
	
	if (ialg==ZVER) {
		// Выделение оперативной памяти.
       my_alloc_zver(ksi, etta, gamma, d, m, n);
	   theta=1.0;
	   // Тоже самое для грубой сетки.
	   my_alloc_zver(ksil, ettal, gammal, dl, mc, nc);
	   thetal=1.0;
       // Тоже самое для грубой сетки второго уровня вложенности.
	   my_alloc_zver(ksil1, ettal1, gammal1, dl1, mc1, nc1);
	   thetal1=1.0;
	}

	// проинтерполированное значение v на подробную сетку.
	Real** v_fine=new Real*[m+2];
	for (int i=0; i<m+2; i++) v_fine[i]=new Real[n+2];

	// проинтерполированное значение v на подробную сетку для второго уровня вложенности.
	Real** v_fine1=new Real*[mc+2];
	for (int i=0; i<mc+2; i++) v_fine1[i]=new Real[nc+2];

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(M+1));
	Real h2=(Real)(lengthy/(N+1));
	// Координаты узлов для интерполляции.
	Real* xf=new Real[m+2];
	Real* xc=new Real[mc+2];
	Real* xc1=new Real[mc1+2];
	int ic=0;
	int ic1=0;
	for (int i=0; i<m+2; i++) {
		xf[i]=(Real)(i*h1);
		if (i%q==0) {
			xc[ic]=(Real)(ic*h1*q);
			ic++;
		}
		if (i%(q*q)==0) {
			xc1[ic1]=(Real)(ic1*h1*q*q);
			ic1++;
		}
	}
	Real* yf=new Real[n+2];
	Real* yc=new Real[nc+2];
	Real* yc1=new Real[nc1+2];
	ic=0; ic1=0;
	for (int i=0; i<n+2; i++) {
		yf[i]=(Real)(i*h2);
		if (i%q==0) {
			yc[ic]=(Real)(ic*h2*q);
			ic++;
		}
        if (i%(q*q)==0) {
			yc1[ic1]=(Real)(ic1*h2*q*q);
			ic1++;
		}
	}

	// TODO

	//printf(" iter  residual\n");
	
	// Вспомогательные данные для операции проецирования 
    // с подробной сетки на грубую.
    RESTRICT_AVG_S** myrq=new RESTRICT_AVG_S*[mc+2];
	for (int i=0; i<mc+2; i++) {
		myrq[i]=new RESTRICT_AVG_S[nc+2];
	}
	// инициализация !
#if MY_FLOAT
	for (int i1=0; i1<mc+2; i1++) {
	    	for (int j1=0; j1<nc+2; j1++) {
				myrq[i1][j1].SumVol=0.0f;
				for (int i=0; i<5; i++) {
	    	        for (int j=0; j<5; j++) {
						myrq[i1][j1].ix[i][j]=0;
						myrq[i1][j1].iy[i][j]=0;
						myrq[i1][j1].Vol[i][j]=0.0f;
					}
				}
			}
	}
#else
	for (int i1=0; i1<mc+2; i1++) {
	    	for (int j1=0; j1<nc+2; j1++) {
				myrq[i1][j1].SumVol=0.0;
				for (int i=0; i<5; i++) {
	    	        for (int j=0; j<5; j++) {
						myrq[i1][j1].ix[i][j]=0;
						myrq[i1][j1].iy[i][j]=0;
						myrq[i1][j1].Vol[i][j]=0.0;
					}
				}
			}
	}
#endif

	

	// Сам препроцессинг.
	for (int i=0; i<mc+2; i++) {
	   	for (int j=0; j<nc+2; j++) {
			resavgVolpreprocessing(xf, yf, m, n, idist, i*q, j*q, myrq[i][j]);
	    }
	}      
	
	
	// Дополнительный уровень вложенности.
	// Вспомогательные данные для операции проецирования 
    // с подробной сетки на грубую.
    RESTRICT_AVG_S** myrq1=new RESTRICT_AVG_S*[mc1+2];
	for (int i=0; i<mc1+2; i++) {
		myrq1[i]=new RESTRICT_AVG_S[nc1+2];
	}
	// инициализация !
#if MY_FLOAT
	for (int i1=0; i1<mc1+2; i1++) {
	    	for (int j1=0; j1<nc1+2; j1++) {
				myrq1[i1][j1].SumVol=0.0f;
				for (int i=0; i<5; i++) {
	    	        for (int j=0; j<5; j++) {
						myrq1[i1][j1].ix[i][j]=0;
						myrq1[i1][j1].iy[i][j]=0;
						myrq1[i1][j1].Vol[i][j]=0.0f;
					}
				}
			}
	}
#else
	for (int i1=0; i1<mc1+2; i1++) {
	    	for (int j1=0; j1<nc1+2; j1++) {
				myrq1[i1][j1].SumVol=0.0;
				for (int i=0; i<5; i++) {
	    	        for (int j=0; j<5; j++) {
						myrq1[i1][j1].ix[i][j]=0;
						myrq1[i1][j1].iy[i][j]=0;
						myrq1[i1][j1].Vol[i][j]=0.0;
					}
				}
			}
	}
#endif

	

	// Сам препроцессинг.
	for (int i=0; i<mc1+2; i++) {
	   	for (int j=0; j<nc1+2; j++) {
			resavgVolpreprocessing(xc, yc, mc, nc, idist, i*q, j*q, myrq1[i][j]);
	    }
	}      
	


	Real norm=10.0;
	int it=1; // счётчик количества итераций
	int i=0;
	while ((i<1200)&&(norm>epsilon)) {
		i++;

		int iend=7; // число итераций сглаживающего метода
		switch (ialg) {
          case STANDART : iend=4; break;
          case SEIDEL : iend=4; break;
		  case LR : iend=2; break; // Оптимальное на сетке 50x50 q5 значение 2. 
		  case SORDIRICHLET : iend=4; break;
		  case ZVER : iend=2; break; // Оптимальное на сетке 50x50 q5 значение 2. 
		}

		/* Мысли. Как видно из эксперимента ZVER в качестве базового метода для алгоритма Федоренко уступает полинейному методу
		* в качестве базового в алгоритме Федоренко. Безусловно применение данных методов в сочеании с алгоритмом Федоренко даёт
		* более быструю сходимость по сравнению со случает когда алгоритмы ZVER и LR применяются отдельно без алгоритма Федоренко.
		* То что алгоритм ZVER уступает алгоритму LR когда они применяются внутри алгоритма Федоренко возможно из-за того что в алгоритме
		* ZVER ослаблен диагональный член и усредняющее (сглаживающее) действие алгоритма ZVER хуже чем сглаживающее действие алгоритма LR
		* (т.к. в алгоритме LR очень большая главная диагональ).
		* Однако если применять методы LR и ZVER без связки с идеей Федоренко то алгоритм ZVER очень сильно выигрывает на SPD задачах у алгоритма LR.
		*/

		// PRE SMOOTING and POST SMOOTING
		for (int j=0; j<iend; j++) {
			switch (ialg) {
			  case STANDART : solve(0.125, u, u_old, rthdsd, A, m, n); break;
			  case SEIDEL : // запоминаем поле с предыдущей итерации.
	                        // данный итерационный процесс не требует в два раза больше памяти.
	                        for (int i1=0; i1<m+2; i1++) {
		                        for (int j1=0; j1<n+2; j1++) {
			                        u_old[i1][j1]=u[i1][j1];
		                        }
	                        }
				            Seidel(u, rthdsd, A, m, n);
							break; 
			   case LR : // запоминаем поле с предыдущей итерации.
	                // данный итерационный процесс не требует в два раза больше памяти.
	                for (int i1=0; i1<m+2; i1++) {
		                for (int j1=0; j1<n+2; j1++) {
			                 u_old[i1][j1]=u[i1][j1];
		                }
	                }
			        LRsolve(u, rthdsd, A, m, n); break;
			   case SORDIRICHLET : for (int i1=0; i1<m+2; i1++) {
		                               for (int j1=0; j1<n+2; j1++) {
			                               u_old[i1][j1]=u[i1][j1];
		                               }
	                               }
			                       // Метод верхней релаксации только в случае условий Дирихле 
			                       // С оптимальным параметром релаксации.
			                       // Подходит только для функции тока и более не для чего.
			                       SORDirichlet(u, rthdsd, A, URF, m, n); 
			          break;
			   case ZVER : // запоминаем поле с предыдущей итерации.
	                       // данный итерационный процесс требует в два раза больше памяти.
	                       for (int i1=0; i1<m+2; i1++) {
		                       for (int j1=0; j1<n+2; j1++) {
			                       u_old[i1][j1]=u[i1][j1];
		                       }
	                       }
					       ZVERsolve(u, rthdsd, A, ksi, etta, gamma, d, theta, m, n); 
				           break;
			  default : solve(0.125, u, u_old, rthdsd, A, m, n); break;
			}
		    residual(r, u, rthdsd, A, m, n);
		    norm=normar(r,m,n);
			residual_history[it-1]=norm;
		    //printf("  %d   %1.4e  \n",it,norm);
			it++;
		}
		//exporttecplot(r, xf, yf,  m,  n);
		//getchar();
		// Решение вспомогательной системы на грубой сетке.
		//if (i%2==0) printf(" iter  residual\n");
		//exporttecplot(r, xf, yf,  m,  n);

		
		// RESTRICTION
		switch (irestriction_type) {
		   case STANDART : my_restriction1(r, r_coarse, m, n); break; // просто взяты значения в совподающих узлах.
		   case AVGR : my_restriction2(r, r_coarse, xf, yf, m, n); break; // на основе осреднённого значения сходится лучше.
		   case AVGRP : my_restriction3(r, r_coarse, mc, nc, myrq); break; // на основе осреднённого значения сходится лучше. Тяжёловесные операции вынесены в стадию препроцессинга.
		}


		//exporttecplot(r_coarse, xc, yc,  mc,  nc);
		norm=normar(r_coarse,mc,nc);
		//printf("  restriction norm =  %1.4e  \n",norm);
		//getchar();
		// INIT COARSE
		// Для вспомогательной системы имеем однородные граничные условия.
		my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, mc, nc);
		// вычисление правой части
		// для вспомогательной системы.
		for (int i1=0; i1<mc+2; i1++) {
	    	for (int j1=0; j1<nc+2; j1++) {
				//rthdsd_c[i1][j1]=q*q*r_coarse[i1][j1]; при h1==h2==1.0 в версии Fedorenko1
				rthdsd_c[i1][j1]=-r_coarse[i1][j1]; // именно минус, т.к. мы следуем записи дискретного аналога по Патанкару.

				// 15.05.2021
				//rthdsd_c[i1][j1] = -(q*q*h1*h2)*r_coarse[i1][j1];

				// Мы решаем вспомогательную СЛАУ с невязкой в качестве правой части. Данный факт не зависит от способа получения СЛАУ.
				// Это может быть метод контрольного объёма или метод конечных разностей.
				
		    }
	    }  

		// Однородные граничные условия !!!!!!
		constrrthdsdzero(rthdsd_c, mc, nc); // однородные граничные условия !!!

		
		int iend2=q*q; // число итераций сглаживающего метода
		//Сходимость метода Зейделя в два раза более быстрая чем у стандартного метода.
		// Сходимость полинейного метода в два раза более быстрая чем у Зейделя, однако он
		// требует на одну итерацию существенно больше флопов.
		switch (ialg) {
          case STANDART : iend2=q*q; break;
          case SEIDEL : iend2=(int)(floor(0.5*q*q)); break;
		  case LR : iend2=(int)(floor(0.25*q*q)); break;
		  case SORDIRICHLET : iend2=(int)(floor(0.5*q*q)); break;
		  case ZVER : iend2=(int)(floor(0.25*q*q)); break; // Алгоритм В.Г. Зверева.
		}

		// решение вспомогательной СЛАУ.
		for (int j=0; j<iend2; j++) {
			switch (ialg) {
			  case STANDART : solve(0.125, v, v_old, rthdsd_c, Al, mc, nc); break;
			  case SEIDEL : // запоминаем поле с предыдущей итерации.
	                        // данный итерационный процесс не требует в два раза больше памяти.
	                        for (int i1=0; i1<mc+2; i1++) {
		                        for (int j1=0; j1<nc+2; j1++) {
			                        v_old[i1][j1]=v[i1][j1];
									//v[i1][j1] = 0.0;
		                        }
	                        }
				            Seidel(v, rthdsd_c, Al, mc, nc);
				            break; 
              case LR : // запоминаем поле с предыдущей итерации.
	                    // данный итерационный процесс не требует в два раза больше памяти.
	                    for (int i1=0; i1<mc+2; i1++) {
		                    for (int j1=0; j1<nc+2; j1++) {
			                    v_old[i1][j1]=v[i1][j1];
		                    }
	                    }
			            LRsolve(v, rthdsd_c, Al, mc, nc);
					    break;
			  case SORDIRICHLET : for (int i1=0; i1<mc+2; i1++) {
		                          for (int j1=0; j1<nc+2; j1++) {
			                          v_old[i1][j1]=v[i1][j1];
		                          }
	                          }
			                  // Метод верхней релаксации только в случае условий Дирихле 
			                  // С оптимальным параметром релаксации.
			                  // Подходит только для функции тока и более не для чего.
			                  SORDirichlet(v, rthdsd_c, Al, URFl, mc, nc); 
			          break;
			  case ZVER : // запоминаем поле с предыдущей итерации.
	                       // данный итерационный процесс требует в два раза больше памяти.
	                       for (int i1=0; i1<mc+2; i1++) {
		                       for (int j1=0; j1<nc+2; j1++) {
			                       v_old[i1][j1]=v[i1][j1];
		                       }
	                       }
						   ZVERsolve(v, rthdsd_c, Al, ksil, ettal, gammal, dl, thetal,  mc, nc); 
				           break;
			  default : solve(0.125, v, v_old, rthdsd_c, Al, mc, nc); break; 
			}
			residual(r_coarse, v_old, rthdsd_c, Al, mc, nc);
		    norm=normar(r_coarse,mc,nc);
		    //printf("  %d   %1.4e  \n",it++,norm);
		}
		//getchar();


		// RESTRICTION
		switch (irestriction_type) {
		   case STANDART : my_restriction1(r_coarse, r_coarse1, mc, nc); break; // просто взяты значения в совподающих узлах.
		   case AVGR : my_restriction2(r_coarse, r_coarse1, xc, yc, mc, nc); break; // на основе осреднённого значения сходится лучше.
		   case AVGRP : my_restriction3(r_coarse, r_coarse1, mc1, nc1, myrq1); break; // на основе осреднённого значения сходится лучше. Тяжёловесные операции вынесены в стадию препроцессинга.
		}


		//exporttecplot(r_coarse1, xc1, yc1,  mc1,  nc1);
		norm=normar(r_coarse1,mc1,nc1);
		//printf("  restriction norm =  %1.4e  \n",norm);
		//getchar();
		// INIT COARSE
		// Для вспомогательной системы имеем однородные граничные условия.
		my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, mc1, nc1);
		// вычисление правой части
		// для вспомогательной системы.
		for (int i1=0; i1<mc1+2; i1++) {
	    	for (int j1=0; j1<nc1+2; j1++) {
				//rthdsd_c1[i1][j1]=q*q*q*q*r_coarse1[i1][j1]; при h1==h2==1.0 в версии Fedorenko1
				rthdsd_c1[i1][j1]=-r_coarse1[i1][j1]; // именно минус, т.к. мы следуем записи дискретного аналога по Патанкару.

				//rthdsd_c1[i1][j1] = -(q * q * q * q*h1*h2)*r_coarse1[i1][j1];

				// Мы решаем вспомогательную СЛАУ с невязкой в качестве правой части. Данный факт не зависит от способа получения СЛАУ.
				// Это может быть метод контрольного объёма или метод конечных разностей.
				
		    }
	    }  

		// Однородные граничные условия !!!!!!
		constrrthdsdzero(rthdsd_c1, mc1, nc1); // однородные граничные условия !!!


        // iend2 число итераций сглаживающего метода
		//Сходимость метода Зейделя в два раза более быстрая чем у стандартного метода.
		// Сходимость полинейного метода в два раза более быстрая чем у Зейделя, однако он
		// требует на одну итерацию существенно больше флопов.
		switch (ialg) {
          case STANDART : iend2=q*q; break;
          case SEIDEL : iend2=(int)(floor(0.5*q*q)); break;
		  case LR : iend2=(int)(floor(0.25*q*q)); break;
		  case SORDIRICHLET : iend2=(int)(floor(0.5*q*q)); break;
		  case ZVER : iend2=(int)(floor(0.25*q*q)); break; // Алгоритм В.Г. Зверева.
		}

		// решение вспомогательной СЛАУ.
		for (int j=0; j<iend2; j++) {
			switch (ialg) {
			  case STANDART : solve(0.125, v1, v_old1, rthdsd_c1, Al1, mc1, nc1); break;
			  case SEIDEL : // запоминаем поле с предыдущей итерации.
	                        // данный итерационный процесс не требует в два раза больше памяти.
	                        for (int i1=0; i1<mc1+2; i1++) {
		                        for (int j1=0; j1<nc1+2; j1++) {
			                        v_old1[i1][j1]=v1[i1][j1];
									//v1[i1][j1] = 0.0;
		                        }
	                        }
				            Seidel(v1, rthdsd_c1, Al1, mc1, nc1);
				            break; 
              case LR : // запоминаем поле с предыдущей итерации.
	                    // данный итерационный процесс не требует в два раза больше памяти.
	                    for (int i1=0; i1<mc1+2; i1++) {
		                    for (int j1=0; j1<nc1+2; j1++) {
			                    v_old1[i1][j1]=v1[i1][j1];
		                    }
	                    }
			            LRsolve(v1, rthdsd_c1, Al1, mc1, nc1);
					    break;
			  case SORDIRICHLET : 
				        for (int i1=0; i1<mc1+2; i1++) {
		                          for (int j1=0; j1<nc1+2; j1++) {
			                          v_old1[i1][j1]=v1[i1][j1];
		                          }
	                          }
			                  // Метод верхней релаксации только в случае условий Дирихле 
			                  // С оптимальным параметром релаксации.
			                  // Подходит только для функции тока и более не для чего.
			                  SORDirichlet(v1, rthdsd_c1, Al1, URFl, mc1, nc1); 
			          break;
			  case ZVER : // запоминаем поле с предыдущей итерации.
	                       // данный итерационный процесс требует в два раза больше памяти.
	                       for (int i1=0; i1<mc1+2; i1++) {
		                       for (int j1=0; j1<nc1+2; j1++) {
			                       v_old1[i1][j1]=v1[i1][j1];
		                       }
	                       }
						   ZVERsolve(v1, rthdsd_c1, Al1, ksil1, ettal1, gammal1, dl1, thetal1,  mc1, nc1); 
				           break;
			  default : solve(0.125, v1, v_old1, rthdsd_c1, Al1, mc1, nc1); break; 
			}
			residual(r_coarse1, v1, rthdsd_c1, Al1, mc1, nc1);
		    norm=normar(r_coarse1,mc1,nc1);
		    //printf("  %d   %1.4e  \n",it++,norm);
		}
		//getchar();

		// проинтерполлировать v на подробную сетку (v_fine) (например с помощью сплайна)
		my_splain_interpol_func_table2(mc, nc, mc1, nc1, xc1, yc1, xc, yc, v1, v_fine1);
		// вычесть v_fine из u 
		for (int i1=0; i1<mc+2; i1++) {
			for (int j1=0; j1<nc+2; j1++) {
				v[i1][j1]-=v_fine1[i1][j1];
			}
		}

		// Пост сглаживание.
		// число итераций сглаживающего метода
		//Сходимость метода Зейделя в два раза более быстрая чем у стандартного метода.
		// Сходимость полинейного метода в два раза более быстрая чем у Зейделя, однако он
		// требует на одну итерацию существенно больше флопов.
		switch (ialg) {
          case STANDART : iend2=q*q; break;
          case SEIDEL : iend2=(int)(floor(0.5*q*q)); break;
		  case LR : iend2=(int)(floor(0.25*q*q)); break;
		  case SORDIRICHLET : iend2=(int)(floor(0.5*q*q)); break;
		  case ZVER : iend2=(int)(floor(0.25*q*q)); break; // Алгоритм В.Г. Зверева.
		}

		// решение вспомогательной СЛАУ.
		for (int j=0; j<iend2; j++) {
			switch (ialg) {
			  case STANDART : solve(0.125, v, v_old, rthdsd_c, Al, mc, nc); break;
			  case SEIDEL : // запоминаем поле с предыдущей итерации.
	                        // данный итерационный процесс не требует в два раза больше памяти.
	                        for (int i1=0; i1<mc+2; i1++) {
		                        for (int j1=0; j1<nc+2; j1++) {
			                        v_old[i1][j1]=v[i1][j1];
		                        }
	                        }
				            Seidel(v, rthdsd_c, Al, mc, nc);
				            break; 
              case LR : // запоминаем поле с предыдущей итерации.
	                    // данный итерационный процесс не требует в два раза больше памяти.
	                    for (int i1=0; i1<mc+2; i1++) {
		                    for (int j1=0; j1<nc+2; j1++) {
			                    v_old[i1][j1]=v[i1][j1];
		                    }
	                    }
			            LRsolve(v, rthdsd_c, Al, mc, nc);
					    break;
			  case SORDIRICHLET : for (int i1=0; i1<mc+2; i1++) {
		                          for (int j1=0; j1<nc+2; j1++) {
			                          v_old[i1][j1]=v[i1][j1];
		                          }
	                          }
			                  // Метод верхней релаксации только в случае условий Дирихле 
			                  // С оптимальным параметром релаксации.
			                  // Подходит только для функции тока и более не для чего.
			                  SORDirichlet(v, rthdsd_c, Al, URFl, mc, nc); 
			          break;
			  case ZVER : // запоминаем поле с предыдущей итерации.
	                       // данный итерационный процесс требует в два раза больше памяти.
	                       for (int i1=0; i1<mc+2; i1++) {
		                       for (int j1=0; j1<nc+2; j1++) {
			                       v_old[i1][j1]=v[i1][j1];
		                       }
	                       }
						   ZVERsolve(v, rthdsd_c, Al, ksil, ettal, gammal, dl, thetal,  mc, nc); 
				           break;
			  default : solve(0.125, v, v_old, rthdsd_c, Al, mc, nc); break; 
			}
			residual(r_coarse, v_old, rthdsd_c, Al, mc, nc);
		    norm=normar(r_coarse,mc,nc);
		    //printf("  %d   %1.4e  \n",it++,norm);
		}
		//getchar();

		// проинтерполлировать v на подробную сетку (v_fine) (например с помощью сплайна)
		my_splain_interpol_func_table2(m, n, mc, nc, xc, yc, xf, yf, v, v_fine);
		// вычесть v_fine из u 
		for (int i1=0; i1<m+2; i1++) {
			for (int j1=0; j1<n+2; j1++) {
				u[i1][j1]-=v_fine[i1][j1];
			}
		}

		// PRE SMOOTING and POST SMOOTING
		for (int j=0; j<iend; j++) {
			switch (ialg) {
			  case STANDART : solve(0.125, u, u_old, rthdsd, A, m, n); break;
			  case SEIDEL : // запоминаем поле с предыдущей итерации.
	                        // данный итерационный процесс не требует в два раза больше памяти.
	                        for (int i1=0; i1<m+2; i1++) {
		                        for (int j1=0; j1<n+2; j1++) {
			                        u_old[i1][j1]=u[i1][j1];
		                        }
	                        }
				            Seidel(u, rthdsd, A, m, n);
							break; 
			   case LR : // запоминаем поле с предыдущей итерации.
	                // данный итерационный процесс не требует в два раза больше памяти.
	                for (int i1=0; i1<m+2; i1++) {
		                for (int j1=0; j1<n+2; j1++) {
			                 u_old[i1][j1]=u[i1][j1];
		                }
	                }
			        LRsolve(u, rthdsd, A, m, n); break;
			   case SORDIRICHLET : for (int i1=0; i1<m+2; i1++) {
		                               for (int j1=0; j1<n+2; j1++) {
			                               u_old[i1][j1]=u[i1][j1];
		                               }
	                               }
			                       // Метод верхней релаксации только в случае условий Дирихле 
			                       // С оптимальным параметром релаксации.
			                       // Подходит только для функции тока и более не для чего.
			                       SORDirichlet(u, rthdsd, A, URF, m, n); 
			          break;
				case ZVER : // запоминаем поле с предыдущей итерации.
	                       // данный итерационный процесс требует в два раза больше памяти.
	                       for (int i1=0; i1<m+2; i1++) {
		                       for (int j1=0; j1<n+2; j1++) {
			                       u_old[i1][j1]=u[i1][j1];
		                       }
	                       }
					       ZVERsolve(u, rthdsd, A, ksi, etta, gamma, d, theta,  m, n); 
				           break;
			  default : solve(0.125, u, u_old, rthdsd, A, m, n); break;
			}
		    residual(r, u_old, rthdsd, A, m, n);
		    norm=normar(r,m,n);
			residual_history[it-1]=norm;
		    printf("  %d   %1.4e  \n",it,norm);
			it++;
		}

	}

	getchar();

	//exporttecplot(u, xf, yf,  m,  n);

	int iret = i;


	// Освобождение оперативной памяти.
	for (int i=0; i<mc+2; i++) delete v_fine1[i];
	delete v_fine1;
	for (int i=0; i<m+2; i++) delete v_fine[i];
	delete v_fine;
	delete xf; delete yf; delete xc; delete yc;
	delete xc1; delete yc1;
	if (ialg==ZVER) {
		// Освобождение памяти из под вспомогательных структур используемых в алгоритме В.Г. Зверева.
		my_free_zver(ksi, etta, gamma, d, m, n);
		my_free_zver(ksil, ettal, gammal, dl, mc, nc);
		my_free_zver(ksil1, ettal1, gammal1, dl1, mc1, nc1);
	}

	// Уничтожение памяти из под вспомогательной структуры данных
	// использующейся в операции restriction типа AVG.
	for (int i=0; i<mc+2; i++) {
		delete myrq[i];
	}
	delete myrq;
	for (int i=0; i<mc1+2; i++) {
		delete myrq1[i];
	}
	delete myrq1;

	return iret;

} // itsolve_Fedor1


//  функции связанные непосредственно с алгоритмом Р.П.Федоренко.


// Оригинальный алгоритм Р.П. Федоренко 1961 года.
void start2() {

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.


	calculation_start_time=clock(); // момент начала счёта.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(M+1));
	Real h2=(Real)(lengthy/(N+1));

	Real* xf=new Real[M+2];
	for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}
	Real* yf=new Real[N+2];
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	Real bleft=0;
	Real bright=0.0;
	Real btop=0.0;
	Real bbottom=0.0;
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0;

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
	// Ещё один уровень вложенности.
	bool bactive1=false;
    Real** v1;
    Real** v_old1;
    Real** r_coarse1;
	Real** rthdsd_c1; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al1; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_universal(rthdsd_internal, M, N);

	// Шаблоны для граничных условий.
	int itask=STUDENT; // STUDENT STUDENTA DAVIS CHOHRAVLSKY BLASIUS RALEYBENAR

	load_my_bound_temp(my_bound, itask, xf, yf, M,N);

	printf("Multigrd Fedorenko 1961 algorithm \n");
	my_alloc(u, u_old, r, rthdsd, A, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, u, M, N);
	if (!bnonlinear) {
		// геометрия неизменна и свойства материалов постоянны
		// поэтому матрица собирается только один раз перед началом счёта.
	    constrA0(A, my_bound, K300, xf, yf, M, N); // сборка матрицы.
	}
	for (int i=0; i<M+2; i++) {
		for (int j=0; j<N+2; j++) {
			r[i][j]=0.0; // невязка
			rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		}
	}


	for (int i = 1; i < M + 1; i++) {
		for (int j = 1; j < N + 1; j++) {
			//rthdsd_internal[i][j] = 1.0;

			// аналитическая правая часть.
			//const double M_PI = 3.14159;
			rthdsd_internal[i][j] = -2.0 * (M_PI * M_PI) * (cos(2.0 * M_PI * xf[i] / lengthx) * sin(M_PI * yf[j] / lengthy) * sin(M_PI * yf[j] / lengthy) +
				cos(2.0 * M_PI * yf[j] / lengthy) * sin(M_PI * xf[i] / lengthx) * sin(M_PI * xf[i] / lengthx));
			// Аналитическое решение.
			//etalon[i][j] = sin(M_PI * xf[i] / lengthx) * sin(M_PI * xf[i] / lengthx) * sin(M_PI * yf[j] / lengthy) * sin(M_PI * yf[j] / lengthy);
			rthdsd_internal[i][j] *= h1 * h2;
		}
	}


	constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.

	// Первый уровень вложенности.

	int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);

	load_my_bound_temp(my_bound_coarse, itask, xc, yc, MC, NC);

	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);
	// Для вспомогательной системы имеем однородные граничные условия.
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	if (!bnonlinear) {
		// геометрия неизменна и свойства материалов постоянны
		// поэтому матрица собирается только один раз перед началом счёта.
	    constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	}
	for (int i=0; i<MC+2; i++) {
		for (int j=0; j<NC+2; j++) {
			r_coarse[i][j]=0.0;
			rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		}
	}

	// Второй уровень вложенности.

	int MC1, NC1; // C - coarse
	MC1=(int)((M+1)/q/q)-1;
	NC1=(int)((N+1)/q/q)-1;

	if ((MC1>5) && (NC1>5)) {
		bactive1=true;
	}


	Real *xc1, *yc1;
	TBONCONDOMAIN my_bound_coarse1; // Граничные условия
	if (bactive1) {

	   // координаты на грубой сетке.
	   xc1=new Real[MC1+2];
	   int ic=0;
	   for (int i=0; i<M+2; i++) {
	   	  if (i%(q*q)==0) {
		     xc1[ic++]=xf[i];
		  }
	   }
	   yc1=new Real[NC1+2];
	   ic=0;
	   for (int i=0; i<N+2; i++) {
	   	  if (i%(q*q)==0) {
			 yc1[ic++]=yf[i];
		  }
	   }

	
	   // Выделение памяти под граничные условия.
       my_alloc_bound(my_bound_coarse1,MC1,NC1);

	   load_my_bound_temp(my_bound_coarse1, itask, xc1, yc1, MC1, NC1);

	   my_alloc(v1, v_old1, r_coarse1, rthdsd_c1, Al1, MC1, NC1);
	   // Для вспомогательной системы имеем однородные граничные условия.
	   my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC1, NC1);
	   if (!bnonlinear) {
		  // геометрия неизменна и свойства материалов постоянны
		  // поэтому матрица собирается только один раз перед началом счёта.
	      constrA0(Al1, my_bound_coarse1, K300, xc1, yc1, MC1, NC1); // сборка матрицы.
	   }
	   for (int i=0; i<MC1+2; i++) {
		  for (int j=0; j<NC1+2; j++) {
			   r_coarse1[i][j]=0.0;
			   rthdsd_c1[i][j]=0.0*0.25*(xc1[i+1]-xc1[i-1])*(yc1[j+1]-yc1[j-1]);
		  }
	   }
	}

	int iend = 20000;
	int iendret = 1; // реальное количество итераций сделанных алгебраическим многосеточным методом.
	Real *residual_history=new Real[iend+1];
	for (int i=0; i<iend; i++) {
	   residual_history[i]=1.0; // инициализация.
	}
	if (bactive1) {
		// Два уровня вложенности в многосеточном методе.
		std::cout << "3 level geometric multigrid R.P. Fedorenko\n";
		iendret = itsolve_Fedor1(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC,  v1, v_old1,  r_coarse1, rthdsd_c1, MC1, NC1, ibasealg, A, Al, Al1, 1.0e-12, residual_history);
		//iendret=itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1e-5, residual_history);
	}
	else {
		iendret=itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-12, residual_history);
	}
	
	// нормированная октаэдрическая норма (сумма модулей).
	//for (int i=1; i<iend; i++) 
	for (int i = 1; i < iendret; i++)
	{
	    residual_history[i]=residual_history[i]/residual_history[0];
	}
	residual_history[0]=1.0;

	//for (int i=0; i<iend; i++) 
	for (int i = 1; i < iendret; i++)
	{
	    printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	}
	delete residual_history;
	

	

	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	

	exporttecplot(u, xf, yf, M, N);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	getchar();

} // start 2

// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
void startMESFETonlypotencial() {

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	Real ug=-29.07; // напряжение на затворе.
	Real ud=290.7; // напряжение на стоке.
	Real xendsource=0.084; // позиция конца истока.
	Real xstartgate=0.168; // позиция начала затвора
	Real xendgate=0.252; // позиция конца затвора
	Real xstartdrain=0.336; // позиция начала стока.
	// 0.42 конечное значение.
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

    Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(M+1));
	Real h2=(Real)(lengthy/(N+1));

	Real* xf=new Real[M+2];
	for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}
	Real* yf=new Real[N+2];
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}

	

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER

	

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_universal(rthdsd_internal, M, N);

	// Шаблоны для граничных условий.
	load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);


	printf("Multigrd Fedorenko 1961 algorithm \n");
	my_alloc(u, u_old, r, rthdsd, A, M, N);
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);
	if (!bnonlinear) {
		// геометрия неизменна и свойства материалов постоянны
		// поэтому матрица собирается только один раз перед началом счёта.
	    constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
	}
	for (int i=0; i<M+2; i++) {
		for (int j=0; j<N+2; j++) {
			r[i][j]=0.0;
			rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		}
	}
	constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.


	// Метод MICCG отказывается работать в 2D если есть краевые условия Неймана.
	//itsolve_krjlov(u, u_old, r, rthdsd, M, N, ICCGalg, A, (int)(1.3*sqrt((float)(M+2)*(N+2))) );

	
	int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);

	load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);
	// Для вспомогательной системы имеем однородные граничные условия.
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	if (!bnonlinear) {
		// геометрия неизменна и свойства материалов постоянны
		// поэтому матрица собирается только один раз перед началом счёта.
	    constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	}
	for (int i=0; i<MC+2; i++) {
		for (int j=0; j<NC+2; j++) {
			r_coarse[i][j]=0.0;
			rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		}
	}
	
	int iend=3000;
	Real *residual_history=new Real[iend+1];
	for (int i=0; i<iend; i++) {
	   residual_history[i]=1.0; // инициализация.
	}
	itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1e-5,residual_history);

	// нормированная октаэдрическая норма (сумма модулей).
	for (int i=1; i<iend; i++) {
	    residual_history[i]=residual_history[i]/residual_history[0];
	}
	residual_history[0]=1.0;

	for (int i=0; i<iend; i++) {
	    printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	}
	delete residual_history;
	
	

	

	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	

	exporttecplot(u, xf, yf, M, N);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	getchar();

} // startMESFETonlypotencial


void universalgradx(Real** u, Real** &uf_x, Real* x, int m, int n) {
	for (int i=0; i<m+1; i++) {
	   	for (int j=0; j<=(n+1); j++) {
			// uf_x=diff(u,x);
			uf_x[i][j]=(u[i+1][j]-u[i][j])/(x[i+1]-x[i]);
		}
	}
	   
} // universalgradx

void universalgrady(Real** u, Real** &uf_y, Real* y, int m, int n) {
	for (int i=0; i<=(m+1); i++) {
	   	for (int j=0; j<(n+1); j++) {
			// uf_y=diff(u,y);
			uf_y[i][j]=(u[i][j+1]-u[i][j])/(y[j+1]-y[j]);
		}
	}	   
} // universalgrady

void universalgrady_mapx(Real** u, Real** uf_y, Real** &uf_y_mapx, int m, int n) {
	for (int i=0; i<m+1; i++) {
	   	for (int j=0; j<=(n+1); j++) {
			if ((j>0)&&(j<n+1)) {
			    uf_y_mapx[i][j]=0.25*(uf_y[i][j]+uf_y[i][j-1]+uf_y[i+1][j]+uf_y[i+1][j-1]);
			}
			else if (j==0) {
				uf_y_mapx[i][j]=0.5*(uf_y[i][j]+uf_y[i+1][j]);
			}
			else {
				uf_y_mapx[i][j]=0.5*(uf_y[i][j-1]+uf_y[i+1][j-1]);
			}
		}
	}
} // universalgrady_mapx

void universalgradx_mapy(Real** u, Real** uf_x, Real** &uf_x_mapy, int m, int n) {
	for (int i=0; i<=(m+1); i++) {
	   	for (int j=0; j<n+1; j++) {
			if ((i>0)&&(i<m+1)) {
			    uf_x_mapy[i][j]=0.25*(uf_x[i][j]+uf_x[i-1][j]+uf_x[i][j+1]+uf_x[i-1][j+1]);
			}
			else if (i==0) {
				uf_x_mapy[i][j]=0.5*(uf_x[i][j]+uf_x[i][j+1]);
			}
			else {
				uf_x_mapy[i][j]=0.5*(uf_x[i-1][j]+uf_x[i-1][j+1]);
			}
		}
	}
} // universalgradx_mapy


// возвращает квадрат вещественного числа.
Real sqr(Real r) {
	return r*r;
} // sqr

// Раздельный решатель (расщепление) для решения Диффузионно-Дрейфовой модели.
// применённый для моделирования MESFET в динамике.
// материал Кремний.
void startMESFETSi() {

	
	inithashtable(); // обязательная инициализация hash table.

#if MY_FLOAT    
	// V
	Real ug=-1.0f; // напряжение на затворе. -1V
	Real ud=10.0f; //50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17f; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0f; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4f; // позиция конца истока.
	Real xstartgate=3.0e-4f; // позиция начала затвора
	Real xendgate=5.0e-4f; // позиция конца затвора
	Real xstartdrain=7.0e-4f; // позиция начала стока.
	lengthx=9.0e-4f; // протяжённость всей моделируемой области.
	lengthy=0.3e-4f; // высота канала.
#else
	// V
	Real ug=-8.0; // напряжение на затворе. -1V
	Real ud=101.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.
#endif
	
	
	FILE *fp;
	errno_t err1;
	
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		//printf("ND=%e\n",Nd);
		//getchar();
		fclose(fp);
	}
	

	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы :
	const Real epsilonSi=11.9;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	
	//const Real mu_Si=700; // подвижность электронов в кремнии. 
	//const Real mu_Si=5.5e6*exp(-1.5*log(Tamb)); // подвижность электронов в кремнии. 
	// В действительности подвижность зависит также и от концентрации, поэтому :
    const Real mu_Si=1400*exp(-1.5*log(Tamb/300.0))/(1.0+sqrt(Nd/1.0e17)); // подвижность электронов в кремнии. 
	//Real K1=3858.51; // Безразмерный комплекс.
	Real K1=elementary_q/epsilon0/epsilonSi;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_Si*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonSi*epsilon0/(elementary_q*Nd*mu_Si); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
    dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//600; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** ux_alternative;
	Real** uy_alternative;
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N);
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	// Альтернативное вычисление полескоростной характеристики,
	// более экономичное по количеству арифметических операций.
	my_alloc_universal(ux_alternative, M, N);
	my_alloc_universal(uy_alternative, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	FILE *fp_statistic;
	errno_t err_stat;

	if ((err_stat=fopen_s(&fp_statistic,"statistic.txt","w"))!=0) {
		printf("Not Found and open file statistic.txt\n");
		getchar();
		exit(0);
	}



	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				      SORDirichlet(u, rthdsd, A, URF, M, N);
                 }
				 
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
            // exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			 if (0) {
	         // Найдём компоненты скорости не ограниченной сверху они параллельны градиету потенциала :
	         calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 // Напряжённости же поля противоположны градиенту потенциала.
					 ex[i][j]=-x_vel[i][j];
					 ey[i][j]=-y_vel[i][j];
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
			 }
			

	         // Применение реальной полескоростной характеристики кремния :
	         //const Real K2=9.821e-6;
			 //const Real vsat=1.6e7; // скорость насыщения cm/s
			 //const Real K2=mu_Si/vsat;
			 /*
			 if (0) {
    	     for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/(1.0+K2*vel_mag[i][j]);
			        y_vel[i][j]=mu_Si*y_vel[i][j]/(1.0+K2*vel_mag[i][j]);
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }
			 }
			 */

			 // Полескоростная характеристика сверенная с ЗИ:
			 // В действительности скорость насыщения также зависит от температуры.
			 const Real vsat300=1.0e7;
			 const Real An_vsat=0.26;
			 const Real vsat=vsat300/((1.0-An_vsat)+An_vsat*(Tamb/300.0)); // скорость насыщения cm/s
			 const Real K2=mu_Si/vsat;
			  if (0) {
    	     for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
			        y_vel[i][j]=mu_Si*y_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }
			 }

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			  /* Отладочная проверка.
			  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 u[i][j]=yf[j]; // xf[i];
				 }
			  }
			  */


			  // В данном варианте поддерживаются скорости на двух сетках:
			  // На первой сетке скорость хранится на фейсах смещённых по x на пол ячейки.
			  // На второй сетке скорость хранится на фейсах смещенных по y на пол ячейки.

			 // компоненты скорости на шахматной сетке
			  // Компоненты скорости соноправлены с градиентом потенциала,
			  // в то время как напряжённость электрического поля направлена строго противоположно.
			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			 /*
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/(1.0+K2*sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j])));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/(1.0+K2*sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j])));
		         }
	         }*/

			
			 /*
			 // Рабочий вариант до использования hash table.
			 // Полескоростная характеристика сверенная с ЗИ:
			 // Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j])))))));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j])))))));
		         }
	         }
			 */

			 
			 // Вариант с использованием хэш таблицы.
			 // Полескоростная характеристика сверенная с ЗИ:
			 // Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					  Real keyEmag=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/SiliconDriftVel(keyEmag, K2);
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					  Real keyEmag=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/SiliconDriftVel(keyEmag, K2);
		         }
	         }
			 


			  /* При этом способе присутствуют осцилляции концентрации с шагом сетки.
			  // Хотя этот метод более экономичен по машинному времени.
			  // Алтернативное вычисление компонент дрейфовой скорости.
			  calc_gradx(ux_alternative,u,xf,yf,M,N);
			  calc_grady(uy_alternative,u,xf,yf,M,N);
			  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real vmag=sqrt(sqr(ux_alternative[i][j])+sqr(uy_alternative[i][j]));
					 // VX
					 Real vx=mu_Si*ux_alternative[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vmag)))));
					 // VY
					 Real vy=mu_Si*uy_alternative[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vmag)))));
					 // полескоростная характеристика :
					 ux_alternative[i][j]=vx;
					 uy_alternative[i][j]=vy;
                      
		         }
	         }

			  for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=0.5*(ux_alternative[i][j]+ux_alternative[i+1][j]);
				 }
			  }

			   for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=0.5*(uy_alternative[i][j]+uy_alternative[i][j+1]);
				 }
			   }
			   */
			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(curent_x[i][j]*curent_x[i][j]+curent_y[i][j]*curent_y[i][j]);
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			//load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn,rthdsdn, M, N); 
			load_my_bound_n4(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn,rthdsdn, M, N);

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

			// exporttecplot(n,xf,yf,M,N);

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/
	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
		Real igate_loc=0.0; // ток затвора.
		Real iout_loc=0.0; // ток через все остальные границы.
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
			if ((xf[i]>xstartgate)&&(xf[i]<xendgate)) {
				igate_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			}
			if (((xf[i]>=xendsource)&&(xf[i]<=xstartgate))||((xf[i]>=xendgate)&&(xf[i]<=xstartdrain))) {
				iout_loc+=fabs((K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]));
			}
            iout_loc+=fabs((K300Dn*(n[i][1]-n[i][0])/(yf[1]-yf[0])-0.5*(n[i][1]+n[i][0])*y_vel_face_sn[i][0])*0.5*(xf[i+1]-xf[i-1]));
	    }
		for (int j=1; j<N+1; j++) {
			// боковые стенки : левая граница.
			iout_loc+=fabs((K300Dn*(n[1][j]-n[0][j])/(xf[1]-xf[0])-0.5*(n[1][j]+n[0][j])*x_vel_face_we[0][j])*0.5*(yf[j+1]-yf[j-1]));
			// боковые стенки : правая граница.
			iout_loc+=fabs((K300Dn*(n[M+1][j]-n[M][j])/(xf[M+1]-xf[M])-0.5*(n[M+1][j]+n[M][j])*x_vel_face_we[M][j])*0.5*(yf[j+1]-yf[j-1]));
		}
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		//printf("%d%% %f %1.4f %1.4f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))),0.1*elementary_q*isource_loc,0.1*elementary_q*igate_loc); // ток на 1мм ширины затвора.
		printf("%d%% %f %1.4f %1.4f %1.4f %1.4f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))),0.1*elementary_q*isource_loc, 0.1*elementary_q*idrain_loc, 0.1*elementary_q*igate_loc, 0.1*elementary_q*iout_loc); // ток на 1мм ширины затвора.

        fprintf(fp_statistic,"%d %e %e %e %e\n",inumbertimestep,0.1*elementary_q*isource_loc, 0.1*elementary_q*idrain_loc,0.1*elementary_q*igate_loc,0.1*elementary_q*iout_loc);


	} // конец шагов по времени.

	
	fclose(fp_statistic);

	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

    // Сверено с ЗИ.
	// В действительности скорость насыщения также зависит от температуры.
	const Real vsat300=1.0e7;
	const Real An_vsat=0.26;
	const Real vsat=vsat300/((1.0-An_vsat)+An_vsat*(Tamb/300.0)); // скорость насыщения cm/s
	// const Real vsat=1.0e7; // скорость насыщения cm/s
	 const Real K2=mu_Si/vsat;
	 calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
			        y_vel[i][j]=mu_Si*y_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }

	if (1) {
			  // найдём токи
		// Сверено с Федотовым стр. 648. 
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
		     // именно скорости так как она направлена по градиенту потенциала, в то время как напряжённость поля 
	    	// направлена в противоположную сторону против градиента потенциала.
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 //напряжённость же электрического поля направлена противоположно вектору скорости против градиента потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		printf("Not Found and open file task.txt\n");
		// данные записаны не будут
	}
	else {
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		fclose(fp);
	}

    // Освобождение оперативной памяти.
	my_free_universal(ux_alternative,M,N);
	my_free_universal(uy_alternative,M,N);
	

    printf("source=%f\n", isource);
    printf("drain=%f\n", idrain);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
    //getchar();

} // startMESFETSi



void dichtomiq_kvasiField_Si(Real mu_Si, Real neg, Real elementary_q, Real taue, Real nu, Real K2, Real &kvasiFieldMag)
{
	// правая часть.
	Real rthdsd=0.0;
	
	
	

	Real ra=0.0;
	Real rb=8.0e12;
	Real x=ra;

	if (nu<=0.0) {
		x=0.0;
	}
	else {

		if (fabs(neg)>1.0e-17)
	    {
		    // 1e6 1e7 = 1e13
		    // 7e10 1.6e16 1e-17=1e9
		    // taue - сокращается, в терминах nu.
	       // rthdsd=nu/elementary_q/taue/neg;
			rthdsd=nu/(elementary_q*taue*neg);
	    }
		else {
			printf("error ! dichtomiq kvazifield neg is zero.");
			getchar();
		}

	    while (fabs(x-0.5*(ra+rb))>1.0e-10) {

              x=0.5*(ra+rb);
			  // начинать лучше с правой границы чтобы стремиться к минимальному значению поля.
		      if ((rb*(mu_Si*rb/SiliconDriftVel(rb, K2))-rthdsd)*(x*(mu_Si*x/SiliconDriftVel(x, K2))-rthdsd)>0.0) {
			      rb=x;
		      }
		      else {
			      ra=x;
		      }
		      // printf("rthdsd=%e %e\n",rthdsd,x);

	    }
	}
    //	getchar();

	// возвращаем найденное значение 
	kvasiFieldMag=x;

} // dichtomiq_kvasiField_Si



// за 500 шагов устанавливается граничное условие.
Real bound_relax(Real boundval, int i) {
	Real mu=0.005;
	Real r=(Real)(mu*i);
	if (fabs(boundval)>1.0e-10) {
	if (boundval>0.0) {
	    r=2.0*r/(1.0+r/boundval);
	}
	else {
		r=-2.0*r/(1.0+r/fabs(boundval));
	}
	}
	else r=0.0;

	return r;
}

// исправляет глюки визуализации не укладывающиеся в представления пользователя-физика.
void forZub(Real Nd,Real** u, Real** &nu, Real energy_source, Real** kvasiFieldMag, Real taue, Real** ex, Real** ey, Real** emag, Real** &neg, Real** &x_vel, Real** &y_vel, Real** &vel_mag, Real** curent_x, Real** curent_y, Real** curent_mag, Real* x, Real* y, int m, int n)
{
	for (int j=0; j<n+2; j++) for (int i=0; i<m+2; i++)   {
		// Делаем так чтобы не было отрицательных температур.
		if (nu[i][j]<=0.0) {
			nu[i][j]=0.0;
		}
	}
		// Делаем так чтобы не было концентраций превышающих
		// концентрацию доноров на истоке и стоке.
		Real min_neg=Nd;
		for (int j=0; j<n+2; j++) {
			for (int i=0; i<m+2; i++)   {
		   if (neg[i][j]>Nd) {
			   neg[i][j]=Nd;
			   if (neg[i][j]<min_neg) {
			    	min_neg=neg[i][j];
			   }
		   }
			}
		}
		Real mag_vel=0.0;
		Real abs_x_vel=0.0;
		Real abs_y_vel=0.0;
		bool bvisit = false;
		for (int j=0; j<n+2; j++) {
			for (int i=0; i<m+2; i++) 
			{
			if (log(neg[i][j])>log(min_neg+0.2*(Nd-min_neg)) ){
				bvisit = true;
				if (vel_mag[i][j]>mag_vel) {
					mag_vel=vel_mag[i][j];
				}
				if (fabs(x_vel[i][j])>abs_x_vel) {
				     abs_x_vel=fabs(x_vel[i][j]);
				}
				if (fabs(y_vel[i][j])>abs_y_vel) {
				     abs_y_vel=fabs(y_vel[i][j]);
				}
			}
			}
		}
        for (int j=0; j<n+2; j++) {
			for (int i=0; i<m+2; i++)   {
				if (bvisit) {
					if (vel_mag[i][j]>mag_vel) {
						vel_mag[i][j] = mag_vel;
					}

					if (fabs(x_vel[i][j])>abs_x_vel) {
						if (x_vel[i][j] > 0.0) {
							x_vel[i][j] = abs_x_vel;
						}
						else {
							x_vel[i][j] = -abs_x_vel;
						}
					}

					if (fabs(y_vel[i][j]) > abs_y_vel) {
						if (y_vel[i][j] > 0.0) {
							y_vel[i][j] = abs_y_vel;
						}
						else {
							y_vel[i][j] = -abs_y_vel;
						}
					}
				}
			}
		}

	
}

/* План реализации квазигидродинамической модели:
* 1. Добавляем уравнение энергии с граничными условиями, но без источникового члена генерации и релаксации.
* 2. Добавляем в уравнеие энергии правую часть. В итоге получаем как энергия зависит от поля.
* 3. Замыкаем систему уравнений с помощью введения квазиполя как предложил Гарбер. С помощью квазиполя находим как
* подвижность зависит от энергии и коэффициент диффузии зависит от энергии.
* 3.1. Внимаение меняется только подвижность, а коэффициент диффузии пересчитывается через подвижность.
* Для подвижности существуют пять различных вариантов. Перечислим их :
* вариант 1. Энергия газа меньше энергии решетки (это возможно на первых итерациях где пока всё далеко от сходимости и распределения
* не имеют физического смысла). Поле E меньше значения 100В/см. Тогда в качестве подвижности берется просто константа mu_300K (
* в общем та подвижность которая зависит от температуры и концентрации доноров по литературным данным.
* вариант 2. Энергия газа меньше энергии решетки (это возможно на первых итерациях где пока всё далеко от сходимости и распределения
* не имеют физического смысла). Поле E больше значения 100В/см. Тогда подвижность будет такая как по литературным данным т.е. зависящая от 
* температуры и концентрации плюс еще ограничена сверху (из-за эффекта насыщения скорости дрейфа (т.е. подвижность при сильных полях уменьшится
* согласно насыщению скорости дрейфа). mu=mu300/sqrt(1.0+mu300*abs(E)/vsat);
* вариант 3. Энергия газа больше либо равна энергии решетки (именно такой режим и установится в реальности и будет иметь физический смысл,
* но это не означает что в программе не нужно прописывать первые два варианта). Поля Е и F (квазиполе) меньше 100В/см. Тогда подвижность 
* берется просто константой mu300 по литературным данным (зависит от концентрации доноров и от температуры решетки). 
* вариант 4. Энергия газа больше либо равна энергии решетки (именно такой режим и установится в реальности и будет иметь физический смысл,
* но это не означает что в программе не нужно прописывать первые два варианта). Поле Е больше чем 100В/см, а квазиполе F меньше чем 100В/см. 
* В этом случае работает обычная ДДМ модель в которой прописан эффект насыщения скорости дрейфа. Т.е. подвижность такая-же как и в варианте 2,
* т.е. mu=mu300/sqrt(1.0+mu300*abs(E)/vsat);
* вариант 5. Энергия газа больше либо равна энергии решетки (именно такой режим и установится в реальности и будет иметь физический смысл,
* но это не означает что в программе не нужно прописывать первые два варианта). Поле Е больше чем 100В/см, а квазиполе F также больше 100В/см.
* В этом случае работает ИДДМ Гарбера. А именно подвижность вычисляется по формуле : mu=(abs(F)/abs(E))*(mu300/sqrt(1.0+mu300*abs(F)/vsat));
* Если умножить данную подвижность на градиент потенциала то мы получим нужную скорость дрейфа.
* На этом случаи рассмотрения различных вариантов для подвижности закончены.
* Пробуем для простого случя : однородное легирование и простой материал. 
* 4. Переносим пункты 1-3 на сложный профиль легирования и группу материалов.
*/
// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Кремний.
// Версия PARIS2 содержащее третье уравнение для энергии электронного газа.
void startMESFETSiPARIS2()
{

	amgGM.a = NULL;
	amgGM.f = NULL;
	amgGM.ia = NULL;
	amgGM.ig = NULL;
	amgGM.ja = NULL;
	amgGM.u = NULL;

	
	inithashtable(); // обязательная инициализация hash table.

#if MY_FLOAT    
	// V
	Real ug=-1.0f; // напряжение на затворе. -1V
	Real ud=10.0f; //50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17f; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0f; // температура полупроводника.
	const Real k_bolcman=1.38066e-23f;
	Real energy_source=1.5f*k_bolcman*Tamb; // однородное граничное условие Дирихле для nu
	Real taue=1.0e-12f; // 1пс время релаксации энергии.

	// cm
	Real xendsource=2.0e-4f; // позиция конца истока.
	Real xstartgate=3.0e-4f; // позиция начала затвора
	Real xendgate=5.0e-4f; // позиция конца затвора
	Real xstartdrain=7.0e-4f; // позиция начала стока.
	lengthx=9.0e-4f; // протяжённость всей моделируемой области.
	lengthy=0.3e-4f; // высота канала.
#else
	// V
	Real ug=-8.0; // напряжение на затворе. -1V
	Real ud=101.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.
	const Real k_bolcman=1.38066e-23;
	Real energy_source=1.5*k_bolcman*Tamb; // однородное граничное условие Дирихле для nu
	Real taue=1.0e-12; // 1пс время релаксации энергии.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.
#endif
	
	
	FILE *fp;
	errno_t err1;

	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		//printf("ND=%e\n",Nd);
		//getchar();
		fclose(fp);
	}

	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha_u=1.0; // решили без нижней релаксации для потенциала.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.
	Real alphanu=0.1; // нижняя релаксация для решения уравнения переноса энергии электронного газа.
	int iendnu=1; // количество итераций для решения уравнения  энергии электронного газа.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы :
	const Real epsilonSi=11.9;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	
	
	//const Real mu_Si=700; // подвижность электронов в кремнии. 
	//const Real mu_Si=5.5e6*exp(-1.5*log(Tamb)); // подвижность электронов в кремнии. 
	// В действительности подвижность зависит также и от концентрации, поэтому :
	// подвижность зависит от концентрации и от температуры решетки.
    const Real mu_Si=1400*exp(-1.5*log(Tamb/300.0))/(1.0+sqrt(Nd/1.0e17)); // подвижность электронов в кремнии. 
	//Real K1=3858.51; // Безразмерный комплекс.
	Real K1=elementary_q/(epsilon0*epsilonSi);
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_Si*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonSi*epsilon0/(elementary_q*Nd*mu_Si); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	printf("Si modelling\n");
	printf("solving is : 0.5 tauM UDS. NO artifical diffusion !\n");

	// Будем ли использовать алгебраический многосеточный метод.
	bool buse_amg1r5 = true;
	if (buse_amg1r5) {
		printf("use Algebraic Multigrid Method Fedorenko R.P. 1961 (amg1r5 code.)\n");
	}




	dtimestep=0.5*tauM;
	//dtimestep=6.0*tauM;
   // dtimestep=8000.0*tauM;
	int imaxnumbertimestep=1500; //600; // количество шагов по времени. 1500
	int inumberinternaliter=30; // количество итераций на временном слое.

	if (buse_amg1r5) {
		imaxnumbertimestep = 2000;
		inumberinternaliter = 1; // безитерационный
		alpha = 0.8;
		alphanu = 0.8;
	}


	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;
	int ialgnu=SEIDEL; // алгоритм для переноса энергии электронов.
	

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** ux_alternative;
	Real** uy_alternative;
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ
	Real** nu; // здесь nu есть функция от энергии электронного газа : nu=n*(u-energy_source)/taue;
	Real** nu_oldi; // nu с предыдущей итерации.
	Real** nu_old; // nu с предыдущего временного слоя.
	Real** rthdsdnu; // правая часть для nu.
	Real** rnu; 
	Real** rthdsd_internalnu;
	MATRNODE** Anu; // матрица СЛАУ для nu.
	Real** kvasiFieldMag; // квазиполе. 
	Real** energy_mobility; // подвижность зависящая от энергии и определяемая через квазиполе.
	Real** energy_K300Dn; // коэффициент диффузии завиящий от подвижности.

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	// для алгебраического многосеточного метода:
	Real *dX0 = new Real[(M + 2)*(N + 2)];


	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	TBONCONDOMAIN my_boundnu; // Граничные условия для энергии.
	printf("compleate tolerance source drain gate out \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_bound(my_boundnu,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N);
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	// Альтернативное вычисление полескоростной характеристики,
	// более экономичное по количеству арифметических операций.
	my_alloc_universal(ux_alternative, M, N);
	my_alloc_universal(uy_alternative, M, N);
	my_alloc_universal(energy_mobility, M, N); // подвижность зависящая от энергии и определяемая через квазиполе.
	my_alloc_universal(energy_K300Dn, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(kvasiFieldMag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);
	// Выделение памяти под энергию электронного газа.
	my_alloc(nu, nu_oldi, rnu, rthdsdnu, Anu, M, N);
	//my_alloc_universal(nu, M, N);
	my_alloc_universal(nu_old, M, N);
	//my_alloc_universal(nu_oldi, M, N);
	//my_alloc_universal(rthdsdnu, M, N);
	//my_alloc_universal(rnu, M, N);
	my_alloc_universal(rthdsd_internalnu, M, N);


	//my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, Nd, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);

	// инициализация функции, выраженной через энергию.
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, nu, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, nu_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, nu_oldi, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, rnu, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, rthdsdnu, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, rthdsd_internalnu, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	FILE *fp_statistic;
	errno_t err_stat;

	if ((err_stat=fopen_s(&fp_statistic,"statistic.txt","w"))!=0) {
		printf("Not Found and open file statistic.txt\n");
		getchar();
		exit(0);
	}


	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	bool bminus=false;
	
	int compleate=0;
	printf("%d%%",compleate);

	const bool iddm_Garber=true;

	Real time=0.0;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	         // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				 for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
		                 // A[i][j].ap/=alpha_u;				                        
		                  
		             }
		         }
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
					 // нижняя релаксация для потенциала
					 //rthdsd_internal[i][j]+=A[i][j].ap*(1.0-alpha_u)*u[i][j];
		         }
	         }



			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	        //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);
			 // bound_relax(, inumbertimestep);
			// constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, bound_relax(ug, inumbertimestep), bound_relax(ud, inumbertimestep), xendsource, xstartgate, xendgate, xstartdrain);
	
             
			 

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.


				 if (buse_amg1r5) {
					 //amg_loc_memory(u,rthdsd, A,M, N,0,dX0);
					 amg_global_memory(u, rthdsd, A, M, N, 0, dX0);
				 }
				 else {

					 // itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
					 for (int i = 0; i < iend; i++) {
						 // Метод Гаусса, Зейделя, Ричардсона, Либмана
						// Seidel(u, rthdsd, A, M, N);
						 // метод последовательной верхней релаксации с коэффициентом 1.855.
						 Real URF = 1.855;
						 SORDirichlet(u, rthdsd, A, URF, M, N);
					 }
				 }
				 
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
            // exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			 // Обязательно нужный кусок кода !!!
	         // Найдём компоненты скорости не ограниченные сверху они соноправлены градиенту потенциала :
	         calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 // Напряжённости поля противоположны градиенту потенциала.
					 ex[i][j]=-x_vel[i][j];
					 ey[i][j]=-y_vel[i][j];
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
			
			

	         // Применение реальной полескоростной характеристики кремния :
	         //const Real K2=9.821e-6;
			 //const Real vsat=1.6e7; // скорость насыщения cm/s
			 //const Real K2=mu_Si/vsat;
			 /*
			 if (0) {
    	     for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/(1.0+K2*vel_mag[i][j]);
			        y_vel[i][j]=mu_Si*y_vel[i][j]/(1.0+K2*vel_mag[i][j]);
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }
			 }
			 */

			 // Полескоростная характеристика сверенная с ЗИ:
			 // В действительности скорость насыщения также зависит от температуры.
			 const Real vsat300=1.0e7;
			 const Real An_vsat=0.26;
			 const Real vsat=vsat300/((1.0-An_vsat)+An_vsat*(Tamb/300.0)); // скорость насыщения cm/s
			 const Real K2=mu_Si/vsat;
			 if (0) {
    	         for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
		        	     vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			             x_vel[i][j]=mu_Si*x_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
			             y_vel[i][j]=mu_Si*y_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
					     vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		             }
	             }
			 }

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			  /* Отладочная проверка.
			  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 u[i][j]=yf[j]; // xf[i];
				 }
			  }
			  */


			  // В данном варианте поддерживаются скорости на двух сетках:
			  // На первой сетке скорость хранится на фейсах смещённых по x на пол ячейки.
			  // На второй сетке скорость хранится на фейсах смещенных по y на пол ячейки.

			 // компоненты скорости на шахматной сетке
			 // Компоненты скорости соноправлены с градиентом потенциала,
			 // в то время как напряжённость электрического поля направлена строго противоположно.
			 // Vx Vy
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			 /*
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/(1.0+K2*sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j])));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/(1.0+K2*sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j])));
		         }
	         }*/

			
			 /*
			 // Рабочий вариант до использования hash table.
			 // Полескоростная характеристика сверенная с ЗИ:
			 // Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j])))))));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j])))))));
		         }
	         }
			 */

			 
			 // Вариант с использованием хэш таблицы.
			 // Полескоростная характеристика сверенная с ЗИ:
			 /*
			 // Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					  Real keyEmag=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/SiliconDriftVel(keyEmag, K2);
                      y_vel_face_we[i][j]=mu_Si*y_vel_face_we[i][j]/SiliconDriftVel(keyEmag, K2);
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					  Real keyEmag=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/SiliconDriftVel(keyEmag, K2);
					  x_vel_face_sn[i][j]=mu_Si*x_vel_face_sn[i][j]/SiliconDriftVel(keyEmag, K2);
		         }
	         }
			 */
			 
			 // модель Г.З. Гарбера.
			 // если iddm_Garber

			 

			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real keyEmag=kvasiFieldMag[i][j];
					 Real Emag_loc=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					
					 if (!iddm_Garber) {
						 if (Emag_loc<1.0e2) {
						         energy_mobility[i][j]=mu_Si; 
						 }
						 else {
							 // эффект насыщения скорости дрейфа при больших полях.
							 energy_mobility[i][j]=mu_Si/SiliconDriftVel(Emag_loc, K2);
						 }
					 }
					
					 if (iddm_Garber) {
						 if (nu[i][j]<=0.0) {
							 // обычная подвижность, та которая используется в диффузионно дрейфовой модели.
							 if (Emag_loc<1.0e2) {
						         energy_mobility[i][j]=mu_Si; 
						     }
						     else {
							     // эффект насыщения скорости дрейфа при больших полях.
							     energy_mobility[i][j]=mu_Si/SiliconDriftVel(Emag_loc, K2);
						     }
						 }
						 else {

							 // Подвижность вычисляется на основе квазипеоля при любом Emag_loc.
							  if (fabs(keyEmag)<100.0) {
								  // Слабое квазиполе обычная подвижность при слабых полях.
								  energy_mobility[i][j]=mu_Si;
							  }
							  else {
								  // Сильные квазиполя подвижность вычисленная по модулю квазиполя с учётом насыщения.
							     energy_mobility[i][j]=mu_Si/SiliconDriftVel(fabs(keyEmag), K2);
							  }

							 /*
							 // Этот вариант перемудрён, слишком надуман, см разговор с Гарбером.
							 if (Emag_loc<100.0) {
								 // малые поля : скорость дрейфа пропорциональна градиенту потенциала.
								   energy_mobility[i][j]=mu_Si;
							 }
							 else {
								 if (fabs(keyEmag)<100.0) {
									 // малые значения квазиполя.
									 // переходим к ДДМ модели.
									 //Real keychangeE2F=fabs(keyEmag)/Emag_loc;
									 //energy_mobility[i][j]=mu_Si*keychangeE2F;
									 energy_mobility[i][j]=mu_Si/SiliconDriftVel(Emag_loc, K2);
								 }
								 else {
								     // Нельзя подставлят напряженность поля вместо квазполя, скорости дрейфа будут превышать vsaturation.
									 // С другой стороны скорости могут быть боьше чем скорости дрейфа в равновесном состояни (при коротких затворах) 
									 // Явление overshoot но это только при высоких температурах электронного газа.
								     //Real keychangeE2F=fabs(keyEmag)/Emag_loc;
			                         //energy_mobility[i][j]=(mu_Si*keychangeE2F)/SiliconDriftVel(keyEmag, K2);
									 // С другой стороны в выражении для тока фигурирует именно напряженность электрического поля
									 // А от скалярной величины (квазиполе) зависит лишь скалярная величина подвижность и 
									 energy_mobility[i][j]=mu_Si/SiliconDriftVel(fabs(keyEmag), K2);
								 }
							 }
							 */
						 }
					 }
					 
					 energy_K300Dn[i][j]=k_bolcman*Tamb*energy_mobility[i][j]/elementary_q;
				 }
			}
			 
			
			 // Дрейфовая скорость может быть и больше скорости насыщения, 
			 // это так называемый overshoot в квазигидродинамической модели Г.З. Гарбера.

			 // Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 
					 Real mobil;
					  if (fabs((energy_mobility[i][j] + energy_mobility[i+1][j]))<1.0e-3) {
						   mobil=0.5*(energy_mobility[i][j] + energy_mobility[i+1][j]);
					  }
					  else {
						  mobil=2.0*(energy_mobility[i][j]*energy_mobility[i+1][j])/(energy_mobility[i][j] + energy_mobility[i+1][j]);
					  }
                      // универсальная форма записи, подходит как для малых так и для больших полей, все хранится в подвижности.
					  // одинаково подхлодит как для модели Гарбера так и для обычной ДДМ.
                      x_vel_face_we[i][j]*=mobil;
                      y_vel_face_we[i][j]*=mobil;

		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					
					  Real mobil;
					  if (fabs((energy_mobility[i][j] + energy_mobility[i][j+1]))<1.0e-3) {
						  mobil=0.5*(energy_mobility[i][j] + energy_mobility[i][j+1]);
					  }
					  else {
						  mobil=2.0*(energy_mobility[i][j]*energy_mobility[i][j+1])/(energy_mobility[i][j] + energy_mobility[i][j+1]);
					  }

					  
                      // универсальная форма записи, подходит как для малых так и для больших полей, все хранится в подвижности.
                      // одинаково подхлодит как для модели Гарбера так и для обычной ДДМ.
					  y_vel_face_sn[i][j]*=mobil;
					  x_vel_face_sn[i][j]*=mobil;     						
					 
		         }
	         }
			 
            


			  /* При этом способе присутствуют осцилляции концентрации с шагом сетки.
			  // Хотя этот метод более экономичен по машинному времени.
			  // Алтернативное вычисление компонент дрейфовой скорости.
			  calc_gradx(ux_alternative,u,xf,yf,M,N);
			  calc_grady(uy_alternative,u,xf,yf,M,N);
			  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real vmag=sqrt(sqr(ux_alternative[i][j])+sqr(uy_alternative[i][j]));
					 // VX
					 Real vx=mu_Si*ux_alternative[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vmag)))));
					 // VY
					 Real vy=mu_Si*uy_alternative[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vmag)))));
					 // полескоростная характеристика :
					 ux_alternative[i][j]=vx;
					 uy_alternative[i][j]=vy;
                      
		         }
	         }

			  for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=0.5*(ux_alternative[i][j]+ux_alternative[i+1][j]);
				 }
			  }

			   for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=0.5*(uy_alternative[i][j]+uy_alternative[i][j+1]);
				 }
			   }
			   */
			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0)
			 {
			    // найдём токи
			    calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			    for (int i=0; i<M+2; i++) {
	    	        for (int j=0; j<N+2; j++) {
					    curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					    curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					    curent_mag[i][j]=sqrt(curent_x[i][j]*curent_x[i][j]+curent_y[i][j]*curent_y[i][j]);
				    }
			    }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			//load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn,rthdsdn, M, N); 
			//load_my_bound_n3(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn,rthdsdn, M, N);
			 // без противопоточного ограничителя на диагональное преобладание в ap.
			//load_my_bound_n5(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn,rthdsdn, M, N);
			// содержит дополнительную нижнюю релаксацию для условия ток равен нулю.
			//load_my_bound_n6(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn,rthdsdn,alpha,n, M, N);
			load_my_bound_n7(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn,rthdsdn, M, N);

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			//constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);	
			constrAPatankarMESFET3(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, energy_K300Dn, xf, yf, M, N);

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

			 if (buse_amg1r5) {
				 //amg_loc_memory(n,rthdsdn, An,M, N,1,dX0);
				 amg_global_memory(n, rthdsdn, An, M, N, 1, dX0);
			 }
			 else {
				 //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
				 for (int i = 0; i < iendn; i++) {
					 Seidel(n, rthdsdn, An, M, N);
				 }
			 }

			 // exporttecplot(n,xf,yf,M,N);


			 // Решение  уравнения переноса энергии электронного газа.

           
			 //load_my_bound_nu2(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, K300Dn, rthdsdnu, M, N); 
			 //load_my_bound_nu3(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, M, N); 
			 // без противопоточного ограничителя на диагональное преобладание в ap.
			 //load_my_bound_nu5(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, M, N); 
			 // содержит дополнительную нижнюю релаксацию для условия ток равен нулю.
			 //load_my_bound_nu6(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, alphanu, nu, M, N); 
	         load_my_bound_nu7(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, M, N); 
	
		
		
			 
			// constrAPatankarMESFET2(Anu, my_boundnu, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				
			 constrAPatankarMESFET3(Anu, my_boundnu, x_vel_face_we, y_vel_face_sn, 1.0, energy_K300Dn, xf, yf, M, N);
			
			 

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             nu_oldi[i][j]=nu[i][j];
		         }
	         }

			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // невязка.
					 rnu[i][j]=0.0;
					 // правая часть.
					 // плотности токов.
					// Real jx=K300Dn*nx[i][j]-n[i][j]*0.5*(x_vel_face_we[i-1][j]+x_vel_face_we[i][j]);
					// Real jy=K300Dn*ny[i][j]-n[i][j]*0.5*(y_vel_face_sn[i][j-1]+y_vel_face_sn[i][j]);
					 Real jx=energy_K300Dn[i][j]*nx[i][j]-n[i][j]*0.5*(x_vel_face_we[i-1][j]+x_vel_face_we[i][j]);
					 Real jy=energy_K300Dn[i][j]*ny[i][j]-n[i][j]*0.5*(y_vel_face_sn[i][j-1]+y_vel_face_sn[i][j]);
					 // мощность тепловыделения и диссипация.
					 rthdsd_internalnu[i][j]=(elementary_q*(ex[i][j]*jx+ey[i][j]*jy)-nu[i][j]/taue)*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             Anu[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internalnu[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*nu_old[i][j]/dtimestep;
			         }
		         }
		     }

			 // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             Anu[i][j].ap/=alphanu;				                        
		             rthdsd_internalnu[i][j]+=Anu[i][j].ap*(1.0-alphanu)*nu_oldi[i][j];
		         }
		     }

			 constrrthdsd0MESFETnu(rthdsdnu, rthdsd_internalnu, my_boundnu, xf, yf, M, N); // правая часть.


			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 Anu[i][0].ap/=alphanu;				                        
		         rthdsdnu[i][0]+=Anu[i][0].ap*(1.0-alphanu)*nu_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 Anu[0][j].ap/=alphanu;				                        
		         rthdsdnu[0][j]+=Anu[0][j].ap*(1.0-alphanu)*nu_oldi[0][j];
				 Anu[M+1][j].ap/=alphanu;				                        
		         rthdsdnu[M+1][j]+=Anu[M+1][j].ap*(1.0-alphanu)*nu_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  Anu[i][N+1].ap/=alphanu;				                        
		              rthdsdnu[i][N+1]+=Anu[i][N+1].ap*(1.0-alphanu)*nu_oldi[i][N+1];
			     }
		     }

			 if (buse_amg1r5) {
				 //amg_loc_memory(nu,rthdsdnu, Anu,M, N, 2, dX0);
				 amg_global_memory(nu, rthdsdnu, Anu, M, N, 2, dX0);
			 }
			 else {

				 for (int i = 0; i < iendnu; i++) {
					 Seidel(nu, rthdsdnu, Anu, M, N);
				 }
			 }

			 // минимальное значение nu во внутренности.
			 Real nu_min_internal=1.0e40;
             for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
					 if (nu[i][j]<nu_min_internal) {
                         nu_min_internal=nu[i][j];
					 }
				 }
             }

			 // Находим квазиполе:
			 for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
					 // Мы решим нелинейное уравнение методом половинного деления.
					 /*
					 if ((j==N+1)&&(xf[i]<=xendsource)) {
						 // Нулевое nu
						 dichtomiq_kvasiField_Si(mu_Si, n[i][j], elementary_q, taue, nu_min_internal, K2, kvasiFieldMag[i][j]);
					 }
					 else {
					     dichtomiq_kvasiField_Si(mu_Si, n[i][j], elementary_q, taue, nu[i][j], K2, kvasiFieldMag[i][j]);
					 }*/
					 dichtomiq_kvasiField_Si(mu_Si, n[i][j], elementary_q, taue, nu[i][j], K2, kvasiFieldMag[i][j]);
				 }
			 }


		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

		 //	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
				nu_old[i][j]=nu[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/
	

		Real idrain_loc=0.0;   // ток стока.
    	Real isource_loc=0.0; // ток истока.
		Real igate_loc=0.0;  // ток затвора.
		Real iout_loc=0.0;  // ток через внешний контур.
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
			if ((xf[i]>xstartgate)&&(xf[i]<xendgate)) {
				//igate_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
                igate_loc+=fabs(((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]));
			}
			if (((xf[i]>=xendsource)&&(xf[i]<=xstartgate))||((xf[i]>=xendgate)&&(xf[i]<=xstartdrain))) {
                iout_loc+=fabs(((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]));
			}
			iout_loc+=fabs(((2.0*energy_K300Dn[i][0]*energy_K300Dn[i][1]/(energy_K300Dn[i][0]+energy_K300Dn[i][1]))*(n[i][1]-n[i][0])/(yf[1]-yf[0])-0.5*(n[i][1]+n[i][0])*y_vel_face_sn[i][0])*0.5*(xf[i+1]-xf[i-1]));
	     }
		for (int j=1; j<N+1; j++) {
			iout_loc+=fabs(((2.0*energy_K300Dn[0][j]*energy_K300Dn[1][j]/(energy_K300Dn[0][j]+energy_K300Dn[1][j]))*(n[1][j]-n[0][j])/(xf[1]-xf[0])-0.5*(n[1][j]+n[0][j])*x_vel_face_we[0][j])*0.5*(yf[j+1]-yf[j-1]));
	        iout_loc+=fabs(((2.0*energy_K300Dn[M+1][j]*energy_K300Dn[M][j]/(energy_K300Dn[M+1][j]+energy_K300Dn[M][j]))*(n[M+1][j]-n[M][j])/(xf[M+1]-xf[M])-0.5*(n[M+1][j]+n[M][j])*x_vel_face_we[M][j])*0.5*(yf[j+1]-yf[j-1]));
		}
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
			Real diviation=10.0;
			if ((fabs(isource_loc)>1.0e-20)&&(fabs(idrain_loc)>1.0e-20)) {
			if (fabs(isource_loc)>fabs(idrain_loc)) {
				diviation=fabs(idrain_loc)/fabs(isource_loc);
			}
			else {
				diviation=fabs(isource_loc)/fabs(idrain_loc);
			}
			}
		if ((fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005)&&((diviation<1.1)&&(diviation>0.9))) {
			// досрочное прекращение вычислений
			 //inumbertimestep=imaxnumbertimestep+1;
			 //  break;
			 printf("diviation=%e",diviation);
			//getchar();
		}}
		else {
			// возможно нулевой ток.
			//if (inumbertimestep>70) break;
			printf("zero current");
			getchar();
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <1000) {
			printf("\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <10000) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b\b");
		}
		// запас.
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		if (bminus) printf("\b");
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		printf("%d%% %f %1.4f %1.4f %1.4f %1.4f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))),0.1*elementary_q*isource_loc, 0.1*elementary_q*idrain_loc, 0.1*elementary_q*igate_loc, 0.1*elementary_q*iout_loc); // ток на 1мм ширины затвора.
		if (isource_loc<0.0) {
			bminus=true;
		}
		else {
			bminus=false;
		}

		if (compleate>85) {
			break;
		}

		fprintf(fp_statistic,"%d %e %e %e %e\n",inumbertimestep,0.1*elementary_q*isource_loc, 0.1*elementary_q*idrain_loc,0.1*elementary_q*igate_loc,0.1*elementary_q*iout_loc);
	} // конец шагов по времени.

	

	fclose(fp_statistic);
	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */



	 // модель Г.З. Гарбера.
	 // если iddm_Garber

			 
	// Сверено с ЗИ.
	// В действительности скорость насыщения также зависит от температуры.
	const Real vsat300=1.0e7;
	const Real An_vsat=0.26;
	const Real vsat=vsat300/((1.0-An_vsat)+An_vsat*(Tamb/300.0)); // скорость насыщения cm/s
	// const Real vsat=1.0e7; // скорость насыщения cm/s
	 const Real K2=mu_Si/vsat;
	for (int i=0; i<M+2; i++) {
	    for (int j=0; j<N+2; j++) {
	    	 Real keyEmag=kvasiFieldMag[i][j];
			 Real Emag_loc=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					
			 if (!iddm_Garber) {
				 if (Emag_loc<1.0e2) {
			         energy_mobility[i][j]=mu_Si; 
				 }
				 else {
					 // эффект насыщения скорости дрейфа при больших полях.
					 energy_mobility[i][j]=mu_Si/SiliconDriftVel(Emag_loc, K2);
				 }
			 }
					
			 if (iddm_Garber) {
				 if (nu[i][j]<=0.0) {
					 // обычная подвижность, та которая используется в диффузионно дрейфовой модели.
					 if (Emag_loc<1.0e2) {
				         energy_mobility[i][j]=mu_Si; 
				     }
				     else {
					     // эффект насыщения скорости дрейфа при больших полях.
					     energy_mobility[i][j]=mu_Si/SiliconDriftVel(Emag_loc, K2);
				     }
				 }
				 else {

					 // Подвижность зависит лишь от квазиполя.
					 if (fabs(keyEmag)<100.0) {
						 energy_mobility[i][j]=mu_Si;
					 }
					 else {
						 energy_mobility[i][j]=mu_Si/SiliconDriftVel(fabs(keyEmag), K2);
					 }

					 // После разговора с Гарбером этот вариант считается перемудрённым
					 // и поэтому он закоментирован.
					 /*if (Emag_loc<100.0) {
						 // малые поля : скорость дрейфа пропорциональна градиенту потенциала.
		   			     energy_mobility[i][j]=mu_Si;
					 }
					 else {
						 if (fabs(keyEmag)<100.0) {
						 // малые значения квазиполя.
						 // переходим к ДДМ модели.
						 //Real keychangeE2F=fabs(keyEmag)/Emag_loc;
						 //energy_mobility[i][j]=mu_Si*keychangeE2F;
						 energy_mobility[i][j]=mu_Si/SiliconDriftVel(Emag_loc, K2);
					 }
					 else {
					     // Нельзя подставлят напряженность поля вместо квазполя, скорости дрейфа будут превышать vsaturation.
						 // С другой стороны скорости могут быть боьше чем скорости дрейфа в равновесном состояни (при коротких затворах) 
						 // Явление overshoot но это только при высоких температурах электронного газа.
					     //Real keychangeE2F=fabs(keyEmag)/Emag_loc;
			             //energy_mobility[i][j]=(mu_Si*keychangeE2F)/SiliconDriftVel(keyEmag, K2);
					     // С другой стороны в выражении для тока фигурирует именно напряженность электрического поля
						 // А от скалярной величины (квазиполе) зависит лишь скалярная величина подвижность и 
						 energy_mobility[i][j]=mu_Si/SiliconDriftVel(fabs(keyEmag), K2);
					     }
				   }*/
			   }
			}
					 
		    energy_K300Dn[i][j]=k_bolcman*Tamb*energy_mobility[i][j]/elementary_q;
		}
	}
			 



	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	    // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

    
	 calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
                    // Универсальное значение подвижности было вычислено раньше 
					 // в ходе вычислительного процесса.

                    x_vel[i][j]*=energy_mobility[i][j];
					y_vel[i][j]*=energy_mobility[i][j];
					/*
					if (j<N+1) {
					    y_vel[i][j]*=energy_mobility[i][j];
					}
					else {
						y_vel[i][j]*=0.5*(energy_mobility[i][j]+energy_mobility[i][j-1]);
					}*/
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					
		         }
	         }



	if (1) {
			  // найдём токи
		// Сверено с Федотовым стр. 648. 
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 // Универсальное значение коэффициента диффузии было вычислено раньше 
					 // в ходе вычислительного процесса.

					 curent_x[i][j]=elementary_q*(energy_K300Dn[i][j]*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(energy_K300Dn[i][j]*ny[i][j]-n[i][j]*y_vel[i][j]);
					 /*
if (j<N+1) {
					 curent_y[i][j]=elementary_q*(energy_K300Dn[i][j]*ny[i][j]-n[i][j]*y_vel[i][j]);
}
else {
	 curent_y[i][j]=elementary_q*(0.5*(energy_K300Dn[i][j]+energy_K300Dn[i][j-1])*ny[i][j]-n[i][j]*y_vel[i][j]);
}
*/
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
		     // именно скорости так как она направлена по градиенту потенциала, в то время как напряжённость поля 
	         // направлена в противоположную сторону против градиента потенциала.
	        
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 //напряжённость же электрического поля направлена противоположно вектору скорости против градиента потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

	   // Делаем визуализацию более физичной.	
	   forZub( Nd, u, nu, energy_source, kvasiFieldMag, taue, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	
    	exporttecplotMESFET4(u, nu, energy_source, kvasiFieldMag, taue, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);

		/*
		// Проверка вычисления напряженностей электрического поля.
		// ugradx ugrady
		universalgradx(u, x_vel_face_we, xf, M, N);
		// печать градиента.
		exporttecplot(x_vel_face_we,xf,yf,M-1,N);
		universalgrady(u, y_vel_face_sn, yf, M, N);
		exporttecplot(y_vel_face_sn, xf, yf, M, N-1);
		universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
		exporttecplot(y_vel_face_we, xf, yf, M-1, N);
		universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
		exporttecplot(x_vel_face_sn, xf, yf, M, N-1);
		*/
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		printf("Not Found and open file task.txt\n");
		// данные записаны не будут
	}
	else {
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		fclose(fp);
	}

    // Освобождение оперативной памяти.
	my_free_universal(ux_alternative,M,N);
	my_free_universal(uy_alternative,M,N);
	my_free_universal(kvasiFieldMag, M, N);
	my_free_universal(energy_mobility, M, N); // подвижность зависящая от энергии и определяемая через квазиполе.
	my_free_universal(energy_K300Dn, M, N);

	// Внутренние переменные алгебраического многосеточного метода.
	delete[] dX0;
	dX0 = NULL;

	if (amgGM.a != NULL) {
		delete[] amgGM.a;
	}
	if (amgGM.f != NULL) {
		delete[] amgGM.f;
	}
	if (amgGM.ia != NULL) {
		delete[] amgGM.ia;
	}
	if (amgGM.ig != NULL) {
		delete[] amgGM.ig;
	}
	if (amgGM.ja != NULL) {
		delete[] amgGM.ja;
	}
	if (amgGM.u != NULL) {
		delete[] amgGM.u;
	}

	bfirst_use_amgGM = true;


	

    printf("source=%f\n", isource_loc);
    printf("drain=%f\n", idrain_loc);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
    getchar();

} // startMESFETSiPARIS2






// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Кремний.
void startMESFETSi_VAX() {

	inithashtable(); // обязательная инициализация hash table.
    
	// V
	Real ug=-8.0; // напряжение на затворе. -1V
	Real ud=101.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.

	
	
	FILE *fp;
	errno_t err1;

	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}

	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы :
	const Real epsilonSi=11.9;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	
	//const Real mu_Si=700; // подвижность электронов в кремнии. 
	//const Real mu_Si=5.5e6*exp(-1.5*log(Tamb)); // подвижность электронов в кремнии. 
	// В действительности подвижность зависит также и от концентрации, поэтому :
    const Real mu_Si=1400*exp(-1.5*log(Tamb/300.0))/(1.0+sqrt(Nd/1.0e17)); // подвижность электронов в кремнии. 
	//Real K1=3858.51; // Безразмерный комплекс.
	Real K1=elementary_q/epsilon0/epsilonSi;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_Si*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonSi*epsilon0/(elementary_q*Nd*mu_Si); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
    dtimestep=8000.0*tauM;
	int imaxnumbertimestep=10000;//600; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N);
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;

	FILE *fpvax;
	errno_t err2;

	if ((err2=fopen_s(&fpvax,"vetka.txt","r"))!=0) {
		printf("Not Found and open file vekta.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {

		if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		     printf("Not Found and open file task.txt\n");
		     // данные записаны не будут
	     }
	     else {

			 int dincount=0;
			 fscanf_s(fpvax, "%d", &dincount);
		
			 for (int ivd=0; ivd<dincount; ivd++) {

				 float fin;
				 fscanf_s(fpvax, "%f", &fin);
				 ud=fin;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				      SORDirichlet(u, rthdsd, A, URF, M, N);
                 }
				 
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			if (0) {
	         // Найдём компоненты скорости не ограниченной сверху они параллельны градиету потенциала :
	         calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 // Напряжённости же поля противоположны градиенту потенциала.
					 ex[i][j]=-x_vel[i][j];
					 ey[i][j]=-y_vel[i][j];
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
			 }
			

	         // Применение реальной полескоростной характеристики кремния :
	         //const Real K2=9.821e-6;
			 //const Real vsat=1.6e7; // скорость насыщения cm/s
			 //const Real K2=mu_Si/vsat;
			 /*
			 if (0) {
    	     for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/(1.0+K2*vel_mag[i][j]);
			        y_vel[i][j]=mu_Si*y_vel[i][j]/(1.0+K2*vel_mag[i][j]);
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }
			 }
			 */

			 // Полескоростная характеристика сверенная с ЗИ:
			 // В действительности скорость насыщения также зависит от температуры.
			 const Real vsat300=1.0e7;
			 const Real An_vsat=0.26;
			 const Real vsat=vsat300/((1.0-An_vsat)+An_vsat*(Tamb/300.0)); // скорость насыщения cm/s
			 const Real K2=mu_Si/vsat;
			  if (0) {
    	     for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
			        y_vel[i][j]=mu_Si*y_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }
			 }

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			  // В данном варианте поддерживаются скорости на двух сетках:
			  // На первой сетке скорость хранится на фейсах смещённых по x на пол ячейки.
			  // На второй сетке скорость хранится на фейсах смещенных по y на пол ячейки.

			 // компоненты скорости на шахматной сетке

			  // Компоненты скорости соноправлены с градиентом потенциала,
			  // в то время как напряжённость электрического поля направлена строго противоположно.

			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			 /*
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/(1.0+K2*sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j])));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/(1.0+K2*sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j])));
		         }
	         }*/
			 /*
			 // Рабочий вариант полескоростной характеристики без использования хэш таблицы.
			 // Полескоростная характеристика сверенная с ЗИ:
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j])))))));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j])))))));
		         }
	         }
			 */

			 // Вариант с использованием хэш таблицы.
			 // Полескоростная характеристика сверенная с ЗИ:
			 // Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					  Real keyEmag=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/SiliconDriftVel(keyEmag, K2);
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					  Real keyEmag=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/SiliconDriftVel(keyEmag, K2);
		         }
	         }

			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(curent_x[i][j]*curent_x[i][j]+curent_y[i][j]*curent_y[i][j]);
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn,rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/
	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		printf("%d%% %f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

    // Сверено с ЗИ.
	// В действительности скорость насыщения также зависит от температуры.
	const Real vsat300=1.0e7;
	const Real An_vsat=0.26;
	const Real vsat=vsat300/((1.0-An_vsat)+An_vsat*(Tamb/300.0)); // скорость насыщения cm/s
	// const Real vsat=1.0e7; // скорость насыщения cm/s
	 const Real K2=mu_Si/vsat;
	 calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
			        y_vel[i][j]=mu_Si*y_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }

	if (1) {
			  // найдём токи
		// Сверено с Федотовым стр. 648. 
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

		if (1) {
	         // Найдём компоненты скорости :
		     // именно скорости так как она направлена по градиенту потенциала, в то время как напряжённость поля 
	    	// направлена в противоположную сторону против градиента потенциала.
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 //напряжённость же электрического поля направлена противоположно вектору скорости против градиента потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм


		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		
	
	

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

   }

}

   }

   // закрытие файлов :
   fclose(fpvax);
   fclose(fp);
	

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();

} // startMESFETSi_VAX


//**************** Gauss *******************************
// код очень быстрого Пуассоновксого солвера который учитывает то, что матрица 
// СЛАУ не меняется в процессе вычислений!!!


// План запуска !!!
// 1. завести две переменные : Real** Gauss_M=NULL; Real** dCik=NULL; Real* Gauss_b=NULL; Real* Gauss_x=NULL;
// 2. (единожды!!!) запустить :
// constr_matr(Gauss_M, dCik, Gauss_b, Gauss_x, A, M, N);
// а также : eqsolve_lenta_gauss_only_matrix(Gauss_M, (M+2)*(N+2), M+2, dCik);

// 3. многократные запуски следующего обратного хода :
// copy_vector(rthdsd, Gauss_b, M, N); // прямое копирование.
// eqsolve_lenta_gauss_obratnji_hod(Gauss_M, dCik, M, N, Gauss_b, Real* &x);
// copy_vector_inverse(u, Gauss_x, M, N);

// 4. По окончании работы программы произвести полную зачистку оперативной памяти.
// free_matr(Gauss_M, dCik, Gauss_b, Gauss_x,  M, N);

// сборка матрицы для ленточного метода гаусса из матрицы ADiff.
void free_matr(Real** &Gauss_M, Real** &dCik, Real* &Gauss_b, Real* &Gauss_x,  int m, int n) {
	// Внимание : однократное выделение оперативной памяти :
	if (Gauss_b!=NULL) {
	   delete Gauss_b;
	   Gauss_b=NULL;
	}
	if (Gauss_x!=NULL) {
	   delete Gauss_x;
	   Gauss_x=NULL;
	}
	if (Gauss_M!=NULL) {
	   for (int i=0; i<(m+2)*(n+2); i++) {
		   delete Gauss_M[i];
	   }
	   delete Gauss_M;
	   Gauss_M=NULL;
	}
	if (dCik!=NULL) {
	   for (int i=0; i<(m+2); i++) {
		   delete dCik[i];
	   }
	   delete dCik;
	   dCik=NULL;
	}
}

// сборка матрицы для ленточного метода гаусса из матрицы ADiff.
void constr_matr(Real** &Gauss_M, Real** &dCik, Real* &Gauss_b, Real* &Gauss_x, MATRNODE** A, int m, int n) {
	// Внимание : однократное выделение оперативной памяти :
	if (Gauss_b==NULL) {
    	Gauss_b=new Real[(m+2)*(n+2)];
	}
	if (Gauss_x==NULL) {
	    Gauss_x=new Real[(m+2)*(n+2)];
	}
	if (Gauss_M==NULL) {
	   Gauss_M=new Real*[(m+2)*(n+2)];
	   for (int i=0; i<(m+2)*(n+2); i++) {
		   Gauss_M[i]=new Real[2*(m+2)+1];
       }
	}
	if (dCik==NULL) {
	   dCik=new Real*[m+2];
	   for (int i=0; i<(m+2); i++) {
		   dCik[i]=new Real[(m+2)*(n+2)];
	   }
	}
	// инициализация :
	for (int i=0; i<(m+2)*(n+2); i++) {
		for (int j=0; j<2*(m+2)+1; j++) {
			Gauss_M[i][j]=0.0;
		}
	}
	for (int i=0; i<(m+2); i++) {
	    for (int j=0; j<(m+2)*(n+2); j++) {
		    dCik[i][j]=0.0; // обязательное обнуление !!!.
	    }
	}
	// Заполнение :
	for (int i=1; i<m+1; i++) {
		for (int j=1; j<n+1; j++) {
			int is=i+j*(m+2);
			Gauss_M[is][m+2+1-1]=-A[i][j].ap;
			Gauss_M[is][m+2+1+((i+1)+j*(m+2))-(is)-1]=A[i][j].ae;
			Gauss_M[is][m+2+1+((i-1)+j*(m+2))-(is)-1]=A[i][j].aw;
			Gauss_M[is][m+2+1+((i)+(j+1)*(m+2))-(is)-1]=A[i][j].an;
			Gauss_M[is][m+2+1+((i)+(j-1)*(m+2))-(is)-1]=A[i][j].as;
		}
	}
	for (int i=1; i<m+2-1; i++) {
		int j=0;
		int is=i+j*(m+2);
		Gauss_M[is][m+2+1-1]=-A[i][j].ap;
		Gauss_M[is][m+2+1+((i)+(j+1)*(m+2))-(is)-1]=A[i][j].an;
		j=n+2-1;
		is=i+j*(m+2);
		Gauss_M[is][m+2+1-1]=-A[i][j].ap;
		Gauss_M[is][m+2+1+((i)+(j-1)*(m+2))-(is)-1]=A[i][j].as;
	}
	for (int j=1; j<n+2-1; j++) {
		int i=0;
		int is=i+j*(m+2);
		Gauss_M[is][m+2+1-1]=-A[i][j].ap;
		Gauss_M[is][m+2+1+((i+1)+j*(m+2))-(is)-1]=A[i][j].ae;
		i=m+2-1;
		is=i+j*(m+2);
		Gauss_M[is][m+2+1-1]=-A[i][j].ap;
		Gauss_M[is][m+2+1+((i-1)+j*(m+2))-(is)-1]=A[i][j].aw;
	}
	{
		int i=0;
		int j=0;
		int is=i+j*(m+2);
        Gauss_M[is][m+2+1-1]=-A[i][j].ap;
		Gauss_M[is][m+2+1+((i+1)+j*(m+2))-(is)-1]=A[i][j].ae;
		Gauss_M[is][m+2+1+((i)+(j+1)*(m+2))-(is)-1]=A[i][j].an;
		i=m+2-1;
		j=0;
		is=i+j*(m+2);
		Gauss_M[is][m+2+1-1]=-A[i][j].ap;
		Gauss_M[is][m+2+1+((i-1)+(j)*(m+2))-(is)-1]=A[i][j].aw;
		Gauss_M[is][m+2+1+((i)+(j+1)*(m+2))-(is)-1]=A[i][j].an;
		i=m+2-1;
		j=n+2-1;
		is=i+j*(m+2);
		Gauss_M[is][m+2+1-1]=-A[i][j].ap;
		Gauss_M[is][m+2+1+((i)+(j-1)*(m+2))-(is)-1]=A[i][j].as;
        Gauss_M[is][m+2+1+((i-1)+j*(m+2))-(is)-1]=A[i][j].aw;
		i=0;
		j=n+2-1;
		is=i+j*(m+2);
		Gauss_M[is][m+2+1-1]=-A[i][j].ap;
		Gauss_M[is][m+2+1+((i+1)+j*(m+2))-(is)-1]=A[i][j].ae;
		Gauss_M[is][m+2+1+((i)+(j-1)*(m+2))-(is)-1]=A[i][j].as;
	}
}

/*
void copy_matr(Real** &Gauss_M_orig, Real** &Gauss_M_copy,
			   MESH* &mgmesh, int il)
{
	for (int i=0; i<mgmesh[il].inx*mgmesh[il].iny; i++) {
		for (int j=0; j<2*mgmesh[il].inx+1; j++) {
			Gauss_M_copy[i][j]=Gauss_M_orig[i][j];
		}
	}
}
*/
void copy_vector(Real** &u, Real* &u_c, int m, int n) {
	for (int i=0; i<m+2; i++) {
		for (int j=0; j<n+2; j++) {
			int is=i+j*(m+2);
			// проверено : здесь нужен минус.
			u_c[is]=-u[i][j];
		}
	}
}

void copy_vector_inverse(Real** &u, Real* &u_c, int m, int n) {
	for (int i=0; i<m+2; i++) {
		for (int j=0; j<n+2; j++) {
			int is=i+j*(m+2);
			u[i][j]=u_c[is];
		}
	}
}




/* метод Гаусса для ленточной матрицы A размером
*              nodes x 2*icolx+1, где
*   2*icolx+1 - ширина ленты. Под тем что матрица
*  A ленточная понимается то что ненулевые элементы
*  матрицы содержатся только внутри ленты.
*  b - вектор правой части СЛАУ, x - вектор решение.
*  Нумерация элементов начинается с нуля.
*  Для положительно определённых возможно несимметричных
*  матриц А, которые задаются своей лентой.
*  Гаусс Карл Фридрих 1777-1855.
*  В результате работы матрица А портится.
*/
// метод only_matrix преобразует только матрицу СЛАУ,
// зависит только от матрицы и вызывается лишь единожды при
// неизменной матрице СЛАУ в процессе решения.
// В процессе делается матрица dCik размером icolx x nodes,
// память под неё предполагается выделенной заранее.
// Внимание : перед началом вычисления dCik должно быть строго заполнено нулевыми значениями.
// Диагональный элемент в матрице А должен быть строго отрицательным.
void eqsolve_lenta_gauss_only_matrix(Real** &A, int nodes, int icolx, Real** &dCik) {

	

	// Преобразуется матрица А и заполняется матрица dCik зависящая только от А.

	const Real eps=FLT_MIN; // для сравнения с нулём
	Real  dSum=0.0;
	int max;

	int *move=new int[nodes]; // массив сдвигов.
	int i=0, j=0, k=0; // счётчики цикла for
	for (i=0; i<nodes; i++) move[i]=icolx-i; // инициализация массива сдвигов

	

	// прямой ход метода Гаусса
	// приведение к верхнему треугольному виду:

	// по всем столбцам слева направо
	for (k=0; k<nodes; k++) {
        max=imin(k+icolx,nodes-1);
		// цикл по всем строкам ниже строки с номером k
       // #pragma omp parallel for private(i,j) shared(k,max,move,eps,A,dCik)
		for (i=k+1; i<=max; i++) {
			// применяется только в том случае
			// если элемент ненулевой
			// это должно несколько ускорить счёт.
			if (fabs(A[i][k+move[i]]) > eps) {
               
                if(fabs(A[k][k+move[k]])<eps){
			          // решение не может быть получено, т.к.
			          // на диагонали находится ноль.
	                  printf("\nSolution is not exist! divizion by zero...\n");
	                  getchar();
		              //exit(0);
	            }

                // обработка фиксированной строки с номером i
				dCik[i-(k+1)][k]=A[i][k+move[i]]/A[k][k+move[k]];
				// преаобразование матрицы к верхнетреугольному виду:
				for (j=k; j<=max; j++) A[i][j+move[i]] -= dCik[i-(k+1)][k]*A[k][j+move[k]];
			}
		}
	}

	delete move;

}  // eqsolve_lenta_gauss_only_matrix


/* метод Гаусса для ленточной матрицы A размером
*              nodes x 2*icolx+1, где
*   2*icolx+1 - ширина ленты. Под тем что матрица
*  A ленточная понимается то что ненулевые элементы
*  матрицы содержатся только внутри ленты.
*  b - вектор правой части СЛАУ, x - вектор решение.
*  Нумерация элементов начинается с нуля.
*  Для положительно определённых возможно несимметричных
*  матриц А, которые задаются своей лентой.
*  Гаусс Карл Фридрих 1777-1855.
*  В результате работы матрица А портится.
*/
// Обратный ход запускается многократно  требует линейного времени !.
void eqsolve_lenta_gauss_obratnji_hod(Real ** &A, Real** &dCik, int m, int n, Real* &b, Real* &x) {

	// b - правая часть.
	// x - результат

	int nodes=(m+2)*(n+2);
	int icolx=m+2;

	const Real eps=FLT_MIN; // для сравнения с нулём
	Real  dSum=0.0;
	int max;

	int *move=new int[nodes]; // массив сдвигов.
	int i=0, j=0, k=0; // счётчики цикла for
	for (i=0; i<nodes; i++) move[i]=icolx-i; // инициализация массива сдвигов

	for (i=0; i<nodes; i++) x[i]=0.0; // инициализация

	// прямой ход метода Гаусса
	// приведение к верхнему треугольному виду:

	//omp_set_num_threads(2);

	// по всем столбцам слева направо
	for (k=0; k<nodes; k++) {
        max=imin(k+icolx,nodes-1);
		// цикл по всем строкам ниже строки с номером k
      //   #pragma omp parallel for private(i) shared(k,max,eps,b,dCik)
		for (i=k+1; i<=max; i++) {
				b[i]-= dCik[i-(k+1)][k]*b[k]; // преобразование правой части
		}
	}

    // Теперь когда матрица приведена к верхнетреугольному виду
	// можно совершить обратный ход метода Гаусса:
	for (k=nodes-1; k>=0; k--) {
        dSum=0.0; // обнуление сумматора
		max=imin(k+icolx,nodes-1);
        //#pragma omp parallel for shared(max,k,A,x,move) private (i) reduction(+:dSum)
		for (i=k+1; i<=max; i++) {
			dSum+= A[k][i+move[k]]*x[i];
		}
		x[k]=(b[k]-dSum)/A[k][k+move[k]];
	}

	delete move;

}  // eqsolve_lenta_gauss_obratnji_hod

/* метод Гаусса для ленточной матрицы A размером
*              nodes x 2*icolx+1, где
*   2*icolx+1 - ширина ленты. Под тем что матрица
*  A ленточная понимается то что ненулевые элементы
*  матрицы содержатся только внутри ленты.
*  b - вектор правой части СЛАУ, x - вектор решение.
*  Нумерация элементов начинается с нуля.
*  Для положительно определённых возможно несимметричных
*  матриц А, которые задаются своей лентой.
*  Гаусс Карл Фридрих 1777-1855.
*  В результате работы матрица А портится.
*/
// Эта реализация оставлена на случай если матрица меняется и есть желание применить прямой метод,
// но этот метод неэкономичен.
void eqsolve_lenta_gauss(Real **A, int nodes, int icolx, Real *b, Real* &x) {

	// b - правая часть.
	// x - результат

	const Real eps=FLT_MIN; // для сравнения с нулём
	Real dCik, dSum=0.0;
	int max;

	int *move=new int[nodes]; // массив сдвигов.
	int i=0, j=0, k=0; // счётчики цикла for
	for (i=0; i<nodes; i++) move[i]=icolx-i; // инициализация массива сдвигов

	for (i=0; i<nodes; i++) x[i]=0.0; // инициализация

	// прямой ход метода Гаусса
	// приведение к верхнему треугольному виду:

	// по всем столбцам слева направо
	for (k=0; k<nodes; k++) {
        max=imin(k+icolx,nodes-1);
		// цикл по всем строкам ниже строки с номером k
       // #pragma omp parallel for private(i,j,dCik) shared(k,max,move,eps,b,A)
		for (i=k+1; i<=max; i++) {
			// применяется только в том случае
			// если элемент ненулевой
			// это должно несколько ускорить счёт.
			if (fabs(A[i][k+move[i]]) > eps) {
               
                if(fabs(A[k][k+move[k]])<eps){
			          // решение не может быть получено, т.к.
			          // на диагонали находится ноль.
	                  printf("\nSolution is not exist! divizion by zero...\n");
	                  getchar();
		              //exit(0);
	            }

                // обработка фиксированной строки с номером i
				dCik=A[i][k+move[i]]/A[k][k+move[k]];
				// преаобразование матрицы к верхнетреугольному виду:
				for (j=k; j<=max; j++) A[i][j+move[i]] -= dCik*A[k][j+move[k]];
				b[i]-= dCik*b[k]; // преобразование правой части
			}
		}
	}

    // Теперь когда матрица приведена к верхнетреугольному виду
	// можно совершить обратный ход метода Гаусса:
	for (k=nodes-1; k>=0; k--) {
        dSum=0.0; // обнуление сумматора
		max=imin(k+icolx,nodes-1);
       // #pragma omp parallel for shared(max,k,A,x,move) private (i) reduction(+:dSum)
		for (i=k+1; i<=max; i++) {
			dSum+= A[k][i+move[k]]*x[i];
		}
		x[k]=(b[k]-dSum)/A[k][k+move[k]];
	}

}  // eqsolve_lenta_gauss
//**************** Gauss *******************************

// очень медленно сходящееся решение.
void start1() {

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time = clock(); // момент начала счёта.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	Real bleft = 0.0; // 400.0;
	Real bright = 0.0; // 300.0;
	Real btop = 0.0; // 300.0;
	Real bbottom = 0.0; // 300.0;
	// Постоянный коэффициент теплопроводности при 300К
	Real K300 = 1.0;

	// Замена SOR на однократное обращение верхнего треугольника.
	Real** Gauss_M = NULL;
	Real** dCik = NULL;
	Real* Gauss_b = NULL;
	Real* Gauss_x = NULL;

	Real** u; // рассчитываемый потенциал.
	Real** etalon; // аналитическое решение для сравнения.
	Real** u_old; // потенциал с предыдущей итерации.
	Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть
	MATRNODE** A; // матрица СЛАУ

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1 = (Real)(lengthx / (M + 1));
	Real h2 = (Real)(lengthy / (N + 1));

	Real* xf = new Real[M + 2];
	for (int i = 0; i < M + 2; i++) {
		xf[i] = (Real)(i * h1);
	}
	Real* yf = new Real[N + 2];
	for (int i = 0; i < N + 2; i++) {
		yf[i] = (Real)(i * h2);
	}

	TBONCONDOMAIN my_bound; // Граничные условия
	// Выделение памяти под граничные условия.
	my_alloc_bound(my_bound, M, N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc_universal(etalon, M, N);

	// Шаблоны для граничных условий.
	int itask = STUDENT; // STUDENT STUDENTA DAVIS CHOHRAVLSKY BLASIUS RALEYBENAR

	load_my_bound_temp(my_bound, itask, xf, yf, M, N);



	printf("naivnji algorithm \n");
	my_alloc(u, u_old, r, rthdsd, A, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, u, M, N);
	if (!bnonlinear) {
		// свойства материалов постоянны.
		// геометрия тоже неизменна поэтому матрица 
		// собирается лишь единожды перед началом счёта.
		constrA0(A, my_bound, K300, xf, yf, M, N); // сборка матрицы.
	}

	my_init_zero(bleft, bright, bbottom, btop, 0.0, etalon, M, N);

	for (int i = 0; i < M + 2; i++) {
		for (int j = 0; j < N + 2; j++) {
			rthdsd_internal[i][j] = 0.0;
		}
	}

	for (int i = 1; i < M + 1; i++) {
		for (int j = 1; j < N + 1; j++) {
			//rthdsd_internal[i][j] = 1.0;

			// аналитическая правая часть.
			//const double M_PI = 3.14159;
			rthdsd_internal[i][j] = - 2.0 * ( M_PI* M_PI) * (cos(2.0*M_PI*xf[i]/lengthx)*sin(M_PI*yf[j]/lengthy)*sin(M_PI * yf[j] / lengthy)+
				cos(2.0 * M_PI * yf[j] / lengthy) * sin(M_PI * xf[i] / lengthx) * sin(M_PI * xf[i] / lengthx));
			// Аналитическое решение.
			etalon[i][j] = sin(M_PI * xf[i] / lengthx) * sin(M_PI * xf[i] / lengthx)*sin(M_PI * yf[j] / lengthy) * sin(M_PI * yf[j] / lengthy);
		}
	}

	constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.

	R_Bellman(M, N, u, rthdsd);
	//R_Bellmanq(M, N, u, rthdsd);

	//DFTq(M, N, u, rthdsd);


	for (int i = 0; i < M + 2; i++) {
		for (int j = 0; j < N + 2; j++) {
			if (mcv) {			

				rthdsd[i][j] *= h1 * h2;
			}
			else {
				// МКР; Сетка предполагается равномерной h1==h2==h.
						
			}
		}
	}

	// Внимание. Алгоритм В.Г. Зверева по видимому пригоден лишь для задач чистой диффузии и более того
	// только для краевых условий Дирихле. Поэтому настоятельно рекомендуется использовать LR.
	// Хотя возможно алгоритм Зверева и допускает модификацию позволяющую ему работать с условиями Неймана
	// но как реализовать эту модификацию пока неизвестно.
	int ialg = LR; // STANDART SEIDEL LR SORDIRICHLET ZVER CGalg BiCGStabalg ICCGalg GMRESalg
    //itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, 1070);
	//Ilyin1985(u, rthdsd, A, M, N, 17000);
	//itsolve_krjlov(u, u_old, r, rthdsd, M, N, ialg, A, 300);//(int)(1.3*sqrt((float)(M+2)*(N+2))) );
	

	// 
	// для алгебраического многосеточного метода amg1r5:
	//Real* dX0 = new Real[(M + 2) * (N + 2)];
	//amg_global_memory(u, rthdsd, A, M, N, 0, dX0);
	//delete[] dX0;
	

	double um = -1.0e30;
	for (int i = 0; i < M + 2; i++) {
		for (int j = 0; j < N + 2; j++) {
			if (u[i][j] > um) {
				um = u[i][j];
			}
		}
	}
	std::cout << "um = " << um;
	//getchar();

	bool bflagconstrA = true;
	bool Gauss_label = false;

	if (Gauss_label) {
		if (bflagconstrA) {
			// Для метода Гаусса, осторожно ресурсоёмко по памяти.
			constr_matr(Gauss_M, dCik, Gauss_b, Gauss_x, A, M, N);
			eqsolve_lenta_gauss_only_matrix(Gauss_M, (M + 2) * (N + 2), M + 2, dCik);
			bflagconstrA = false;
		}


		// 3. многократные запуски следующего обратного хода :
		// Замер времени.
		unsigned int calculation_start_time1; // начало счёта мс.
		unsigned int calculation_end_time1; // окончание счёта мс.
		unsigned int calculation_seach_time1; // время выполнения участка кода в мс.

		calculation_start_time1 = clock(); // момент начала счёта.

		copy_vector(rthdsd, Gauss_b, M, N); // прямое копирование.
		eqsolve_lenta_gauss_obratnji_hod(Gauss_M, dCik, M, N, Gauss_b, Gauss_x);
		copy_vector_inverse(u, Gauss_x, M, N);

		calculation_end_time1 = clock(); // момент начала счёта.

		calculation_seach_time1 = calculation_end_time1 - calculation_start_time1;
		int im1 = 0, is1 = 0, ims1 = 0;
		im1 = (int)(calculation_seach_time1 / 60000); // минуты
		is1 = (int)((calculation_seach_time1 - 60000 * im1) / 1000); // секунды
		ims1 = (int)((calculation_seach_time1 - 60000 * im1 - 1000 * is1)); // /10 миллисекунды делённые на 10
		printf(" %1d:%2d:%3d \n", im1, is1, ims1);
	}
	calculation_end_time = clock();
	calculation_seach_time = calculation_end_time - calculation_start_time;
	int im = 0, is = 0, ims = 0;
	im = (int)(calculation_seach_time / 60000); // минуты
	is = (int)((calculation_seach_time - 60000 * im) / 1000); // секунды
	ims = (int)((calculation_seach_time - 60000 * im - 1000 * is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	getchar();

	//exporttecplot(u, xf, yf, M, N);
	exporttecplot(u,etalon, xf, yf, M, N);
} // start1

// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Кремний.
void startMESFETSi_Gauss() {

	inithashtable(); // обязательная инициализация hash table.

 #if MY_FLOAT  
	// V
	Real ug=-1.0f; // напряжение на затворе. -1V
	Real ud=10.0f;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17f; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0f; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4f; // позиция конца истока.
	Real xstartgate=3.0e-4f; // позиция начала затвора
	Real xendgate=5.0e-4f; // позиция конца затвора
	Real xstartdrain=7.0e-4f; // позиция начала стока.
	lengthx=9.0e-4f; // протяжённость всей моделируемой области.
	lengthy=0.3e-4f; // высота канала.
#else
	// V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.
#endif
	
	
	FILE *fp;
	errno_t err1;

	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}

	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы :
	const Real epsilonSi=11.9;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	
	//const Real mu_Si=700; // подвижность электронов в кремнии. 
	//const Real mu_Si=5.5e6*exp(-1.5*log(Tamb)); // подвижность электронов в кремнии. 
	// В действительности подвижность зависит также и от концентрации, поэтому :
    const Real mu_Si=1400*exp(-1.5*log(Tamb/300.0))/(1.0+sqrt(Nd/1.0e17)); // подвижность электронов в кремнии. 
	//Real K1=3858.51; // Безразмерный комплекс.
	Real K1=elementary_q/epsilon0/epsilonSi;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_Si*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonSi*epsilon0/(elementary_q*Nd*mu_Si); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	// Для диффузионно дрейфовой модели шаг по времени можно увеличить на 4 порядка.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=10000;//600; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;
	// Замена SOR на однократное обращение верхнего треугольника.
	Real** Gauss_M=NULL;
	Real** dCik=NULL;
	Real* Gauss_b=NULL;
	Real* Gauss_x=NULL;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N);
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				// Для метода Гаусса, осторожно ресурсоёмко по памяти.
				constr_matr(Gauss_M, dCik, Gauss_b, Gauss_x, A, M, N);
                eqsolve_lenta_gauss_only_matrix(Gauss_M, (M+2)*(N+2), M+2, dCik);
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 /*
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				      SORDirichlet(u, rthdsd, A, URF, M, N);
                 }
				 */

				  // 3. многократные запуски следующего обратного хода :
                  copy_vector(rthdsd, Gauss_b, M, N); // прямое копирование.
                  eqsolve_lenta_gauss_obratnji_hod(Gauss_M, dCik, M, N, Gauss_b, Gauss_x);
                  copy_vector_inverse(u, Gauss_x, M, N);
				  //if (inumbertimestep==20) exporttecplot(u,xf,yf,M,N);
				 
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			 if (0) {
	         // Найдём компоненты скорости не ограниченной сверху они параллельны градиету потенциала :
	         calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 // Напряжённости же поля противоположны градиенту потенциала.
					 ex[i][j]=-x_vel[i][j];
					 ey[i][j]=-y_vel[i][j];
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
			 }
			

	         // Применение реальной полескоростной характеристики кремния :
	         //const Real K2=9.821e-6;
			 //const Real vsat=1.6e7; // скорость насыщения cm/s
			 //const Real K2=mu_Si/vsat;
			 /*
			 if (0) {
    	     for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/(1.0+K2*vel_mag[i][j]);
			        y_vel[i][j]=mu_Si*y_vel[i][j]/(1.0+K2*vel_mag[i][j]);
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }
			 }
			 */

			 // Полескоростная характеристика сверенная с ЗИ:
			 // В действительности скорость насыщения также зависит от температуры.
			 const Real vsat300=1.0e7;
			 const Real An_vsat=0.26;
			 const Real vsat=vsat300/((1.0-An_vsat)+An_vsat*(Tamb/300.0)); // скорость насыщения cm/s
			 const Real K2=mu_Si/vsat;
			  if (0) {
    	     for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
			        y_vel[i][j]=mu_Si*y_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }
			 }

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			    // В данном варианте поддерживаются скорости на двух сетках:
			  // На первой сетке скорость хранится на фейсах смещённых по x на пол ячейки.
			  // На второй сетке скорость хранится на фейсах смещенных по y на пол ячейки.


			 // компоненты скорости на шахматной сетке

			  // Компоненты скорости соноправлены с градиентом потенциала,
			  // в то время как напряжённость электрического поля направлена строго противоположно.

			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			 /*
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/(1.0+K2*sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j])));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/(1.0+K2*sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j])));
		         }
	         }*/

			 /*
			 // Полескоростная характеристика, рабочий вариант, без использования хэш таблицы.
			 // Полескоростная характеристика сверенная с ЗИ:
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j])))))));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j])))))));
		         }
	         }
			 */

			  // Вариант с использованием хэш таблицы.
			 // Полескоростная характеристика сверенная с ЗИ:
			 // Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					  Real keyEmag=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/SiliconDriftVel(keyEmag, K2);
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					  Real keyEmag=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/SiliconDriftVel(keyEmag, K2);
		         }
	         }

			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(curent_x[i][j]*curent_x[i][j]+curent_y[i][j]*curent_y[i][j]);
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn,rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/
	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		printf("%d%% %f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

    // Сверено с ЗИ.
	// В действительности скорость насыщения также зависит от температуры.
	const Real vsat300=1.0e7;
	const Real An_vsat=0.26;
	const Real vsat=vsat300/((1.0-An_vsat)+An_vsat*(Tamb/300.0)); // скорость насыщения cm/s
	// const Real vsat=1.0e7; // скорость насыщения cm/s
	 const Real K2=mu_Si/vsat;
	 calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
			        y_vel[i][j]=mu_Si*y_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }

	if (1) {
			  // найдём токи
		// Сверено с Федотовым стр. 648. 
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

		if (1) {
	         // Найдём компоненты скорости :
		     // именно скорости так как она направлена по градиенту потенциала, в то время как напряжённость поля 
	    	// направлена в противоположную сторону против градиента потенциала.
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 //напряжённость же электрического поля направлена противоположно вектору скорости против градиента потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		printf("Not Found and open file task.txt\n");
		// данные записаны не будут
	}
	else {
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		fclose(fp);
	}
	

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

     // Освобождение оперативной памяти из под метода Гаусса.
   free_matr(Gauss_M, dCik, Gauss_b, Gauss_x,  M, N);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();

} // startMESFETSi_Gauss


// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Кремний.
void startMESFETSi_Gauss_VAX() {


	inithashtable(); // обязательная инициализация hash table.
	
#if MY_FLOAT  
	// V
	Real ug=-8.0f; // напряжение на затворе. -1V
	Real ud=101.0f;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17f; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;

	Real Tamb=400.0f; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4f; // позиция конца истока.
	Real xstartgate=3.0e-4f; // позиция начала затвора
	Real xendgate=5.0e-4f; // позиция конца затвора
	Real xstartdrain=7.0e-4f; // позиция начала стока.
	lengthx=9.0e-4f; // протяжённость всей моделируемой области.
	lengthy=0.3e-4f; // высота канала.
#else
	// V
	Real ug=-8.0; // напряжение на затворе. -1V
	Real ud=101.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;

	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.
#endif
	
	
	FILE *fp;
	errno_t err1;

	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		 fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}

	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы :
	const Real epsilonSi=11.9;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	
	//const Real mu_Si=700; // подвижность электронов в кремнии. 
	//const Real mu_Si=5.5e6*exp(-1.5*log(Tamb)); // подвижность электронов в кремнии. 
	// В действительности подвижность зависит также и от концентрации, поэтому :
    const Real mu_Si=1400*exp(-1.5*log(Tamb/300.0))/(1.0+sqrt(Nd/1.0e17)); // подвижность электронов в кремнии. 
	//Real K1=3858.51; // Безразмерный комплекс.
	Real K1=elementary_q/epsilon0/epsilonSi;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_Si*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonSi*epsilon0/(elementary_q*Nd*mu_Si); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	// Для диффузионно дрейфовой модели шаг по времени можно увеличить на 4 порядка.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//600; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;
	// Замена SOR на однократное обращение верхнего треугольника.
	Real** Gauss_M=NULL;
	Real** dCik=NULL;
	Real* Gauss_b=NULL;
	Real* Gauss_x=NULL;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N);
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;

	FILE *fpvax;
	errno_t err2;

	if ((err2=fopen_s(&fpvax,"vetka.txt","r"))!=0) {
		printf("Not Found and open file vekta.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {

		if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		     printf("Not Found and open file task.txt\n");
		     // данные записаны не будут
	     }
	     else {

			 int dincount=0;
			 fscanf_s(fpvax, "%d", &dincount);
		
			 for (int ivd=0; ivd<dincount; ivd++) {

				 float fin;
				 fscanf_s(fpvax, "%f", &fin);
				 ud=fin;


	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				// Для метода Гаусса, осторожно ресурсоёмко по памяти.
				constr_matr(Gauss_M, dCik, Gauss_b, Gauss_x, A, M, N);
                eqsolve_lenta_gauss_only_matrix(Gauss_M, (M+2)*(N+2), M+2, dCik);
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 /*
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				      SORDirichlet(u, rthdsd, A, URF, M, N);
                 }
				 */

				  // 3. многократные запуски следующего обратного хода :
                  copy_vector(rthdsd, Gauss_b, M, N); // прямое копирование.
                  eqsolve_lenta_gauss_obratnji_hod(Gauss_M, dCik, M, N, Gauss_b, Gauss_x);
                  copy_vector_inverse(u, Gauss_x, M, N);
				  //if (inumbertimestep==20) exporttecplot(u,xf,yf,M,N);
				 
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			 if (0) {
	         // Найдём компоненты скорости не ограниченной сверху они параллельны градиету потенциала :
	         calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 // Напряжённости же поля противоположны градиенту потенциала.
					 ex[i][j]=-x_vel[i][j];
					 ey[i][j]=-y_vel[i][j];
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
			 }
			

	         // Применение реальной полескоростной характеристики кремния :
	         //const Real K2=9.821e-6;
			 //const Real vsat=1.6e7; // скорость насыщения cm/s
			 //const Real K2=mu_Si/vsat;
			 /*
			 if (0) {
    	     for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/(1.0+K2*vel_mag[i][j]);
			        y_vel[i][j]=mu_Si*y_vel[i][j]/(1.0+K2*vel_mag[i][j]);
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }
			 }
			 */

			 // Полескоростная характеристика сверенная с ЗИ:
			 // В действительности скорость насыщения также зависит от температуры.
			 const Real vsat300=1.0e7;
			 const Real An_vsat=0.26;
			 const Real vsat=vsat300/((1.0-An_vsat)+An_vsat*(Tamb/300.0)); // скорость насыщения cm/s
			 const Real K2=mu_Si/vsat;
			  if (0) {
    	     for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
			        y_vel[i][j]=mu_Si*y_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }
			 }

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			  // В данном варианте поддерживаются скорости на двух сетках:
			  // На первой сетке скорость хранится на фейсах смещённых по x на пол ячейки.
			  // На второй сетке скорость хранится на фейсах смещенных по y на пол ячейки.


			 // Vx

			  // Компоненты скорости соноправлены с градиентом потенциала,
			  // в то время как напряжённость электрического поля направлена строго противоположно.
	
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			 /*
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/(1.0+K2*sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j])));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/(1.0+K2*sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j])));
		         }
	         }*/

			 /*
			 // Стабильный рабочий вариант без использования хэш функции.
			 // Полескоростная характеристика сверенная с ЗИ:
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j])))))));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j])))))));
		         }
	         }
			 */

			  // Вариант с использованием хэш таблицы.
			 // Полескоростная характеристика сверенная с ЗИ:
			 // Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					  Real keyEmag=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
                      x_vel_face_we[i][j]=mu_Si*x_vel_face_we[i][j]/SiliconDriftVel(keyEmag, K2);
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					  Real keyEmag=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
                      y_vel_face_sn[i][j]=mu_Si*y_vel_face_sn[i][j]/SiliconDriftVel(keyEmag, K2);
		         }
	         }


			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(curent_x[i][j]*curent_x[i][j]+curent_y[i][j]*curent_y[i][j]);
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn,rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/
	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		printf("%d%% %f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

    // Сверено с ЗИ.
	// В действительности скорость насыщения также зависит от температуры.
	const Real vsat300=1.0e7;
	const Real An_vsat=0.26;
	const Real vsat=vsat300/((1.0-An_vsat)+An_vsat*(Tamb/300.0)); // скорость насыщения cm/s
	// const Real vsat=1.0e7; // скорость насыщения cm/s
	 const Real K2=mu_Si/vsat;
	 calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
		        	vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			        x_vel[i][j]=mu_Si*x_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
			        y_vel[i][j]=mu_Si*y_vel[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vel_mag[i][j])))));
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		         }
	         }

	if (1) {
			  // найдём токи
		// Сверено с Федотовым стр. 648. 
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	  if (1) {
	         // Найдём компоненты скорости :
		     // именно скорости так как она направлена по градиенту потенциала, в то время как напряжённость поля 
	    	// направлена в противоположную сторону против градиента потенциала.
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 //напряжённость же электрического поля направлена противоположно вектору скорости против градиента потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		
	
	

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

   }

}

   }

   // закрытие файлов :
   fclose(fpvax);
   fclose(fp);

     // Освобождение оперативной памяти из под метода Гаусса.
   free_matr(Gauss_M, dCik, Gauss_b, Gauss_x,  M, N);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();

} // startMESFETSi_Gauss_VAX


// возвращает +(-) 1.0 в случае положительности (или отрицательности) передаваемого числа.
Real sign(Real r) {
	Real ret=1.0;
	if (r<0.0) ret=-1.0;
	return (ret);
}

//**********  GaAs ************************//

// Параметры взяты из шпаргалок А. М. Зубкова  23 июля 2014.
// Данные необходимые для полескоростной характеристики.
// пиковое поле в GaAs в зависимости от подвижности.
Real Field_peak_GaAs(Real electron_mobility) {
	//[electron_mobility]=cm^2/V/s.
	Real r=1.0e3;
	r*=3.4*exp(-0.23*log(electron_mobility/1.0e4));
	//[Field_peak]=V/cm.
	return r;
} // Field_peak_GaAs

// Скорость насыщения для GaAs.
Real Velocity_saturation_GaAs(Real electron_mobility,Real Tamb) {
	//[electron_mobility]=cm^2/V/s.
	Real r=1.0e7;
	r*=0.6*(1.0+electron_mobility/1.0e4) -0.2*sqr(electron_mobility/1.0e4);
	// Tamb [K]
	const Real An=0.56;
	r/=((1.0-An)+An*(Tamb/300.0));
	return r;
} // Velocity_saturation_GaAs

// подвижность Арсенида Галлия в зависимости от концентрации и температуры.
Real electron_mobility_GaAs(Real Tamb, Real Nd) {
	// Tamb [K] температура канала транзистора в К.
	// Nd - концентрация неподвижных доноров в GaAs [cm^-3].
	Real r=10000.0;
	r/=(1.0+sqrt(Nd/1.0e17));
	r*=exp((-2.0/3.0)*log(Tamb/300.0));
	return r;
} // electron_mobility_GaAs


// Внимание важное замечание:
// Подвижность зависит от температуры кристаллической решётки и от концентрации доноров.
// Исходный посыл состоит в том что концентрация доноров постоянная вро всей расчётной области и известна заранее.
// Также мы исходим из того, что температура кристаллической решётки неизменна и известна заранее до начала расчёта.
// Таким образом подвижность есть константа на протяжении всего времени расчёта, а поскольку праметры полескоростной характеристики 
// Ее и vsat зависят лишь от подвижности и температуры, то они тоже константы на протяжении всего времени расчёта. 
// Иными словами мы пришли к тому что полескоростная характеристика зависит лишь от модуля напряжённости электрического поля,
// а значит нет препятствий использовать хэш таблицу как в случае с кремнием.
Real GaAsDriftVel(Real keyEmag, Real mu_GaAs, Real Tamb) {
	int ikey=hash(keyEmag);
	Real ret;
	if (hash_table[ikey].bvisit==false) {
		// вычисление :
        
		if (keyEmag<1.0e-1) {
			ret=hash_table[ikey].val=0.0; // 0
		}
		else {
			const Real vsat=Velocity_saturation_GaAs(mu_GaAs,Tamb);
		    const Real Ee=Field_peak_GaAs(mu_GaAs);
            ret=hash_table[ikey].val=(1.0/keyEmag)*((mu_GaAs*fabs(keyEmag) + vsat*sqr((fabs(keyEmag)/Ee))))/(1.0+sqr((fabs(keyEmag)/Ee)));
		}
		hash_table[ikey].bvisit=true;
	}
	else {
		ret=hash_table[ikey].val;
	}
	return ret;
}


//**********  GaAs ************************//


// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Арсенид Галлия.
// мощный компьютер тратит на вычисление одной точки ВАХ при alpha=0.1, 18400шагов по времени размера 2.0*tauM или 25минут машинного времени одного ядра
// Пробивное поле в Арсениде Галлия 4e5 В/см В 8 раз меньше чем в нитриде Галлия.
void startMESFETGaAs() {

   
	inithashtable(); // нициализация хэш таблицы.

	// V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0; //50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.

	
	
	FILE *fp;
	errno_t err1;
	
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}
	
	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы:
	const Real epsilonGaAs=13.1;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	//const Real mu_GaAs=4966.999; // подвижность электронов в кремнии. 
	
	//const Real mu_GaAs=3500;	
	//const Real mu_OH=9400.0;
	//const Real mu_GaAs=(mu_OH/sqrt(1.0+1.0e-17*Nd))*exp((2.0/3.0)*log(300.0/Tamb)); // подвижность Арсенида-Галлия от концентрации и температуры.
	const Real mu_GaAs=electron_mobility_GaAs(Tamb,Nd); // подвижность в Арсениде Галлия.
	Real K1=elementary_q/epsilon0/epsilonGaAs;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_GaAs*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaAs*epsilon0/(elementary_q*Nd*mu_GaAs); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//не менее 18400 шагов по времени с tau=2.0*tauM; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ для потенциала
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	/*
	for (int i=0; i<M+2; i++) for (int j=0; j<N+2; j++) {
		n[i][j]=Nd;
		n_old[i][j]=Nd;
		n_oldi[i][j]=Nd;
		n_buf[i][j]=Nd;
	}
	*/

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N); // выделение памяти под матрицу потенциала.
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	FILE *fp_statistic;
	errno_t err_stat;

	if ((err_stat=fopen_s(&fp_statistic,"statistic.txt","w"))!=0) {
		printf("Not Found and open file statistic.txt\n");
		getchar();
		exit(0);
	}

	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				      SORDirichlet(u, rthdsd, A, URF, M, N);
					 
                 }
				 //Ilyin1985quick(u, rthdsd, A, M, N, iend);
				 
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			  if (0) {
	             // Найдём компоненты скорости не ограниченной сверху они параллельны градиету потенциала :
	             calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			     for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
					     // Напряжённости же поля противоположны градиенту потенциала.
					     ex[i][j]=-x_vel[i][j];
					     ey[i][j]=-y_vel[i][j];
					     emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				     }
			     }
			 }
			

	         // Применение реальной полескоростной характеристики Арсенида Галлия :
			// const Real vsat=6.4e6; // скорость насыщения cm/s
			 //const Real Ee=5.37e3;
			//const Real vsat=1.0e7;
			//const Real Ee=vsat/mu_GaAs;
			 /*
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                   x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		          }
	           }
			 }
			 */
			 /*
			 if (0) {
				 // аппроксимация Крёмера.
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                   x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		          }
	           }
			 }*/

			 // Полескоростная характеристика сверена с ЗИ:
			// const Real vsat=6.4e6;
			//const Real Ee=4.0e3;
			 // Скорость насыщения и пиковое поле зависят от подвижности !!!
			 // Не забыть раскоментировать при использовании полескоростной характеристики вычисляемой без использования хэш таблицы.
			// const Real vsat=Velocity_saturation_GaAs(mu_GaAs,Tamb);
			 //const Real Ee=Field_peak_GaAs(mu_GaAs);

			 /*
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));

					     if (vel_mag[i][j]>1e-30) {
							  x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			                  y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			                  vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
                         }
			             else {
				             vel_mag[i][j]=0.0;
				             x_vel[i][j]=0.0;
                             y_vel[i][j]=0.0;
			             } 

	                  
		          }
	           }
			 }
			 */
			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			 // аппроксимация Крёмера.
			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			 /*
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 if (velmag_loc>1.0e-30) {
					 x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*((vsat*fabs(velmag_loc)/Ee + vsat*sqr(sqr(fabs(velmag_loc)/Ee))))/(1.0+sqr(sqr(fabs(velmag_loc)/Ee)));
					 }
					 else {
					  x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					  y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*((vsat*fabs(velmag_loc)/Ee + vsat*sqr(sqr(fabs(velmag_loc)/Ee))))/(1.0+sqr(sqr(fabs(velmag_loc)/Ee)));
		         }
	         }*/
			  
			 /*
			 // Рабочая версия до использования хэш таблицы.
            // Полескоростная характеристика сверена с ЗИ:
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 if (velmag_loc>1.0e-30) {
					       x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*((mu_GaAs*fabs(velmag_loc) + vsat*sqr((fabs(velmag_loc)/Ee))))/(1.0+sqr((fabs(velmag_loc)/Ee)));
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					  if (velmag_loc>1.0e-30) {
					       y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*((mu_GaAs*fabs(velmag_loc) + vsat*sqr((fabs(velmag_loc)/Ee))))/(1.0+sqr((fabs(velmag_loc)/Ee)));
					  }
					  else {
                           y_vel_face_sn[i][j]=0.0;
					  }
		         }
	         }*/

			 // Полескоростная характеритика GaAs с использованием хэш таблицы.
			 // ВНИМАНИЕ !!! Должны соблюдаться сследующие условия :
			 // Неизменность температуры кристаллической решётки и концентрации доноров во всей расчётной области,
			 // Что влечёт за собой постоянство подвижности и постоянство параметров полескоростной характеристики, таких как Ee и vsat.
			 // Отсюда мы заключаем следущий важный для скорости вычислений инвариант: 
			 // Полескоростная характеристика зависит лишь от напряжёенности электрического поля и для её ускоренного вычисления может использоваться 
			 // хэш таблица, которая фактически хранит ранее вычисленные значения.
			 // В данном случае хэш таблица не дала выигрыша по времени, но и не ухудшила время счёта.
			 // Полескоростная характеристика сверена с ЗИ:
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 x_vel_face_we[i][j]*=GaAsDriftVel(velmag_loc, mu_GaAs, Tamb);
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
                     y_vel_face_sn[i][j]*=GaAsDriftVel(velmag_loc, mu_GaAs, Tamb); 
		         }
	         }


			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn, rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/

		

	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
		Real igate_loc=0.0; // ток затвора
		Real iout_loc=0.0; // ток через остальные границы.
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
			if ((xf[i]>xstartgate)&&(xf[i]<xendgate)) {
				igate_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
			if (((xf[i]>=xendsource)&&(xf[i]<=xstartgate))||((xf[i]>=xendgate)&&(xf[i]<=xstartdrain))) {
				iout_loc+=fabs((K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]));
			}
            iout_loc+=fabs((K300Dn*(n[i][1]-n[i][0])/(yf[1]-yf[0])-0.5*(n[i][1]+n[i][0])*y_vel_face_sn[i][0])*0.5*(xf[i+1]-xf[i-1]));
	     }

		for (int j=1; j<N+1; j++) {
			// боковые стенки : левая граница.
			iout_loc+=fabs((K300Dn*(n[1][j]-n[0][j])/(xf[1]-xf[0])-0.5*(n[1][j]+n[0][j])*x_vel_face_we[0][j])*0.5*(yf[j+1]-yf[j-1]));
			// боковые стенки : правая граница.
			iout_loc+=fabs((K300Dn*(n[M+1][j]-n[M][j])/(xf[M+1]-xf[M])-0.5*(n[M+1][j]+n[M][j])*x_vel_face_we[M][j])*0.5*(yf[j+1]-yf[j-1]));
		}

		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		   if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) 
		   {
			   // досрочное прекращение вычислений
			   inumbertimestep=imaxnumbertimestep+1;
			   break;
		   }
		}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		// на 1мм ширины затвора.
		//printf("%d%% %f %1.4f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))),0.1*elementary_q*isource_loc);
		printf("%d%% %f %1.4f %1.4f %1.4f %1.4f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))),0.1*elementary_q*isource_loc, 0.1*elementary_q*idrain_loc, 0.1*elementary_q*igate_loc, 0.1*elementary_q*iout_loc); // ток на 1мм ширины затвора.

		fprintf(fp_statistic,"%d %e %e %e %e\n",inumbertimestep,0.1*elementary_q*isource_loc, 0.1*elementary_q*idrain_loc,0.1*elementary_q*igate_loc,0.1*elementary_q*iout_loc);

	} // конец шагов по времени.

	
    fclose(fp_statistic);

	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

	 
	 calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	 //const Real vsat=6.4e6; // скорость насыщения cm/s
	 //const Real Ee=5.37e3;
	 //const Real vsat=6.4e6;
	 //const Real Ee=4.0e3;
	 // Скорость насыщения и пиковое поле зависят от подвижности !!!
	 const Real vsat=Velocity_saturation_GaAs(mu_GaAs,Tamb);
	 const Real Ee=Field_peak_GaAs(mu_GaAs);

	 /*
     for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
	          x_vel[i][j]=sign(x_vel[i][j])*((mu_GaAs*fabs(x_vel[i][j]) + vsat*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee))/(1.0+(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)));
			  y_vel[i][j]=sign(y_vel[i][j])*((mu_GaAs*fabs(y_vel[i][j]) + vsat*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee))/(1.0+(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)));
			  vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		  }
	 }
	 *//*
	  for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	           x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			   y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		  }
	  }*/
	  // Полескоростная характеристика сверена с ЗИ:
     for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));

			   if (vel_mag[i][j]>1e-30) {
				    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			       y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			       vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	           }
			   else {
				   vel_mag[i][j]=0.0;
				   x_vel[i][j]=0.0;
                   y_vel[i][j]=0.0;
			   }

			  
		  }
	  }
			 

	  

	if (1) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 // напряжённость электрического поля направлена в сторону противоположную 
					 // градиенту электрического потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		printf("Not Found and open file task.txt\n");
		// данные записаны не будут
	}
	else {
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		fclose(fp);
	}
	

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();

} // startMESFETGaAs


void dichtomiq_kvasiField_GaAs(Real mu_GaAs, Real neg, Real elementary_q, Real taue, Real nu, Real Tamb, Real &kvasiFieldMag)
{
	// правая часть.
	Real rthdsd=0.0;
	
	
	

	Real ra=0.0;
	Real rb=8.0e12;
	Real x=ra;

	if (nu<=0.0) {
		x=0.0;
	}
	else {

		if (fabs(neg)>1.0e-17)
	    {
		    // 1e6 1e7 = 1e13
		    // 7e10 1.6e16 1e-17=1e9
		    // taue - сокращается, в терминах nu.
	        rthdsd=nu/elementary_q/taue/neg;
	    }

	    while (fabs(x-0.5*(ra+rb))>1.0e-10) {

              x=0.5*(ra+rb);
			  // начинать лучше с правой границы чтобы стремиться к минимальному значению поля.
		      if ((rb*(GaAsDriftVel(rb, mu_GaAs, Tamb)*rb)-rthdsd)*(x*(GaAsDriftVel(x, mu_GaAs, Tamb)*x)-rthdsd)>0.0) {
			      rb=x;
		      }
		      else {
			      ra=x;
		      }
		      // printf("rthdsd=%e %e\n",rthdsd,x);

	    }
	}
    //	getchar();

	// возвращаем найденное значение 
	kvasiFieldMag=x;

} // dichtomiq_kvasiField_GaAs

// Код предназначенный для тестирования нахождения производных.
void test_grad() {
	Real** u; // рассчитываемый потенциал.
	Real** ux; // рассчитываемый потенциал.
	Real** uy; // рассчитываемый потенциал.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** skv; // скв отклонение от аналитического распределения.


	Real ug=-1.0f; // напряжение на затворе. -1V
	Real ud=10.0f; //50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17f; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0f; // температура полупроводника.
	const Real k_bolcman=1.38066e-23f;
	Real energy_source=1.5f*k_bolcman*Tamb; // однородное граничное условие Дирихле для nu
	Real taue=1.0e-12f; // 1пс время релаксации энергии.

	Real xendsource=2.0e-4f; // позиция конца истока.
	Real xstartgate=3.0e-4f; // позиция начала затвора
	Real xendgate=5.0e-4f; // позиция конца затвора
	Real xstartdrain=7.0e-4f; // позиция начала стока.
	lengthx=9.0e-4f; // протяжённость всей моделируемой области.
	lengthy=0.3e-4f; // высота канала.


    FILE *fp;
	errno_t err1;

	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		//printf("ND=%e\n",Nd);
		//getchar();
		fclose(fp);
	}

	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	
	my_alloc_universal(u, M, N);
	my_alloc_universal(skv, M, N);
	my_alloc_universal(ux, M, N);
	my_alloc_universal(uy, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);

	Real K=1.0;

	for (int i=0; i<M+2; i++) for (int j=0; j<N+2; j++) {
		u[i][j]=K*sin(2.0*3.141*xf[i]/lengthx)*sin(2.0*3.141*yf[j]/lengthy);
	}

    calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);

	

	for (int i=0; i<M+2; i++) for (int j=0; j<N+2; j++) {
		ux[i][j]=K*2.0*3.141*sin(2.0*3.141*yf[j]/lengthy)*cos(2.0*3.141*xf[i]/lengthx)/lengthx;
		uy[i][j]=K*2.0*3.141*cos(2.0*3.141*yf[j]/lengthy)*sin(2.0*3.141*xf[i]/lengthx)/lengthy;
		skv[i][j]=sqrt(sqr(x_vel[i][j]-K*2.0*3.141*sin(2.0*3.141*yf[j]/lengthy)*cos(2.0*3.141*xf[i]/lengthx)/lengthx)+sqr(y_vel[i][j]-K*2.0*3.141*cos(2.0*3.141*yf[j]/lengthy)*sin(2.0*3.141*xf[i]/lengthx)/lengthy));
	}

	//exporttecplot(u,xf,yf,M,N);

	exporttecplottestgrad(u,x_vel,y_vel,u,ux,uy,skv, xf,yf,M,N);

}


/* План реализации квазигидродинамической модели:
* 1. Добавляем уравнение энергии с граничными условиями, но без источникового члена генерации и релаксации.
* 2. Добавляем в уравнеие энергии правую часть. В итоге получаем как энергия зависит от поля.
* 3. Замыкаем систему уравнений с помощью введения квазиполя как предложил Гарбер. С помощью квазиполя находим как
* подвижность зависит от энергии и коэффициент диффузии зависит от энергии.
* 3.1. Внимаение меняется только подвижность, а коэффициент диффузии пересчитывается через подвижность.
* Для подвижности существуют пять различных вариантов. Перечислим их :
* вариант 1. Энергия газа меньше энергии решетки (это возможно на первых итерациях где пока всё далеко от сходимости и распределения
* не имеют физического смысла). Поле E меньше значения 100В/см. Тогда в качестве подвижности берется просто константа mu_300K (
* в общем та подвижность которая зависит от температуры и концентрации доноров по литературным данным.
* вариант 2. Энергия газа меньше энергии решетки (это возможно на первых итерациях где пока всё далеко от сходимости и распределения
* не имеют физического смысла). Поле E больше значения 100В/см. Тогда подвижность будет такая как по литературным данным т.е. зависящая от 
* температуры и концентрации плюс еще ограничена сверху (из-за эффекта насыщения скорости дрейфа (т.е. подвижность при сильных полях уменьшится
* согласно насыщению скорости дрейфа). mu=GaAsDriftVel(E, mu_300K, Tamb);
* вариант 3. Энергия газа больше либо равна энергии решетки (именно такой режим и установится в реальности и будет иметь физический смысл,
* но это не означает что в программе не нужно прописывать первые два варианта). Поля Е и F (квазиполе) меньше 100В/см. Тогда подвижность 
* берется просто константой mu300 по литературным данным (зависит от концентрации доноров и от температуры решетки). 
* вариант 4. Энергия газа больше либо равна энергии решетки (именно такой режим и установится в реальности и будет иметь физический смысл,
* но это не означает что в программе не нужно прописывать первые два варианта). Поле Е больше чем 100В/см, а квазиполе F меньше чем 100В/см. 
* В этом случае работает обычная ДДМ модель в которой прописан эффект насыщения скорости дрейфа. Т.е. подвижность такая-же как и в варианте 2,
* т.е. mu=GaAsDriftVel(E, mu_300K, Tamb);
* вариант 5. Энергия газа больше либо равна энергии решетки (именно такой режим и установится в реальности и будет иметь физический смысл,
* но это не означает что в программе не нужно прописывать первые два варианта). Поле Е больше чем 100В/см, а квазиполе F также больше 100В/см.
* В этом случае работает ИДДМ Гарбера. А именно подвижность вычисляется по формуле : mu=(abs(F)/abs(E))*mu=GaAsDriftVel(F, mu_300K, Tamb);;
* Если умножить данную подвижность на градиент потенциала то мы получим нужную скорость дрейфа.
* На этом случаи рассмотрения различных вариантов для подвижности закончены.
* Пробуем для простого случя : однородное легирование и простой материал. 
* 4. Переносим пункты 1-3 на сложный профиль легирования и группу материалов.
*/
// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Кремний.
// Версия PARIS2 содержащее третье уравнение для энергии электронного газа.
void startMESFETGaAsPARIS2()
{

	amgGM.a = NULL;
	amgGM.f = NULL;
	amgGM.ia = NULL;
	amgGM.ig = NULL;
	amgGM.ja = NULL;
	amgGM.u = NULL;

	
	inithashtable(); // обязательная инициализация hash table.

#if MY_FLOAT    
	// V
	Real ug=-1.0f; // напряжение на затворе. -1V
	Real ud=10.0f; //50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17f; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0f; // температура полупроводника.
	const Real k_bolcman=1.38066e-23f;
	Real energy_source=1.5f*k_bolcman*Tamb; // однородное граничное условие Дирихле для nu
	Real taue=1.0e-12f; // 1пс время релаксации энергии.

	// cm
	Real xendsource=2.0e-4f; // позиция конца истока.
	Real xstartgate=3.0e-4f; // позиция начала затвора
	Real xendgate=5.0e-4f; // позиция конца затвора
	Real xstartdrain=7.0e-4f; // позиция начала стока.
	lengthx=9.0e-4f; // протяжённость всей моделируемой области.
	lengthy=0.3e-4f; // высота канала.
#else
	// V
	Real ug=-8.0; // напряжение на затворе. -1V
	Real ud=101.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.
	const Real k_bolcman=1.38066e-23;
	Real energy_source=1.5*k_bolcman*Tamb; // однородное граничное условие Дирихле для nu
	Real taue=1.0e-12; // 1пс время релаксации энергии.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.
#endif
	
	
	FILE *fp;
	errno_t err1;

	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		//printf("ND=%e\n",Nd);
		//getchar();
		fclose(fp);
	}

	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha_u=1.0; // решили без нижней релаксации для потенциала.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.
	Real alphanu=0.1; // нижняя релаксация для решения уравнения переноса энергии электронного газа.
	int iendnu=1; // количество итераций для решения уравнения  энергии электронного газа.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы :
	const Real epsilonGaAs=13.1;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	
	//const Real mu_GaAs=4966.999; // подвижность электронов в Арсениде Галлия. 
	
	//const Real mu_GaAs=3500;	
	//const Real mu_OH=9400.0;
	//const Real mu_GaAs=(mu_OH/sqrt(1.0+1.0e-17*Nd))*exp((2.0/3.0)*log(300.0/Tamb)); // подвижность Арсенида-Галлия от концентрации и температуры.
	const Real mu_GaAs=electron_mobility_GaAs(Tamb,Nd); // подвижность в Арсениде Галлия.
	Real K1=elementary_q/epsilon0/epsilonGaAs;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.


	Real K300Dn=mu_GaAs*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaAs*epsilon0/(elementary_q*Nd*mu_GaAs); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	printf("GaAs modelling\n");
	printf("solving is : 0.5 tauM UDS. NO artifical diffusion !\n");

	// Будем ли использовать алгебраический многосеточный метод.
	bool buse_amg1r5 = true;
	if (buse_amg1r5) {
		printf("use Algebraic Multigrid Method Fedorenko R.P. 1961 (amg1r5 code.)\n");
	}



	dtimestep=0.5*tauM;
	//dtimestep=6.0*tauM;
   // dtimestep=8000.0*tauM;
	int imaxnumbertimestep=3000; //600; // количество шагов по времени. // в два раза больше чем в ИДДМ на кремнии.
	int inumberinternaliter=30; // количество итераций на временном слое.


	if (buse_amg1r5) {
		imaxnumbertimestep = 4000;
		inumberinternaliter = 1; // безитерационный
		alpha = 0.8;
		alphanu = 0.8;
	}



	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;
	int ialgnu=SEIDEL; // алгоритм для переноса энергии электронов.
	

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** ux_alternative;
	Real** uy_alternative;
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ
	Real** nu; // здесь nu есть функция от энергии электронного газа : nu=n*(u-energy_source)/taue;
	Real** nu_oldi; // nu с предыдущей итерации.
	Real** nu_old; // nu с предыдущего временного слоя.
	Real** rthdsdnu; // правая часть для nu.
	Real** rnu; 
	Real** rthdsd_internalnu;
	MATRNODE** Anu; // матрица СЛАУ для nu.
	Real** kvasiFieldMag; // квазиполе. 
	Real** energy_mobility; // подвижность зависящая от энергии и определяемая через квазиполе.
	Real** energy_K300Dn; // коэффициент диффузии завиящий от подвижности.

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	// для алгебраического многосеточного метода:
	Real *dX0 = new Real[(M + 2)*(N + 2)];


	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	TBONCONDOMAIN my_boundnu; // Граничные условия для энергии.
	printf("compleate tolerance source drain gate out \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_bound(my_boundnu,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N);
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	// Альтернативное вычисление полескоростной характеристики,
	// более экономичное по количеству арифметических операций.
	my_alloc_universal(ux_alternative, M, N);
	my_alloc_universal(uy_alternative, M, N);
	my_alloc_universal(energy_mobility, M, N); // подвижность зависящая от энергии и определяемая через квазиполе.
	my_alloc_universal(energy_K300Dn, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(kvasiFieldMag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);
	// Выделение памяти под энергию электронного газа.
	my_alloc(nu, nu_oldi, rnu, rthdsdnu, Anu, M, N);
	//my_alloc_universal(nu, M, N);
	my_alloc_universal(nu_old, M, N);
	//my_alloc_universal(nu_oldi, M, N);
	//my_alloc_universal(rthdsdnu, M, N);
	//my_alloc_universal(rnu, M, N);
	my_alloc_universal(rthdsd_internalnu, M, N);


	//my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, Nd, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);

	// инициализация функции, выраженной через энергию.
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, nu, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, nu_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, nu_oldi, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, rnu, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, rthdsdnu, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, rthdsd_internalnu, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	FILE *fp_statistic;
	errno_t err_stat;

	if ((err_stat=fopen_s(&fp_statistic,"statistic.txt","w"))!=0) {
		printf("Not Found and open file statistic.txt\n");
		getchar();
		exit(0);
	}


	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	bool bminus=false;
	
	int compleate=0;
	printf("%d%%",compleate);

	const bool iddm_Garber=true;

	Real time=0.0;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	         // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				 for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
		                 // A[i][j].ap/=alpha_u;				                        
		                  
		             }
		         }
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			         // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
					 // нижняя релаксация для потенциала
					 //rthdsd_internal[i][j]+=A[i][j].ap*(1.0-alpha_u)*u[i][j];
		         }
	         }



			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	        //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			 constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);
			// bound_relax(, inumbertimestep);
			// constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, bound_relax(ug, inumbertimestep), bound_relax(ud, inumbertimestep), xendsource, xstartgate, xendgate, xstartdrain);
	
             
			 

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				 if (buse_amg1r5) {
					 //amg_loc_memory(u, rthdsd, A,  M, N, dX0);
					 amg_global_memory(u, rthdsd, A,  M, N, 0, dX0);
				 }
				 else {


					 // itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
					 for (int i = 0; i < iend; i++) {
						 // Метод Гаусса, Зейделя, Ричардсона, Либмана
						// Seidel(u, rthdsd, A, M, N);
						 // метод последовательной верхней релаксации с коэффициентом 1.855.
						 Real URF = 1.855;
						 SORDirichlet(u, rthdsd, A, URF, M, N);
					 }
				 }
				 
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
            // exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			 // Обязательно нужный кусок кода !!!
	         // Найдём компоненты скорости не ограниченные сверху они соноправлены градиенту потенциала :
	         calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 // Напряжённости поля противоположны градиенту потенциала.
					 ex[i][j]=-x_vel[i][j];
					 ey[i][j]=-y_vel[i][j];
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
			
			
			 // Применение реальной полескоростной характеристики Арсенида Галлия :
			 // const Real vsat=6.4e6; // скорость насыщения cm/s
			 //const Real Ee=5.37e3;
			 //const Real vsat=1.0e7;
			 //const Real Ee=vsat/mu_GaAs;
			 /*
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                   x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		          }
	           }
			 }
			 */
			 /*
			 if (0) {
				 // аппроксимация Крёмера.
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                   x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		          }
	           }
			 }*/

			 // Полескоростная характеристика сверена с ЗИ:
			// const Real vsat=6.4e6;
			//const Real Ee=4.0e3;
			 // Скорость насыщения и пиковое поле зависят от подвижности !!!
			 // Не забыть раскоментировать при использовании полескоростной характеристики вычисляемой без использования хэш таблицы.
			// const Real vsat=Velocity_saturation_GaAs(mu_GaAs,Tamb);
			 //const Real Ee=Field_peak_GaAs(mu_GaAs);


			 /*
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));

					     if (vel_mag[i][j]>1e-30) {
							  x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			                  y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			                  vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
                         }
			             else {
				             vel_mag[i][j]=0.0;
				             x_vel[i][j]=0.0;
                             y_vel[i][j]=0.0;
			             } 

	                  
		          }
	           }
			 }
			 */

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			  /* Отладочная проверка.
			  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 u[i][j]=yf[j]; // xf[i];
				 }
			  }
			  */


			  // В данном варианте поддерживаются скорости на двух сетках:
			  // На первой сетке скорость хранится на фейсах смещённых по x на пол ячейки.
			  // На второй сетке скорость хранится на фейсах смещенных по y на пол ячейки.

			 // компоненты скорости на шахматной сетке
			 // Компоненты скорости соноправлены с градиентом потенциала,
			 // в то время как напряжённость электрического поля направлена строго противоположно.
			 // Vx Vy
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			 /*
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 if (velmag_loc>1.0e-30) {
					 x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*((vsat*fabs(velmag_loc)/Ee + vsat*sqr(sqr(fabs(velmag_loc)/Ee))))/(1.0+sqr(sqr(fabs(velmag_loc)/Ee)));
					 }
					 else {
					  x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					  y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*((vsat*fabs(velmag_loc)/Ee + vsat*sqr(sqr(fabs(velmag_loc)/Ee))))/(1.0+sqr(sqr(fabs(velmag_loc)/Ee)));
		         }
	         }*/

			
			 /*
			 // Рабочая версия до использования хэш таблицы.
            // Полескоростная характеристика сверена с ЗИ:
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 if (velmag_loc>1.0e-30) {
					       x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*((mu_GaAs*fabs(velmag_loc) + vsat*sqr((fabs(velmag_loc)/Ee))))/(1.0+sqr((fabs(velmag_loc)/Ee)));
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					  if (velmag_loc>1.0e-30) {
					       y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*((mu_GaAs*fabs(velmag_loc) + vsat*sqr((fabs(velmag_loc)/Ee))))/(1.0+sqr((fabs(velmag_loc)/Ee)));
					  }
					  else {
                           y_vel_face_sn[i][j]=0.0;
					  }
		         }
	         }
			 */
			 
			 // Вариант с использованием хэш таблицы.
			 // Полескоростная характеристика сверенная с ЗИ:
			// Полескоростная характеритика GaAs с использованием хэш таблицы.
			 // ВНИМАНИЕ !!! Должны соблюдаться сследующие условия :
			 // Неизменность температуры кристаллической решётки и концентрации доноров во всей расчётной области,
			 // Что влечёт за собой постоянство подвижности и постоянство параметров полескоростной характеристики, таких как Ee и vsat.
			 // Отсюда мы заключаем следущий важный для скорости вычислений инвариант: 
			 // Полескоростная характеристика зависит лишь от напряжёенности электрического поля и для её ускоренного вычисления может использоваться 
			 // хэш таблица, которая фактически хранит ранее вычисленные значения.
			 // В данном случае хэш таблица не дала выигрыша по времени, но и не ухудшила время счёта.
			 // Полескоростная характеристика сверена с ЗИ:
			 /*
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 x_vel_face_we[i][j]*=GaAsDriftVel(velmag_loc, mu_GaAs, Tamb);
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
                     y_vel_face_sn[i][j]*=GaAsDriftVel(velmag_loc, mu_GaAs, Tamb); 
		         }
	         }
			 */
			 
			 // модель Г.З. Гарбера.
			 // если iddm_Garber

			 

			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real keyEmag=kvasiFieldMag[i][j];
					 Real Emag_loc=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					
					 if (!iddm_Garber) {
						 if (Emag_loc<1.0e2) {
						         energy_mobility[i][j]=mu_GaAs; 
						 }
						 else {
							 // эффект насыщения скорости дрейфа при больших полях.
							 energy_mobility[i][j]=GaAsDriftVel(Emag_loc, mu_GaAs, Tamb);
						 }
					 }
					
					 if (iddm_Garber) {
						 if (nu[i][j]<=0.0) {
							 // обычная подвижность, та которая используется в диффузионно дрейфовой модели.
							 if (Emag_loc<1.0e2) {
						         energy_mobility[i][j]=mu_GaAs; 
						     }
						     else {
							     // эффект насыщения скорости дрейфа при больших полях.
							     energy_mobility[i][j]=GaAsDriftVel(Emag_loc, mu_GaAs, Tamb);
						     }
						 }
						 else {

							 // В ИДДМ модели подвижность зависит от квазиполя.
							 if (fabs(keyEmag)<100.0) {
								 energy_mobility[i][j]=mu_GaAs;
							 }
							 else {
								 // эффект насыщения скорости дрейфа при больших полях.
							     energy_mobility[i][j]=GaAsDriftVel(keyEmag, mu_GaAs, Tamb);
							 }

							 /*

							 if (Emag_loc<100.0) {
								 // малые поля : скорость дрейфа пропорциональна градиенту потенциала.
								if (fabs(keyEmag)<100.0) {
								     energy_mobility[i][j]=mu_GaAs;
								 }
								 else {
									 // В этом случае мы имеем маленькое поле и достаточно большое квазиполе.
									 // Случай коварен тем что здесь возможно деление на ноль.

									 //energy_mobility[i][j]=GaAsDriftVel(Emag_loc, mu_GaAs, Tamb);

									 if (j<=N-1) {
									    if (Emag_loc>1.0e-14) {
									        // Нельзя подставлять напряженность поля вместо квазиполя, скорости дрейфа будут превышать vsaturation.
								            //Real keychangeE2F=fabs(keyEmag)/Emag_loc;
			                                //energy_mobility[i][j]=(keychangeE2F*GaAsDriftVel(fabs(keyEmag), mu_GaAs, Tamb));

											// overshoot
											energy_mobility[i][j]=GaAsDriftVel(fabs(keyEmag), mu_GaAs, Tamb);
									    }
									    else {
										    // ВНИМИНИЕ большое квазиполе:
										    energy_mobility[i][j]=GaAsDriftVel(fabs(keyEmag), mu_GaAs, Tamb);
									    }
									 }
									 else {
										 energy_mobility[i][j]=mu_GaAs;
									 }
									 
								 }
							 }
							 else {
								 if (fabs(keyEmag)<100.0) {
									 // малые значения квазиполя.
									 // переходим к ДДМ модели.
									  //Real keychangeE2F=fabs(keyEmag)/Emag_loc;
									  //energy_mobility[i][j]=mu_Si*keychangeE2F;
									  energy_mobility[i][j]=GaAsDriftVel(Emag_loc, mu_GaAs, Tamb);
								 }
								 else {
								      // Нельзя подставлят напряженность поля вместо квазполя, скорости дрейфа будут превышать vsaturation.
								      //Real keychangeE2F=fabs(keyEmag)/Emag_loc;
			                          //energy_mobility[i][j]=(keychangeE2F*GaAsDriftVel(fabs(keyEmag), mu_GaAs, Tamb));
									  // Для Арсенида Галлия имеется два минимума. Один минимум с высокой подвижностью лектронов (глубокий),
									  // а второй минимум с низкой подвижностью электронов (неглубокий). Время перехода из одного минимума в другой
									  // равно tauP. может так случится что при коротких затворах меньше 1мкм, время пролёта под затвором станет меньше чем  
									  //  чем значение tauP тогда подвижность еще некоторое время будет соответстовать первому глубокому минимуму и скорость 
									  // дрефа станет больше чем предсказано в равновесной полескоростной характеристике (overshoot). Это возможно лишь при высокой температуре
									  // электронного газа (именно для этих целей она и была введена).
									  energy_mobility[i][j]=(GaAsDriftVel(fabs(keyEmag), mu_GaAs, Tamb));
								 }
							 }*/
						 }
					 }
					 
					 energy_K300Dn[i][j]=k_bolcman*Tamb*energy_mobility[i][j]/elementary_q;
				 }
			}
			 
			

			 // Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 
					 Real mobil;
					  if (fabs((energy_mobility[i][j] + energy_mobility[i+1][j]))<1.0e-3) {
						   mobil=0.5*(energy_mobility[i][j] + energy_mobility[i+1][j]);
					  }
					  else {
						  mobil=2.0*(energy_mobility[i][j]*energy_mobility[i+1][j])/(energy_mobility[i][j] + energy_mobility[i+1][j]);
					  }
                      // универсальная форма записи, подходит как для малых так и для больших полей, все хранится в подвижности.
					  // одинаково подхлодит как для модели Гарбера так и для обычной ДДМ.
                      x_vel_face_we[i][j]*=mobil;
                      y_vel_face_we[i][j]*=mobil;

		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					
					  Real mobil;
					  if (fabs((energy_mobility[i][j] + energy_mobility[i][j+1]))<1.0e-3) {
						  mobil=0.5*(energy_mobility[i][j] + energy_mobility[i][j+1]);
					  }
					  else {
						  mobil=2.0*(energy_mobility[i][j]*energy_mobility[i][j+1])/(energy_mobility[i][j] + energy_mobility[i][j+1]);
					  }

					  
                      // универсальная форма записи, подходит как для малых так и для больших полей, все хранится в подвижности.
                      // одинаково подхлодит как для модели Гарбера так и для обычной ДДМ.
					  y_vel_face_sn[i][j]*=mobil;
					  x_vel_face_sn[i][j]*=mobil;     						
					 
		         }
	         }

			  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real mobil=energy_mobility[i][j];
					 x_vel[i][j]*=mobil;
                     y_vel[i][j]*=mobil;
				 }
			  }
			 
            


			  /* При этом способе присутствуют осцилляции концентрации с шагом сетки.
			  // Хотя этот метод более экономичен по машинному времени.
			  // Алтернативное вычисление компонент дрейфовой скорости.
			  calc_gradx(ux_alternative,u,xf,yf,M,N);
			  calc_grady(uy_alternative,u,xf,yf,M,N);
			  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real vmag=sqrt(sqr(ux_alternative[i][j])+sqr(uy_alternative[i][j]));
					 // VX
					 Real vx=mu_Si*ux_alternative[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vmag)))));
					 // VY
					 Real vy=mu_Si*uy_alternative[i][j]/exp((1.0/1.8)*log((1.0+exp(1.8*log(K2*vmag)))));
					 // полескоростная характеристика :
					 ux_alternative[i][j]=vx;
					 uy_alternative[i][j]=vy;
                      
		         }
	         }

			  for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
                      x_vel_face_we[i][j]=0.5*(ux_alternative[i][j]+ux_alternative[i+1][j]);
				 }
			  }

			   for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
                      y_vel_face_sn[i][j]=0.5*(uy_alternative[i][j]+uy_alternative[i][j+1]);
				 }
			   }
			   */
			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0)
			 {
			    // найдём токи
			    calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			    for (int i=0; i<M+2; i++) {
	    	        for (int j=0; j<N+2; j++) {
					    curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					    curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					    curent_mag[i][j]=sqrt(curent_x[i][j]*curent_x[i][j]+curent_y[i][j]*curent_y[i][j]);
				    }
			    }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			//load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn,rthdsdn, M, N); 
			//load_my_bound_n3(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn,rthdsdn, M, N);
			 // без противопоточного ограничителя на диагональное преобладание в ap.
			//load_my_bound_n5(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn,rthdsdn, M, N);
			// содержит дополнительную нижнюю релаксацию для условия ток равен нулю.
			//load_my_bound_n6(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn,rthdsdn,alpha,n, M, N);
			load_my_bound_n7(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn,rthdsdn, M, N);

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			//constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);	
			constrAPatankarMESFET3(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, energy_K300Dn, xf, yf, M, N);

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

			 if (buse_amg1r5) {
				 //amg_loc_memory(n, rthdsdn, An, M, N, 1, dX0);
				 amg_global_memory(n, rthdsdn, An, M, N, 1, dX0);
			 }
			 else {
				 //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
				 for (int i = 0; i < iendn; i++) {
					 Seidel(n, rthdsdn, An, M, N);
				 }
			 }

			 // exporttecplot(n,xf,yf,M,N);


			 // Решение  уравнения переноса энергии электронного газа.

           
			 //load_my_bound_nu2(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, K300Dn, rthdsdnu, M, N); 
			 //load_my_bound_nu3(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, M, N); 
			 // без противопоточного ограничителя на диагональное преобладание в ap.
			 //load_my_bound_nu5(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, M, N); 
			 // содержит дополнительную нижнюю релаксацию для условия ток равен нулю.
			 //load_my_bound_nu6(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, alphanu, nu, M, N); 
	         load_my_bound_nu7(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, M, N); 
	
		
		
			 
			// constrAPatankarMESFET2(Anu, my_boundnu, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				
			 constrAPatankarMESFET3(Anu, my_boundnu, x_vel_face_we, y_vel_face_sn, 1.0, energy_K300Dn, xf, yf, M, N);
			
			 

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             nu_oldi[i][j]=nu[i][j];
		         }
	         }

			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // невязка.
					 rnu[i][j]=0.0;
					 // правая часть.
					 // плотности токов.
					// Real jx=K300Dn*nx[i][j]-n[i][j]*0.5*(x_vel_face_we[i-1][j]+x_vel_face_we[i][j]);
					// Real jy=K300Dn*ny[i][j]-n[i][j]*0.5*(y_vel_face_sn[i][j-1]+y_vel_face_sn[i][j]);
					 //Real jx=energy_K300Dn[i][j]*nx[i][j]-n[i][j]*0.5*(x_vel_face_we[i-1][j]+x_vel_face_we[i][j]);
					 //Real jy=energy_K300Dn[i][j]*ny[i][j]-n[i][j]*0.5*(y_vel_face_sn[i][j-1]+y_vel_face_sn[i][j]);
					  Real jx=energy_K300Dn[i][j]*nx[i][j]-n[i][j]*x_vel[i][j];
					 Real jy=energy_K300Dn[i][j]*ny[i][j]-n[i][j]*y_vel[i][j];
					 // мощность тепловыделения и диссипация.
					 rthdsd_internalnu[i][j]=(elementary_q*(ex[i][j]*jx+ey[i][j]*jy)-nu[i][j]/taue)*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             Anu[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internalnu[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*nu_old[i][j]/dtimestep;
			         }
		         }
		     }

			 // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             Anu[i][j].ap/=alphanu;				                        
		             rthdsd_internalnu[i][j]+=Anu[i][j].ap*(1.0-alphanu)*nu_oldi[i][j];
		         }
		     }

			 constrrthdsd0MESFETnu(rthdsdnu, rthdsd_internalnu, my_boundnu, xf, yf, M, N); // правая часть.


			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 Anu[i][0].ap/=alphanu;				                        
		         rthdsdnu[i][0]+=Anu[i][0].ap*(1.0-alphanu)*nu_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 Anu[0][j].ap/=alphanu;				                        
		         rthdsdnu[0][j]+=Anu[0][j].ap*(1.0-alphanu)*nu_oldi[0][j];
				 Anu[M+1][j].ap/=alphanu;				                        
		         rthdsdnu[M+1][j]+=Anu[M+1][j].ap*(1.0-alphanu)*nu_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  Anu[i][N+1].ap/=alphanu;				                        
		              rthdsdnu[i][N+1]+=Anu[i][N+1].ap*(1.0-alphanu)*nu_oldi[i][N+1];
			     }
		     }

			 if (buse_amg1r5) {
				 // Мы используем алгебраический многосеточный метод.
				 //amg_loc_memory(nu, rthdsdnu, Anu, M, N, 2, dX0);
				 amg_global_memory(nu, rthdsdnu, Anu, M, N, 2, dX0);
			 }
			 else {

				 for (int i = 0; i < iendnu; i++) {
					 Seidel(nu, rthdsdnu, Anu, M, N);
				 }
			 }

			 // минимальное значение nu во внутренности.
			 Real nu_min_internal=1.0e40;
             for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
					 if (nu[i][j]<nu_min_internal) {
                         nu_min_internal=nu[i][j];
					 }
				 }
             }

			 // Находим квазиполе:
			 for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {

					 dichtomiq_kvasiField_GaAs(mu_GaAs, n[i][j], elementary_q, taue, nu[i][j], Tamb, kvasiFieldMag[i][j]);

					 /*
					 // Мы решим нелинейное уравнение методом половинного деления.
					 if ((j==N+1)&&(xf[i]<=xendsource)) {
						 // Нулевое nu
						 dichtomiq_kvasiField_GaAs(mu_GaAs, n[i][j], elementary_q, taue, nu_min_internal, Tamb, kvasiFieldMag[i][j]);
					 }
					 else {
					     dichtomiq_kvasiField_GaAs(mu_GaAs, n[i][j], elementary_q, taue, nu[i][j], Tamb, kvasiFieldMag[i][j]);
					 }
					 */
				 }

			 }


		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

		 //	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
				nu_old[i][j]=nu[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/
	

		Real idrain_loc=0.0;   // ток стока.
    	Real isource_loc=0.0; // ток истока.
		Real igate_loc=0.0;  // ток затвора.
		Real iout_loc=0.0;  // ток через внешний контур.
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
			if ((xf[i]>xstartgate)&&(xf[i]<xendgate)) {
				//igate_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
                igate_loc+=fabs(((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]));
			}
			if (((xf[i]>=xendsource)&&(xf[i]<=xstartgate))||((xf[i]>=xendgate)&&(xf[i]<=xstartdrain))) {
                iout_loc+=fabs(((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]));
			}
			iout_loc+=fabs(((2.0*energy_K300Dn[i][0]*energy_K300Dn[i][1]/(energy_K300Dn[i][0]+energy_K300Dn[i][1]))*(n[i][1]-n[i][0])/(yf[1]-yf[0])-0.5*(n[i][1]+n[i][0])*y_vel_face_sn[i][0])*0.5*(xf[i+1]-xf[i-1]));
	     }
		for (int j=1; j<N+1; j++) {
			iout_loc+=fabs(((2.0*energy_K300Dn[0][j]*energy_K300Dn[1][j]/(energy_K300Dn[0][j]+energy_K300Dn[1][j]))*(n[1][j]-n[0][j])/(xf[1]-xf[0])-0.5*(n[1][j]+n[0][j])*x_vel_face_we[0][j])*0.5*(yf[j+1]-yf[j-1]));
	        iout_loc+=fabs(((2.0*energy_K300Dn[M+1][j]*energy_K300Dn[M][j]/(energy_K300Dn[M+1][j]+energy_K300Dn[M][j]))*(n[M+1][j]-n[M][j])/(xf[M+1]-xf[M])-0.5*(n[M+1][j]+n[M][j])*x_vel_face_we[M][j])*0.5*(yf[j+1]-yf[j-1]));
		}
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
			Real diviation=10.0;
			if ((fabs(isource_loc)>1.0e-20)&&(fabs(idrain_loc)>1.0e-20)) {
			if (fabs(isource_loc)>fabs(idrain_loc)) {
				diviation=fabs(idrain_loc)/fabs(isource_loc);
			}
			else {
				diviation=fabs(isource_loc)/fabs(idrain_loc);
			}
			}
		if ((fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005)&&((diviation<1.1)&&(diviation>0.9))) {
			// досрочное прекращение вычислений
			 //inumbertimestep=imaxnumbertimestep+1;
			 //  break;
			 printf("diviation=%e",diviation);
			//getchar();
		}}
		else {
			// возможно нулевой ток.
			//if (inumbertimestep>70) break;
			printf("zero current");
			getchar();
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <1000) {
			printf("\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <10000) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b\b");
		}
		// запас.
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b");
		if (bminus) printf("\b");
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		printf("%d%% %f %1.4f %1.4f %1.4f %1.4f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))),0.1*elementary_q*isource_loc, 0.1*elementary_q*idrain_loc, 0.1*elementary_q*igate_loc, 0.1*elementary_q*iout_loc); // ток на 1мм ширины затвора.
		if (isource_loc<0.0) {
			bminus=true;
		}
		else {
			bminus=false;
		}

		if (compleate>85) {
			break;
		}

		fprintf(fp_statistic,"%d %e %e %e %e\n",inumbertimestep,0.1*elementary_q*isource_loc, 0.1*elementary_q*idrain_loc,0.1*elementary_q*igate_loc,0.1*elementary_q*iout_loc);
	} // конец шагов по времени.

	

	fclose(fp_statistic);
	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);


	// модель Г.З. Гарбера.
			 // если iddm_Garber

			 

			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real keyEmag=kvasiFieldMag[i][j];
					 Real Emag_loc=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					
					 if (!iddm_Garber) {
						 if (Emag_loc<1.0e2) {
						         energy_mobility[i][j]=mu_GaAs; 
						 }
						 else {
							 // эффект насыщения скорости дрейфа при больших полях.
							 energy_mobility[i][j]=GaAsDriftVel(Emag_loc, mu_GaAs, Tamb);
						 }
					 }
					
					 if (iddm_Garber) {
						 if (nu[i][j]<=0.0) {
							 // обычная подвижность, та которая используется в диффузионно дрейфовой модели.
							 if (Emag_loc<1.0e2) {
						         energy_mobility[i][j]=mu_GaAs; 
						     }
						     else {
							     // эффект насыщения скорости дрейфа при больших полях.
							     energy_mobility[i][j]=GaAsDriftVel(Emag_loc, mu_GaAs, Tamb);
						     }
						 }
						 else {


							 // Подвижность в ИДДМ зависит от квазиполя.
							 if (fabs(keyEmag)<100.0) {
								 energy_mobility[i][j]=mu_GaAs; 
							 }
							 else {
								 // эффект насыщения скорости дрейфа при больших полях.
							     energy_mobility[i][j]=GaAsDriftVel(keyEmag, mu_GaAs, Tamb);
							 }

							 /*
							 // Данный закоментированный код считается надуманным и решено его исключить.
							 if (Emag_loc<100.0) {
								 // малые поля : скорость дрейфа пропорциональна градиенту потенциала.
								if (fabs(keyEmag)<100.0) {
								     energy_mobility[i][j]=mu_GaAs;
								 }
								 else {
									 // В этом случае мы имеем маленькое поле и достаточно большое квазиполе.
									 // Случай коварен тем что здесь возможно деление на ноль.

									 //energy_mobility[i][j]=GaAsDriftVel(Emag_loc, mu_GaAs, Tamb);

									 if (j<=N-1) {
									    if (Emag_loc>1.0e-14) {
									        // Нельзя подставлять напряженность поля вместо квазиполя, скорости дрейфа будут превышать vsaturation.
								            //Real keychangeE2F=fabs(keyEmag)/Emag_loc;
			                                //energy_mobility[i][j]=(keychangeE2F*GaAsDriftVel(fabs(keyEmag), mu_GaAs, Tamb));

											// overshoot
											energy_mobility[i][j]=GaAsDriftVel(fabs(keyEmag), mu_GaAs, Tamb);
									    }
									    else {
										    // ВНИМИНИЕ большое квазиполе:
										    energy_mobility[i][j]=GaAsDriftVel(fabs(keyEmag), mu_GaAs, Tamb);
									    }
									 }
									 else {
										 energy_mobility[i][j]=mu_GaAs;
									 }
									 
								 }
							 }
							 else {
								 if (fabs(keyEmag)<100.0) {
									 // малые значения квазиполя.
									 // переходим к ДДМ модели.
									  //Real keychangeE2F=fabs(keyEmag)/Emag_loc;
									  //energy_mobility[i][j]=mu_Si*keychangeE2F;
									  energy_mobility[i][j]=GaAsDriftVel(Emag_loc, mu_GaAs, Tamb);
								 }
								 else {
								      // Нельзя подставлят напряженность поля вместо квазполя, скорости дрейфа будут превышать vsaturation.
								      //Real keychangeE2F=fabs(keyEmag)/Emag_loc;
			                          //energy_mobility[i][j]=(keychangeE2F*GaAsDriftVel(fabs(keyEmag), mu_GaAs, Tamb));
									  // Для Арсенида Галлия имеется два минимума. Один минимум с высокой подвижностью лектронов (глубокий),
									  // а второй минимум с низкой подвижностью электронов (неглубокий). Время перехода из одного минимума в другой
									  // равно tauP. может так случится что при коротких затворах меньше 1мкм, время пролёта под затвором станет меньше чем  
									  //  чем значение tauP тогда подвижность еще некоторое время будет соответстовать первому глубокому минимуму и скорость 
									  // дрефа станет больше чем предсказано в равновесной полескоростной характеристике (overshoot). Это возможно лишь при высокой температуре
									  // электронного газа (именно для этих целей она и была введена).
									  energy_mobility[i][j]=(GaAsDriftVel(fabs(keyEmag), mu_GaAs, Tamb));
								 }
							 }*/
						 }
					 }
					 
					 energy_K300Dn[i][j]=k_bolcman*Tamb*energy_mobility[i][j]/elementary_q;
				 }
			}
			 



/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*((2.0*energy_K300Dn[i][N]*energy_K300Dn[i][N+1]/(energy_K300Dn[i][N]+energy_K300Dn[i][N+1]))*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	    // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

    // Сверено с ЗИ.
	// В действительности скорость насыщения также зависит от температуры.
	
	 calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	  for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
                    // Универсальное значение подвижности было вычислено раньше 
					 // в ходе вычислительного процесса.

                    x_vel[i][j]*=energy_mobility[i][j];
					if (j<N+1) {
					    y_vel[i][j]*=energy_mobility[i][j];
					}
					else {
						y_vel[i][j]*=0.5*(energy_mobility[i][j]+energy_mobility[i][j-1]);
					}
					vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					
		         }
	         }



	if (1) {
			  // найдём токи
		// Сверено с Федотовым стр. 648. 
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 // Универсальное значение коэффициента диффузии было вычислено раньше 
					 // в ходе вычислительного процесса.

					 curent_x[i][j]=elementary_q*(energy_K300Dn[i][j]*nx[i][j]-n[i][j]*x_vel[i][j]);
if (j<N+1) {
					 curent_y[i][j]=elementary_q*(energy_K300Dn[i][j]*ny[i][j]-n[i][j]*y_vel[i][j]);
}
else {
	 curent_y[i][j]=elementary_q*(0.5*(energy_K300Dn[i][j]+energy_K300Dn[i][j-1])*ny[i][j]-n[i][j]*y_vel[i][j]);
}
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
		     // именно скорости так как она направлена по градиенту потенциала, в то время как напряжённость поля 
	         // направлена в противоположную сторону против градиента потенциала.
	        
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 //напряжённость же электрического поля направлена противоположно вектору скорости против градиента потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		
	    // Делаем визуализацию более физичной.	
	   forZub( Nd, u, nu, energy_source, kvasiFieldMag, taue, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	

    	exporttecplotMESFET4(u, nu, energy_source, kvasiFieldMag, taue, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);

		/*
		// Проверка вычисления напряженностей электрического поля.
		// ugradx ugrady
		universalgradx(u, x_vel_face_we, xf, M, N);
		// печать градиента.
		exporttecplot(x_vel_face_we,xf,yf,M-1,N);
		universalgrady(u, y_vel_face_sn, yf, M, N);
		exporttecplot(y_vel_face_sn, xf, yf, M, N-1);
		universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
		exporttecplot(y_vel_face_we, xf, yf, M-1, N);
		universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
		exporttecplot(x_vel_face_sn, xf, yf, M, N-1);
		*/
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		printf("Not Found and open file task.txt\n");
		// данные записаны не будут
	}
	else {
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		fclose(fp);
	}

    // Освобождение оперативной памяти.
	my_free_universal(ux_alternative,M,N);
	my_free_universal(uy_alternative,M,N);
	my_free_universal(kvasiFieldMag, M, N);
	my_free_universal(energy_mobility, M, N); // подвижность зависящая от энергии и определяемая через квазиполе.
	my_free_universal(energy_K300Dn, M, N);
	
	// Внутренние переменные алгебраического многосеточного метода.
	delete[] dX0;
	dX0 = NULL;


	if (amgGM.a != NULL) {
		delete[] amgGM.a;
	}
	if (amgGM.f != NULL) {
		delete[] amgGM.f;
	}
	if (amgGM.ia != NULL) {
		delete[] amgGM.ia;
	}
	if (amgGM.ig != NULL) {
		delete[] amgGM.ig;
	}
	if (amgGM.ja != NULL) {
		delete[] amgGM.ja;
	}
	if (amgGM.u != NULL) {
		delete[] amgGM.u;
	}

	bfirst_use_amgGM = true;


    printf("source=%f\n", isource_loc);
    printf("drain=%f\n", idrain_loc);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
    getchar();

} // startMESFETGaAsPARIS2


// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Арсенид Галлия.
// мощный компьютер тратит на вычисление одной точки ВАХ при alpha=0.1, 18400шагов по времени размера 2.0*tauM или 25минут машинного времени одного ядра
// Пробивное поле в Арсениде Галлия 4e5 В/см В 8 раз меньше чем в нитриде Галлия.
void startMESFETGaAs_VAX() {

    
	// V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.

	
	
	FILE *fp;
	errno_t err1;
	
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}
	
	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы:
	const Real epsilonGaAs=13.1;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	//const Real mu_GaAs=4966.999; // подвижность электронов в кремнии. 
	
	//const Real mu_GaAs=3500;	
	//const Real mu_OH=9400.0;
	//const Real mu_GaAs=(mu_OH/sqrt(1.0+1.0e-17*Nd))*exp((2.0/3.0)*log(300.0/Tamb)); // подвижность Арсенида-Галлия от концентрации и температуры.
	const Real mu_GaAs=electron_mobility_GaAs(Tamb,Nd); // подвижность в Арсениде Галлия.
	Real K1=elementary_q/epsilon0/epsilonGaAs;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_GaAs*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaAs*epsilon0/(elementary_q*Nd*mu_GaAs); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//не менее 18400 шагов по времени с tau=2.0*tauM; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ для потенциала
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	/*
	for (int i=0; i<M+2; i++) for (int j=0; j<N+2; j++) {
		n[i][j]=Nd;
		n_old[i][j]=Nd;
		n_oldi[i][j]=Nd;
		n_buf[i][j]=Nd;
	}
	*/

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N); // выделение памяти под матрицу потенциала.
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;


	FILE *fpvax;
	errno_t err2;

	if ((err2=fopen_s(&fpvax,"vetka.txt","r"))!=0) {
		printf("Not Found and open file vekta.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {

		if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		     printf("Not Found and open file task.txt\n");
		     // данные записаны не будут
	     }
	     else {

			 int dincount=0;
			 fscanf_s(fpvax, "%d", &dincount);
		
			 for (int ivd=0; ivd<dincount; ivd++) {

				 float fin;
				 fscanf_s(fpvax, "%f", &fin);
				 ud=fin;


	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				      SORDirichlet(u, rthdsd, A, URF, M, N);
					 
                 }
				 //Ilyin1985quick(u, rthdsd, A, M, N, iend);
				 
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			if (0) {
	             // Найдём компоненты скорости не ограниченной сверху они параллельны градиету потенциала :
	             calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			     for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
					     // Напряжённости же поля противоположны градиенту потенциала.
					     ex[i][j]=-x_vel[i][j];
					     ey[i][j]=-y_vel[i][j];
					     emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				     }
			     }
			 }

	         // Применение реальной полескоростной характеристики Арсенида Галлия :
			// const Real vsat=6.4e6; // скорость насыщения cm/s
			 //const Real Ee=5.37e3;
			//const Real vsat=1.0e7;
			//const Real Ee=vsat/mu_GaAs;
			 /*
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                   x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		          }
	           }
			 }
			 */
			 /*
			 if (0) {
				 // аппроксимация Крёмера.
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                   x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		          }
	           }
			 }*/

			 // Полескоростная характеристика сверена с ЗИ:
			// const Real vsat=6.4e6;
			//const Real Ee=4.0e3;
			 // Скорость насыщения и пиковое поле зависят от подвижности !!!
			 const Real vsat=Velocity_saturation_GaAs(mu_GaAs,Tamb);
			 const Real Ee=Field_peak_GaAs(mu_GaAs);

			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));

					     if (vel_mag[i][j]>1e-30) {
							  x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			                  y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			                  vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
                         }
			             else {
				             vel_mag[i][j]=0.0;
				             x_vel[i][j]=0.0;
                             y_vel[i][j]=0.0;
			             } 

	                  
		          }
	           }
			 }

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			 // аппроксимация Крёмера.
			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			 /*
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 if (velmag_loc>1.0e-30) {
					 x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*((vsat*fabs(velmag_loc)/Ee + vsat*sqr(sqr(fabs(velmag_loc)/Ee))))/(1.0+sqr(sqr(fabs(velmag_loc)/Ee)));
					 }
					 else {
					  x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					  y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*((vsat*fabs(velmag_loc)/Ee + vsat*sqr(sqr(fabs(velmag_loc)/Ee))))/(1.0+sqr(sqr(fabs(velmag_loc)/Ee)));
		         }
	         }*/
            // Полескоростная характеристика сверена с ЗИ:
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 if (velmag_loc>1.0e-30) {
					       x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*((mu_GaAs*fabs(velmag_loc) + vsat*sqr((fabs(velmag_loc)/Ee))))/(1.0+sqr((fabs(velmag_loc)/Ee)));
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					  if (velmag_loc>1.0e-30) {
					       y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*((mu_GaAs*fabs(velmag_loc) + vsat*sqr((fabs(velmag_loc)/Ee))))/(1.0+sqr((fabs(velmag_loc)/Ee)));
					  }
					  else {
                           y_vel_face_sn[i][j]=0.0;
					  }
		         }
	         }

			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn, rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/

		

	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		printf("%d%% %f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));

	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

	 
	 calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	 //const Real vsat=6.4e6; // скорость насыщения cm/s
	 //const Real Ee=5.37e3;
	 //const Real vsat=6.4e6;
	 //const Real Ee=4.0e3;
	 // Скорость насыщения и пиковое поле зависят от подвижности !!!
	 const Real vsat=Velocity_saturation_GaAs(mu_GaAs,Tamb);
	 const Real Ee=Field_peak_GaAs(mu_GaAs);

	 /*
     for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
	          x_vel[i][j]=sign(x_vel[i][j])*((mu_GaAs*fabs(x_vel[i][j]) + vsat*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee))/(1.0+(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)));
			  y_vel[i][j]=sign(y_vel[i][j])*((mu_GaAs*fabs(y_vel[i][j]) + vsat*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee))/(1.0+(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)));
			  vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		  }
	 }
	 *//*
	  for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	           x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			   y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		  }
	  }*/
	  // Полескоростная характеристика сверена с ЗИ:
     for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));

			   if (vel_mag[i][j]>1e-30) {
				    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			       y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			       vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	           }
			   else {
				   vel_mag[i][j]=0.0;
				   x_vel[i][j]=0.0;
                   y_vel[i][j]=0.0;
			   }

			  
		  }
	  }
			 

	  

	if (1) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					  // напряжённость электрического поля направлена в сторону противоположную 
					 // градиенту электрического потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		
	
	

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

   }

}

   }

   // закрытие файлов :
   fclose(fpvax);
   fclose(fp);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();

} // startMESFETGaAs_VAX



// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Арсенид Галлия.
// мощный компьютер тратит на вычисление одной точки ВАХ при alpha=0.1, 18400шагов по времени размера 2.0*tauM или 25минут машинного времени одного ядра
// Пробивное поле в Арсениде Галлия 4e5 В/см В 8 раз меньше чем в нитриде Галлия.
void startMESFETGaAs_Gauss() {

    
	// V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.

	
	
	FILE *fp;
	errno_t err1;
	
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		 fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}
	
	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы:
	const Real epsilonGaAs=13.1;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	//const Real mu_GaAs=4966.999; // подвижность электронов в кремнии. 
	
	//const Real mu_GaAs=3500;	
	//const Real mu_OH=9400.0;
	//const Real mu_GaAs=(mu_OH/sqrt(1.0+1.0e-17*Nd))*exp((2.0/3.0)*log(300.0/Tamb)); // подвижность Арсенида-Галлия от концентрации и температуры.
	const Real mu_GaAs=electron_mobility_GaAs(Tamb,Nd); // подвижность в Арсениде Галлия.
	Real K1=elementary_q/epsilon0/epsilonGaAs;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_GaAs*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaAs*epsilon0/(elementary_q*Nd*mu_GaAs); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	// Для диффузионно дрейфовой модели шаг по времени можно увеличить на 4 порядка.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//не менее 18400 шагов по времени с tau=2.0*tauM; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;
	// Замена SOR на однократное обращение верхнего треугольника.
	Real** Gauss_M=NULL;
	Real** dCik=NULL;
	Real* Gauss_b=NULL;
	Real* Gauss_x=NULL;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ для потенциала
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N); // выделение памяти под матрицу потенциала.
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);

	/*
	for (int i=0; i<M+2; i++) for (int j=0; j<N+2; j++) {
		n[i][j]=Nd;
		n_old[i][j]=Nd;
		n_oldi[i][j]=Nd;
		n_buf[i][j]=Nd;
	}
	*/



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				// Для метода Гаусса, осторожно ресурсоёмко по памяти.
				constr_matr(Gauss_M, dCik, Gauss_b, Gauss_x, A, M, N);
                eqsolve_lenta_gauss_only_matrix(Gauss_M, (M+2)*(N+2), M+2, dCik);
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 /*
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				      SORDirichlet(u, rthdsd, A, URF, M, N);
					 
                 }*/
				 //Ilyin1985quick(u, rthdsd, A, M, N, iend);
				 
				 

                // 3. многократные запуски следующего обратного хода :
                copy_vector(rthdsd, Gauss_b, M, N); // прямое копирование.
                eqsolve_lenta_gauss_obratnji_hod(Gauss_M, dCik, M, N, Gauss_b, Gauss_x);
                copy_vector_inverse(u, Gauss_x, M, N);
				//if (inumbertimestep==20) exporttecplot(u,xf,yf,M,N);
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**

             if (0) {
	             // Найдём компоненты скорости не ограниченной сверху они соноправлены градиету потенциала :
	             calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			     for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
					     // Напряжённости же поля противоположны градиенту потенциала.
					     ex[i][j]=-x_vel[i][j];
					     ey[i][j]=-y_vel[i][j];
					     emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				     }
			     }
			 }
			

	         // Применение реальной полескоростной характеристики Арсенида Галлия :
			// const Real vsat=6.4e6; // скорость насыщения cm/s
			 //const Real Ee=5.37e3;
			//const Real vsat=1.0e7;
			//const Real Ee=vsat/mu_GaAs;
			 /*
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                   x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		          }
	           }
			 }
			 */
			 /*
			 if (0) {
				 // аппроксимация Крёмера.
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                   x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		          }
	           }
			 }*/

			 // Полескоростная характеристика сверена с ЗИ:
			// const Real vsat=6.4e6;
			//const Real Ee=4.0e3;
			 // Скорость насыщения и пиковое поле зависят от подвижности !!!
			 const Real vsat=Velocity_saturation_GaAs(mu_GaAs,Tamb);
			 const Real Ee=Field_peak_GaAs(mu_GaAs);

			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   if (vel_mag[i][j]>1e-30) {
						    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			                y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			                vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                    }
			            else {
				            vel_mag[i][j]=0.0;
				            x_vel[i][j]=0.0;
                            y_vel[i][j]=0.0;
			            }
	                  
		          }
	           }
			 }

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			 // аппроксимация Крёмера.
			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			 /*
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*((vsat*fabs(velmag_loc)/Ee + vsat*sqr(sqr(fabs(velmag_loc)/Ee))))/(1.0+sqr(sqr(fabs(velmag_loc)/Ee)));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					  y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*((vsat*fabs(velmag_loc)/Ee + vsat*sqr(sqr(fabs(velmag_loc)/Ee))))/(1.0+sqr(sqr(fabs(velmag_loc)/Ee)));
		         }
	         }*/
            // Полескоростная характеристика сверена с ЗИ:
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 if (velmag_loc>1.0e-30) {
					     x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*((mu_GaAs*fabs(velmag_loc) + vsat*sqr((fabs(velmag_loc)/Ee))))/(1.0+sqr((fabs(velmag_loc)/Ee)));
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*((mu_GaAs*fabs(velmag_loc) + vsat*sqr((fabs(velmag_loc)/Ee))))/(1.0+sqr((fabs(velmag_loc)/Ee)));
					 }
					 else {
						 y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }

			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn, rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/

		

	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		printf("%d%% %f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));

	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

	 
	 calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	

	 //const Real vsat=6.4e6; // скорость насыщения cm/s
	 //const Real Ee=5.37e3;
	 //const Real vsat=6.4e6;
	 //const Real Ee=4.0e3;
	 // Скорость насыщения и пиковое поле зависят от подвижности !!!
	 const Real vsat=Velocity_saturation_GaAs(mu_GaAs,Tamb);
	 const Real Ee=Field_peak_GaAs(mu_GaAs);

	 /*
     for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
	          x_vel[i][j]=sign(x_vel[i][j])*((mu_GaAs*fabs(x_vel[i][j]) + vsat*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee))/(1.0+(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)));
			  y_vel[i][j]=sign(y_vel[i][j])*((mu_GaAs*fabs(y_vel[i][j]) + vsat*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee))/(1.0+(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)));
			  vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		  }
	 }
	 *//*
	  for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	           x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			   y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		  }
	  }*/
	  // Полескоростная характеристика сверена с ЗИ:
     for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			   if (vel_mag[i][j]>1e-30) {
			      x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			      y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			      vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			   }
			   else {
				   vel_mag[i][j]=0.0;
				   x_vel[i][j]=0.0;
                   y_vel[i][j]=0.0;
			   }
		  }
	  }
			 
	

	if (1) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			// exporttecplot(curent_y, xf,  yf, M, N);
			

		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					  // напряжённость электрического поля направлена в сторону противоположную 
					 // градиенту электрического потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		printf("Not Found and open file task.txt\n");
		// данные записаны не будут
	}
	else {
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		fclose(fp);
	}
	

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

   // Освобождение оперативной памяти из под метода Гаусса.
   free_matr(Gauss_M, dCik, Gauss_b, Gauss_x,  M, N);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();

} // startMESFETGaAs_Gauss


// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Арсенид Галлия.
// мощный компьютер тратит на вычисление одной точки ВАХ при alpha=0.1, 18400шагов по времени размера 2.0*tauM или 25минут машинного времени одного ядра
// Пробивное поле в Арсениде Галлия 4e5 В/см В 8 раз меньше чем в нитриде Галлия.
void startMESFETGaAs_Gauss_VAX() {

    
	// V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.

	
	
	FILE *fp;
	errno_t err1;
	
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		 fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}
	
	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы:
	const Real epsilonGaAs=13.1;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	//const Real mu_GaAs=4966.999; // подвижность электронов в кремнии. 
	
	//const Real mu_GaAs=3500;	
	//const Real mu_OH=9400.0;
	//const Real mu_GaAs=(mu_OH/sqrt(1.0+1.0e-17*Nd))*exp((2.0/3.0)*log(300.0/Tamb)); // подвижность Арсенида-Галлия от концентрации и температуры.
	const Real mu_GaAs=electron_mobility_GaAs(Tamb,Nd); // подвижность в Арсениде Галлия.
	Real K1=elementary_q/epsilon0/epsilonGaAs;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_GaAs*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaAs*epsilon0/(elementary_q*Nd*mu_GaAs); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	// Для диффузионно дрейфовой модели шаг по времени можно увеличить на 4 порядка.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//не менее 18400 шагов по времени с tau=2.0*tauM; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;
	// Замена SOR на однократное обращение верхнего треугольника.
	Real** Gauss_M=NULL;
	Real** dCik=NULL;
	Real* Gauss_b=NULL;
	Real* Gauss_x=NULL;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ для потенциала
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N); // выделение памяти под матрицу потенциала.
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);

	/*
	for (int i=0; i<M+2; i++) for (int j=0; j<N+2; j++) {
		n[i][j]=Nd;
		n_old[i][j]=Nd;
		n_oldi[i][j]=Nd;
		n_buf[i][j]=Nd;
	}
	*/



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;


	FILE *fpvax;
	errno_t err2;

	if ((err2=fopen_s(&fpvax,"vetka.txt","r"))!=0) {
		printf("Not Found and open file vekta.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {

		if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		     printf("Not Found and open file task.txt\n");
		     // данные записаны не будут
	     }
	     else {

			 int dincount=0;
			 fscanf_s(fpvax, "%d", &dincount);
		
			 for (int ivd=0; ivd<dincount; ivd++) {

				 float fin;
				 fscanf_s(fpvax, "%f", &fin);
				 ud=fin;


	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				// Для метода Гаусса, осторожно ресурсоёмко по памяти.
				constr_matr(Gauss_M, dCik, Gauss_b, Gauss_x, A, M, N);
                eqsolve_lenta_gauss_only_matrix(Gauss_M, (M+2)*(N+2), M+2, dCik);
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 /*
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				      SORDirichlet(u, rthdsd, A, URF, M, N);
					 
                 }*/
				 //Ilyin1985quick(u, rthdsd, A, M, N, iend);
				 
				 

                // 3. многократные запуски следующего обратного хода :
                copy_vector(rthdsd, Gauss_b, M, N); // прямое копирование.
                eqsolve_lenta_gauss_obratnji_hod(Gauss_M, dCik, M, N, Gauss_b, Gauss_x);
                copy_vector_inverse(u, Gauss_x, M, N);
				//if (inumbertimestep==20) exporttecplot(u,xf,yf,M,N);
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			 if (0) {
	             // Найдём компоненты скорости не ограниченной сверху они соноправлены градиету потенциала :
	             calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			     for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
					     // Напряжённости же поля противоположны градиенту потенциала.
					     ex[i][j]=-x_vel[i][j];
					     ey[i][j]=-y_vel[i][j];
					     emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				     }
			     }
			 }
			

	         // Применение реальной полескоростной характеристики Арсенида Галлия :
			// const Real vsat=6.4e6; // скорость насыщения cm/s
			 //const Real Ee=5.37e3;
			//const Real vsat=1.0e7;
			//const Real Ee=vsat/mu_GaAs;
			 /*
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                   x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		          }
	           }
			 }
			 */
			 /*
			 if (0) {
				 // аппроксимация Крёмера.
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                   x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		          }
	           }
			 }*/

			 // Полескоростная характеристика сверена с ЗИ:
			// const Real vsat=6.4e6;
			//const Real Ee=4.0e3;
			 // Скорость насыщения и пиковое поле зависят от подвижности !!!
			 const Real vsat=Velocity_saturation_GaAs(mu_GaAs,Tamb);
			 const Real Ee=Field_peak_GaAs(mu_GaAs);

			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   if (vel_mag[i][j]>1e-30) {
						    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			                y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			                vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	                    }
			            else {
				            vel_mag[i][j]=0.0;
				            x_vel[i][j]=0.0;
                            y_vel[i][j]=0.0;
			            }
	                  
		          }
	           }
			 }

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			 // аппроксимация Крёмера.
			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			 /*
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*((vsat*fabs(velmag_loc)/Ee + vsat*sqr(sqr(fabs(velmag_loc)/Ee))))/(1.0+sqr(sqr(fabs(velmag_loc)/Ee)));
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					  y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*((vsat*fabs(velmag_loc)/Ee + vsat*sqr(sqr(fabs(velmag_loc)/Ee))))/(1.0+sqr(sqr(fabs(velmag_loc)/Ee)));
		         }
	         }*/
            // Полескоростная характеристика сверена с ЗИ:
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 if (velmag_loc>1.0e-30) {
					     x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*((mu_GaAs*fabs(velmag_loc) + vsat*sqr((fabs(velmag_loc)/Ee))))/(1.0+sqr((fabs(velmag_loc)/Ee)));
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*((mu_GaAs*fabs(velmag_loc) + vsat*sqr((fabs(velmag_loc)/Ee))))/(1.0+sqr((fabs(velmag_loc)/Ee)));
					 }
					 else {
						 y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }

			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn, rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/

		

	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		printf("%d%% %f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));

	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

	 
	 calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	

	 //const Real vsat=6.4e6; // скорость насыщения cm/s
	 //const Real Ee=5.37e3;
	 //const Real vsat=6.4e6;
	 //const Real Ee=4.0e3;
	 // Скорость насыщения и пиковое поле зависят от подвижности !!!
	 const Real vsat=Velocity_saturation_GaAs(mu_GaAs,Tamb);
	 const Real Ee=Field_peak_GaAs(mu_GaAs);

	 /*
     for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
	          x_vel[i][j]=sign(x_vel[i][j])*((mu_GaAs*fabs(x_vel[i][j]) + vsat*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee))/(1.0+(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)*(fabs(x_vel[i][j])/Ee)));
			  y_vel[i][j]=sign(y_vel[i][j])*((mu_GaAs*fabs(y_vel[i][j]) + vsat*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee))/(1.0+(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)*(fabs(y_vel[i][j])/Ee)));
			  vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		  }
	 }
	 *//*
	  for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
	           x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			   y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((vsat*fabs(vel_mag[i][j])/Ee + vsat*sqr(sqr((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(sqr((fabs(vel_mag[i][j])/Ee)))));
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		  }
	  }*/
	  // Полескоростная характеристика сверена с ЗИ:
     for (int i=0; i<M+2; i++) {
	      for (int j=0; j<N+2; j++) {
			   vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			   if (vel_mag[i][j]>1e-30) {
			      x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			      y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*((mu_GaAs*fabs(vel_mag[i][j]) + vsat*sqr(((fabs(vel_mag[i][j])/Ee))))/(1.0+sqr(((fabs(vel_mag[i][j])/Ee)))));
			      vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
			   }
			   else {
				   vel_mag[i][j]=0.0;
				   x_vel[i][j]=0.0;
                   y_vel[i][j]=0.0;
			   }
		  }
	  }
			 
	

	if (1) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			// exporttecplot(curent_y, xf,  yf, M, N);
			

		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					  // напряжённость электрического поля направлена в сторону противоположную 
					 // градиенту электрического потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм


	fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		
	
	

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

   }

}

   }

   // закрытие файлов :
   fclose(fpvax);
   fclose(fp);
	
	

   // Освобождение оперативной памяти из под метода Гаусса.
   free_matr(Gauss_M, dCik, Gauss_b, Gauss_x,  M, N);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();

} // startMESFETGaAs_Gauss_VAX



//***************** GaN ***************************//


// ссылка на источник с полескоростной характеристикой:
// A modified transferred-electron high-field mobility model 
// for GaN devices simulation.
// Valentin O. Turin *
// Nano-Device Laboratory, Department of Electrical Engineering, University of California, Riverside, CA 92521, USA
// Received 29 April 2005; received in revised from 2 September 2005; accepted 3 September 2005
// Available online 14 October 2005
// The review of this paper was arranged by Prof. S. Cristoloveanu

// подвижность Нитрида Галлия в зависимости от концентрации и температуры.
Real electron_mobility_GaN(Real Tamb, Real Nd) {
	// Tamb [K] температура канала транзистора в К.
	// Nd - концентрация неподвижных доноров в GaN [cm^-3].
	Real r=2000.0;
	r/=(1.0+sqrt(Nd/1.0e17));
	r*=exp((-1.68)*log(Tamb/300.0));
	return r;
} // electron_mobility_GaN

// Полескоростная характеристика GaN
Real Field_velocity_mag(Real &Emag,Real Tamb, Real Nd) {
	Emag=fabs(Emag); // V/cm
	// Tamb [K]
	// Nd [cm^-3]
	//const Real vsat=1.91e7; // cm/s
	//const Real vsat=1.91e7/((1.0-0.15)+0.15*(Tamb/300.0));
	// 23 августа 2015 статья из программы TCAD скорость насыщения 1.8е7
	const Real vsat = 1.8e7f / ((1.0f - 0.15f) + 0.15f*(Tamb / 300.0f));
	const Real vreff=2.86e7;
	const Real EKreff=14000.0;
	const Real Et=41000.0;
	const Real Emt=257000.0;
	const Real betaC=1.7;
	const Real betat=5.7;
	const Real betak=4.0;
	const Real deltaEk=0.0;
	const Real muhigh=100.0;
	const Real mulow=electron_mobility_GaN(Tamb,Nd); // подвижность. cm^2/V/s

	Real r;

	//printf("%e %e %e",log(mulow/muhigh),exp((betaC/(1.0+betaC))*log(mulow/muhigh)), exp((betaC/(1.0+betaC))*log(mulow/muhigh))-1.0);
	if (sizeof(Real)==8) {
		// тип double

	Real E1;
	if (mulow>muhigh) {
		 E1=(vsat/mulow)*exp((1.0/betaC)*log(exp((betaC/(1.0+betaC))*log(mulow/muhigh))-1.0));
	}
	else
	{
		E1=vsat/mulow;
	}
	Real vcanali=mulow*E1/(exp((1.0/betaC)*log(1.0+exp(betaC*log(mulow*E1/vsat)))));

	//Real Ek=(vsat/mulow)*(muhigh/(mulow-muhigh))*exp((1.0+1.0/betaC)*log(exp((betaC/(1.0+betaC))*log(mulow/muhigh))-1.0))+deltaEk;
	Real Ek=vcanali/(mulow-muhigh)-(muhigh/(mulow-muhigh))*E1+deltaEk;
	Real FE=mulow*Emag;
	if (mulow>muhigh) {
		FE=FE/(exp((1.0/betak)*log(1.0+exp(betak*log(mulow*Emag/((mulow-muhigh)*Ek+muhigh*Emag))))));
	}
	Real Vmte=(FE+vsat*exp(betat*log(Emag/Emt)))/(1.0+exp(betat*log(Emag/Emt)));
	Real Vc=mulow*Emag/(exp((1.0/betaC)*log(1.0+exp(betaC*log(mulow*Emag/vsat)))));

    Real FEloc=mulow*Emt;
	if (mulow>muhigh) {
		FEloc=FEloc/(exp((1.0/betak)*log(1.0+exp(betak*log(mulow*Emt/((mulow-muhigh)*Ek+muhigh*Emt))))));
	}
	Real Vmteloc=(FEloc+vsat)/(2.0);
	Real Vcloc=mulow*Emt/(exp((1.0/betaC)*log(1.0+exp(betaC*log(mulow*Emt/vsat)))));

	//printf("%e %e %e %e %e %e %e\n",Ek,FE,Vmte,Vc,FEloc,Vmteloc,Vcloc);

	Real x=0.5;
	Real xold=0.5;
	// Нахождение x.
	for (int i=0; i<100; i++) {
		Real xd1=sqr(sin(3.141*x/2.0));
		Real xd2=1.0-xd1;
		x=(xd1*Vmteloc+xd2*Vcloc)/vreff;
		if (fabs(x-xold)<0.001) {
			// досрочный выход из цикла for.
			break;
		}
		xold=x;
	}

	
	r=sqr(sin(3.141*x/2.0))*Vmte+sqr(cos(3.141*x/2.0))*Vc;
	}

	if (sizeof(Real)==4) {
		// тип float

	Real E1;
	if (mulow>muhigh) {
		 E1=(vsat/mulow)*expf((1.0/betaC)*logf(expf((betaC/(1.0+betaC))*logf(mulow/muhigh))-1.0));
	}
	else
	{
		E1=vsat/mulow;
	}
	Real vcanali=mulow*E1/(expf((1.0/betaC)*logf(1.0+expf(betaC*logf(mulow*E1/vsat)))));

	//Real Ek=(vsat/mulow)*(muhigh/(mulow-muhigh))*exp((1.0+1.0/betaC)*log(exp((betaC/(1.0+betaC))*log(mulow/muhigh))-1.0))+deltaEk;
	Real Ek=vcanali/(mulow-muhigh)-(muhigh/(mulow-muhigh))*E1+deltaEk;
	Real FE=mulow*Emag;
	if (mulow>muhigh) {
		FE=FE/(expf((1.0/betak)*logf(1.0+expf(betak*logf(mulow*Emag/((mulow-muhigh)*Ek+muhigh*Emag))))));
	}
	Real Vmte=(FE+vsat*expf(betat*logf(Emag/Emt)))/(1.0+expf(betat*logf(Emag/Emt)));
	Real Vc=mulow*Emag/(expf((1.0/betaC)*logf(1.0+expf(betaC*logf(mulow*Emag/vsat)))));

    Real FEloc=mulow*Emt;
	if (mulow>muhigh) {
		FEloc=FEloc/(expf((1.0/betak)*logf(1.0+expf(betak*logf(mulow*Emt/((mulow-muhigh)*Ek+muhigh*Emt))))));
	}
	Real Vmteloc=(FEloc+vsat)/(2.0);
	Real Vcloc=mulow*Emt/(expf((1.0/betaC)*logf(1.0+expf(betaC*logf(mulow*Emt/vsat)))));

	//printf("%e %e %e %e %e %e %e\n",Ek,FE,Vmte,Vc,FEloc,Vmteloc,Vcloc);

	Real x=0.5;
	Real xold=0.5;
	// Нахождение x.
	for (int i=0; i<100; i++) {
		Real xd1=sqr(sinf(3.141*x/2.0));
		Real xd2=1.0-xd1;
		x=(xd1*Vmteloc+xd2*Vcloc)/vreff;
		if (fabs(x-xold)<0.001) {
			// досрочный выход из цикла for.
			break;
		}
		xold=x;
	}

	
	r=sqr(sinf(3.141*x/2.0))*Vmte+sqr(cosf(3.141*x/2.0))*Vc;
	}

	return r;
}


// Полескоростная характеристика GaN
// mulow - значение подвижности на которой основана полескоростная характеристика.
Real Field_velocity_magAlGaNGaN(Real &Emag,Real mulow, Real Tamb) {
	//printf("E=%e, mulow=%e, Tamb=%e\n",Emag,mulow,Tamb);

	Emag=fabs(Emag); // V/cm

	if (Emag > 1.0e-14f) {
		if (Emag > 1e6) {
			return 1.8e7 / ((1.0 - 0.15) + 0.15*(Tamb / 300.0));
		}
		else {
			// Tamb [K]
			// Nd [cm^-3]
#if DMY_FLOAT

	//const Real vsat=1.91e7; // cm/s 
	//const Real vsat=1.91e7f/((1.0f-0.15f)+0.15f*(Tamb/300.0f));
	// 23 августа 2015 статья из программы TCAD скорость насыщения 1.2е7
			const Real vsat = 1.8e7f / ((1.0f - 0.15f) + 0.15f*(Tamb / 300.0f));
			const Real vreff = 2.86e7f;
			const Real EKreff = 14.0e3f;
			const Real Et = 41.0e3f;
			const Real Emt = 257.0e3f;
			const Real betaC = 1.7f;
			const Real betat = 5.7f;
			const Real betak = 4.0f;
			const Real deltaEk = 0.0f;
			const Real muhigh = 100.0f;
			// mulow подвижность. cm^2/V/s Параметр передаётся извне в данную процедуру.
#else
	//const Real vsat=1.91e7; // cm/s
	//const Real vsat=1.91e7/((1.0-0.15)+0.15*(Tamb/300.0));
			const Real vsat = 1.8e7 / ((1.0 - 0.15) + 0.15*(Tamb / 300.0));
			const Real vreff = 2.86e7;
			const Real EKreff = 14000.0;
			const Real Et = 41000.0;
			const Real Emt = 257000.0;
			const Real betaC = 1.7;
			const Real betat = 5.7;
			const Real betak = 4.0;
			const Real deltaEk = 0.0;
			const Real muhigh = 100.0;
			// mulow подвижность. cm^2/V/s Параметр передаётся извне в данную процедуру.
#endif

	//printf("mulow=%e Emag=%e \n %e %e %e\n",mulow, Emag, log(mulow/muhigh),exp((betaC/(1.0+betaC))*log(mulow/muhigh)), exp((betaC/(1.0+betaC))*log(mulow/muhigh))-1.0);

			Real r;


			if (sizeof(Real) == 8) {
				// тип double

				Real E1;
				if (mulow > muhigh) {
					E1 = (vsat / mulow)*exp((1.0 / betaC)*log(exp((betaC / (1.0 + betaC))*log(mulow / muhigh)) - 1.0));
				}
				else
				{
					E1 = vsat / mulow;
				}
				Real vcanali = mulow*E1 / (exp((1.0 / betaC)*log(1.0 + exp(betaC*log(mulow*(E1 / vsat))))));


				//Real Ek=(vsat/mulow)*(muhigh/(mulow-muhigh))*exp((1.0+1.0/betaC)*log(exp((betaC/(1.0+betaC))*log(mulow/muhigh))-1.0))+deltaEk;
				Real Ek = vcanali / (mulow - muhigh) - (muhigh / (mulow - muhigh))*E1 + deltaEk;


				Real FE = mulow*Emag;
				if (mulow > muhigh) {
					FE = FE / (exp((1.0 / betak)*log(1.0 + exp(betak*log(mulow*(Emag / ((mulow - muhigh)*Ek + muhigh*Emag)))))));
					//printf("login=%e, logout=%e\n",mulow*Emag/((mulow-muhigh)*Ek+muhigh*Emag), 1.0+exp(betak*log(mulow*Emag/((mulow-muhigh)*Ek+muhigh*Emag))) );
				}
				Real Vmte = (FE + vsat*exp(betat*log(Emag / Emt))) / (1.0 + exp(betat*log(Emag / Emt)));
				Real Vc = mulow*(Emag / (exp((1.0 / betaC)*log(1.0 + exp(betaC*log(mulow*(Emag / vsat)))))));

				Real FEloc = mulow*Emt;
				if (mulow > muhigh) {
					FEloc = FEloc / (exp((1.0 / betak)*log(1.0 + exp(betak*log(mulow*(Emt / ((mulow - muhigh)*Ek + muhigh*Emt)))))));
				}
				Real Vmteloc = (FEloc + vsat) / (2.0);
				Real Vcloc = mulow*Emt / (exp((1.0 / betaC)*log(1.0 + exp(betaC*log(mulow*(Emt / vsat))))));

				//printf("Ek=%e FE=%e Vmte=%e Vc=%e FEloc=%e Vmteloc=%e Vcloc=%e\n",Ek,FE,Vmte,Vc,FEloc,Vmteloc,Vcloc);
				//getchar();

				Real x = 0.5;
				Real xold = 0.5;
				// Нахождение x.
				for (int i = 0; i < 100; i++) {
					Real xd1 = sqr(sin(3.141*x / 2.0));
					Real xd2 = 1.0 - xd1;
					x = (xd1*Vmteloc + xd2*Vcloc) / vreff;
					if (fabs(x - xold) < 0.001) {
						// досрочный выход из цикла for.
						break;
					}
					xold = x;
				}

				r = sqr(sin(3.141*x / 2.0))*Vmte + sqr(cos(3.141*x / 2.0))*Vc;


			}


			if (sizeof(Real) == 4) {
				// тип float

				Real E1;
				if (mulow > muhigh) {
					E1 = (vsat / mulow)*expf((1.0 / betaC)*logf(expf((betaC / (1.0 + betaC))*logf(mulow / muhigh)) - 1.0));
				}
				else
				{
					E1 = vsat / mulow;
				}
				Real vcanali = mulow*E1 / (expf((1.0 / betaC)*logf(1.0 + expf(betaC*logf(mulow*E1 / vsat)))));


				//Real Ek=(vsat/mulow)*(muhigh/(mulow-muhigh))*expf((1.0+1.0/betaC)*logf(exp((betaC/(1.0+betaC))*logf(mulow/muhigh))-1.0))+deltaEk;
				Real Ek = vcanali / (mulow - muhigh) - (muhigh / (mulow - muhigh))*E1 + deltaEk;


				Real FE = mulow*Emag;
				if (mulow > muhigh) {
					FE = FE / (expf((1.0 / betak)*logf(1.0 + expf(betak*logf(mulow*Emag / ((mulow - muhigh)*Ek + muhigh*Emag))))));
					//printf("login=%e, logout=%e\n",mulow*Emag/((mulow-muhigh)*Ek+muhigh*Emag), 1.0+exp(betak*log(mulow*Emag/((mulow-muhigh)*Ek+muhigh*Emag))) );
				}
				Real Vmte = (FE + vsat*expf(betat*logf(Emag / Emt))) / (1.0 + expf(betat*logf(Emag / Emt)));
				Real Vc = mulow*Emag / (expf((1.0 / betaC)*logf(1.0 + expf(betaC*logf(mulow*Emag / vsat)))));

				Real FEloc = mulow*Emt;
				if (mulow > muhigh) {
					FEloc = FEloc / (expf((1.0 / betak)*logf(1.0 + expf(betak*logf(mulow*Emt / ((mulow - muhigh)*Ek + muhigh*Emt))))));
				}
				Real Vmteloc = (FEloc + vsat) / (2.0);
				Real Vcloc = mulow*Emt / (expf((1.0 / betaC)*logf(1.0 + expf(betaC*logf(mulow*Emt / vsat)))));

				//printf("Ek=%e FE=%e Vmte=%e Vc=%e FEloc=%e Vmteloc=%e Vcloc=%e\n",Ek,FE,Vmte,Vc,FEloc,Vmteloc,Vcloc);
				//getchar();


#if MY_FLOAT

				Real x = 0.5f;
				Real xold = 0.5f;
				// Нахождение x.
				for (int i = 0; i < 100; i++) {
					Real xd1 = sqr(sinf(3.141f*x / 2.0f));
					Real xd2 = 1.0f - xd1;
					x = (xd1*Vmteloc + xd2*Vcloc) / vreff;
					if (fabs(x - xold) < 0.001f) {
						// досрочный выход из цикла for.
						break;
					}
					xold = x;
				}

				Real xd1 = sqr(sinf(3.141f*x / 2.0f));
				Real xd2 = 1.0f - xd1;
				r = xd1*Vmte + xd2*Vc;
#else
				Real x = 0.5;
				Real xold = 0.5;
				// Нахождение x.
				for (int i = 0; i < 100; i++) {
					Real xd1 = sqr(sinf(3.141*x / 2.0));
					Real xd2 = 1.0 - xd1;
					x = (xd1*Vmteloc + xd2*Vcloc) / vreff;
					if (fabs(x - xold) < 0.001) {
						// досрочный выход из цикла for.
						break;
					}
					xold = x;
				}

				r = sqr(sinf(3.141*x / 2.0))*Vmte + sqr(cosf(3.141*x / 2.0))*Vc;
#endif

			}

			return r;

		}
	}
	else {
		return 0.0;
	}
} // Field_velocity_magAlGaNGaN


//***************** GaN ***************************//

//************граница раздела сред между GaN и AlxGa1-xN************
//***********************delta layer********************************
Real electron_mobility_delta_layer(Real ns, Real Tamb) {
	// подвижность электронов в потенциальной яме
	// на границе раздела материалов в дельта слое.
#if MY_FLOAT
	Real r=4800.0f;
	// тип float
	r/=(1.0f+sqrtf(ns/1e12f));
    r*=expf(-1.5648f*logf(Tamb/300.0f));
#else
	Real r=4800.0;
// тип double
	r/=(1.0+sqrt(ns/1e12));
	r*=exp(-1.564784*log(Tamb/300.0));
#endif
	return r;
}
//***********************delta layer********************************
//************граница раздела сред между GaN и AlxGa1-xN************

//****************свойства AlxGa1-xN********************************
// подвижность Нитрида Аллюминия в зависимости от концентрации и температуры.
Real electron_mobility_AlN(Real Tamb, Real Nd) 
{
	// Tamb [K] температура канала транзистора в К.
	// Nd - концентрация неподвижных доноров в AlN [cm^-3].
#if MY_FLOAT
	Real r=1.1166f*180.03f;

	r/=(0.1166f+expf(0.1927f*logf(Nd/1.0e17f)));
	r*=expf((-2.0437f)*logf(Tamb/300.0f));

#else
	Real r=1.116606869*180.02848;
	r/=(0.1166068691+exp(0.1927258785*log(Nd/1.0e17)));
	r*=exp((-2.0437314)*log(Tamb/300.0));
#endif
	return r;
}

Real dielectric_const_AlxGa1_xN(Real x) {
	// epsilon GaN 9.5
	// epsilon AlN 8.5
#if MY_FLOAT
	Real r=((1.0f-0.28f)*8.5f+0.28f*9.5f);
#else
	Real r=((1.0-0.28)*8.5+0.28*9.5);
#endif
	return (r);
}

Real electron_mobilityAlxGa1_xN(Real x, Real Tamb, Real Nd) {
	// mobility GaN 1000 (300K Nd=1e17)
	// mobility AlN 135 (300K Nd=1e17) 
	// Для AlN по результатам работы найденной в интернете подвижность для Tamb=300K и Nd=1e17 mu_AlN=180.0;
	// Ссылка на работу :
	// Calculation of electron mobility in wz-AlN and zb-AlN at low electric field. H.Arabshahi, M.Izadifard and A.Karimi.

	Real muGaN=electron_mobility_GaN(Tamb,Nd);
	Real muAlN=electron_mobility_AlN(Tamb,Nd);
	Real r;
#if MY_FLOAT
	r=1.0f/((x/muAlN)+((1.0f-x)/muGaN)+(x*(1.0f-x)/40.0f));
#else
    r=1.0/((x/muAlN)+((1.0-x)/muGaN)+(x*(1.0-x)/40.0));
#endif
	// получается 127.64 cm^2/V/s  при x=0.28 
	return r;
}

// скорость насыщения в AlxGa1-xN cm/s
Real vsat_AlxGa1_xN(Real x) {
	// Nd 1e17
#if MY_FLOAT
	Real CvsatAB=-3.85e7f;
	Real vsatAlN=1.4e7f;
	Real vsatGaN=2.5e7f;
#else
	Real CvsatAB=-3.85e7;
	Real vsatAlN=1.4e7;
	Real vsatGaN=2.5e7;
#endif
	return ((1.0-x)*vsatAlN+x*vsatGaN+x*(1.0-x)*CvsatAB);
}

// критическое поле в AlxGa1-xN В/см
Real Ecrit_AlxGa1_xN(Real x) {
	// Nd 1e17
#if MY_FLOAT 
	Real CEcritAB=50e3f;
	Real EcritAlN=450e3f;
	Real EcritGaN=150e3f;
#else
    Real CEcritAB=50e3;
	Real EcritAlN=450e3;
	Real EcritGaN=150e3;
#endif
	return ((1.0-x)*EcritAlN+x*EcritGaN+x*(1.0-x)*CEcritAB);
}

// пиковая скорость в AlxGa1_xN см/с
Real Vpeak_AlxGa1_xN(Real x) {
	// Nd 1e17
#if MY_FLOAT 
	Real CVpeakAB=-0.1e7f;
	Real VpeakAlN=1.7e7f;
	Real VpeakGaN=3.1e7f;
#else
	Real CVpeakAB=-0.1e7;
	Real VpeakAlN=1.7e7;
	Real VpeakGaN=3.1e7;
#endif
	return ((1.0-x)*VpeakAlN+x*VpeakGaN+x*(1-x)*CVpeakAB);
}

// Внимание важное замечание:
// Подвижность зависит от температуры кристаллической решётки и от концентрации доноров.
// Исходный посыл состоит в том что концентрация доноров постоянная вро всей расчётной области и известна заранее.
// Также мы исходим из того, что температура кристаллической решётки неизменна и известна заранее до начала расчёта.
// Таким образом подвижность есть константа на протяжении всего времени расчёта,  
// Иными словами мы пришли к тому что полескоростная характеристика зависит лишь от модуля напряжённости электрического поля,
// а значит нет препятствий использовать хэш таблицу как в случае с кремнием.
Real GaNDriftVel(Real keyEmag, Real Nd, Real Tamb) {
	int ikey=hash(keyEmag);
	Real ret;
	if (hash_table[ikey].bvisit==false) {
		// вычисление :
        
		if (keyEmag<1.0e-1) {
			ret=hash_table[ikey].val=0.0; // 0
		}
		else {
			
            ret=hash_table[ikey].val=(1.0/keyEmag)*Field_velocity_mag(keyEmag,Tamb, Nd);
		}
		hash_table[ikey].bvisit=true;
	}
	else {
		ret=hash_table[ikey].val;
	}
	return ret;
}



//****************свойства AlxGa1-xN********************************


// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Нитрид Галлия.
void startMESFETGaN() {

	inithashtable(); // нициализация хэш таблицы.

    
#if MY_FLOAT 

	// V
	Real ug=-1.0f; // напряжение на затворе. -1V
	Real ud=10.0f;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17f; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0f; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4f; // позиция конца истока.
	Real xstartgate=3.0e-4f; // позиция начала затвора
	Real xendgate=5.0e-4f; // позиция конца затвора
	Real xstartdrain=7.0e-4f; // позиция начала стока.
	lengthx=9.0e-4f; // протяжённость всей моделируемой области.
	lengthy=0.3e-4f; // высота канала.

#else
    // V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.

#endif
	
	FILE *fp;
	errno_t err1;
	
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}
	
	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы:
	const Real epsilonGaN=9.5;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	//const Real mu_GaAs=4966.999; // подвижность электронов в кремнии. 
	
	// подвижность в нитриде Галлия
	const Real mu_GaN=electron_mobility_GaN(Tamb, Nd);
	Real K1=elementary_q/epsilon0/epsilonGaN;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_GaN*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaN*epsilon0/(elementary_q*Nd*mu_GaN); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//не менее 18400 шагов по времени с tau=2.0*tauM; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;
	int iend_Krjlov = 3;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ для потенциала
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	Real** r_variable_for_Krjlov;
	my_alloc_universal(r_variable_for_Krjlov, M, N);

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N); // выделение памяти под матрицу потенциала.
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.
				 if (0) {
					 // itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
					 for (int i = 0; i < iend; i++) {
						 // Метод Гаусса, Зейделя, Ричардсона, Либмана
						// Seidel(u, rthdsd, A, M, N);
						 // метод последовательной верхней релаксации с коэффициентом 1.855.
						 Real URF = 1.855;
						 SORDirichlet(u, rthdsd, A, URF, M, N);

					 }
					 //Ilyin1985quick(u, rthdsd, A, M, N, iend);
				 }
				 else {
					
					 my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, r_variable_for_Krjlov, M, N);
					 // 300 - это число итераций. оно же iend
					 itsolve_krjlov(u, u_old, r_variable_for_Krjlov, rthdsd, M, N, GMRESalg, A, iend_Krjlov);
					 
				 }

			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			  if (0) {
	             // Найдём компоненты скорости не ограниченной сверху они соноправлены градиету потенциала :
	             calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			     for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
					     // Напряжённости же поля противоположны градиенту потенциала.
					     ex[i][j]=-x_vel[i][j];
					     ey[i][j]=-y_vel[i][j];
					     emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				     }
			     }
			 }
			

	         // Применение реальной полескоростной характеристики Нитрида Галлия :
			
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
					   if (vel_mag[i][j]>1.0e-30) {
	                       x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   }
					   else {
						   x_vel[i][j]=0.0;
						   y_vel[i][j]=0.0;
						   vel_mag[i][j]=0.0;
					   }
		          }
	           }
			 }

			

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			 // аппроксимация Крёмера.
			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 // Vy
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			
			 /*
			 // Рабочий вариант работающий без использования хэш таблицы.
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					    x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						  y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }
			 */

		
			 // Вариант с использованием хэш таблицы.
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					
					 if (velmag_loc>1.0e-30) {
					    x_vel_face_we[i][j]=x_vel_face_we[i][j]*GaNDriftVel(velmag_loc,  Nd, Tamb);
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=y_vel_face_sn[i][j]*GaNDriftVel(velmag_loc,  Nd, Tamb);
					 }
					 else {
						  y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }


			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn, rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 if (0) {
				 for (int i = 0; i < iendn; i++) {
					 Seidel(n, rthdsdn, An, M, N);
				 }
			 }
			 else {

				my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, r_variable_for_Krjlov, M, N);
				// 300 - это число итераций. оно же iend
				itsolve_krjlov(n, n_buf, r_variable_for_Krjlov, rthdsdn, M, N, GMRESalg, An, iend_Krjlov);

		      }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/

		

	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		printf("%d%% %f %1.4f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))),0.1*elementary_q*isource_loc);

	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

	 
	calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	
	for (int i=0; i<M+2; i++) {
	     for (int j=0; j<N+2; j++) {
		      vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		      Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
			   if (vel_mag[i][j]>1.0e-30) {
				    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
               }
			   else {
				   x_vel[i][j]=0.0;
				   y_vel[i][j]=0.0;
				   vel_mag[i][j]=0.0;
				}
	         
		 }
	}	 


	  

	if (1) {
			  // найдём токи Сверено с Федотовым стр. 648.
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 // напряжённость электрического поля направлена в сторону противоположную 
					 // градиенту электрического потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		printf("Not Found and open file task.txt\n");
		// данные записаны не будут
	}
	else {
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		fclose(fp);
	}
	
	my_free_universal(r_variable_for_Krjlov, M, N);

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();

} // startMESFETGaN

// загружает распределение K1Nd
// Для AlGaNGaN транзиситора.
void loadK1Nd(Real** &Ndprofile, Real xendsource, Real xstartgate, Real xendgate, Real xstartdrain,
			   Real ystartdelta, Real yenddelta, Real yendundopedUpAlGaN, Real ystartsourceanddrainLEG, Real NdnoOhmic,
			   Real NdUndopped, Real NdUpLeg, Real ns, int m, int n, Real *x, Real *y)
{
		 // ns // cm^-2 поверхностная концентрация дельта слоя.
	     // остальные концентрации в cm^-3.

	// Предположим прямоугольный профиль легирования в delta слое.
	Real Nddelta=ns/(yenddelta-ystartdelta);


	for (int i=0; i<m+2; i++) for (int j=0; j<n+2; j++) {

		if ((y[j]>=ystartsourceanddrainLEG)&&((x[i]<=xendsource)||(x[i]>=xstartdrain))) {
			// хорошо пролегированная область под контактами истока и стока.
			Ndprofile[i][j]=NdnoOhmic;
		}
		else if ((y[j]>yendundopedUpAlGaN)&&((x[i]>xendsource)&&(x[i]<xstartdrain))) {
			// верхний подзатворный слой соединённый с контактами истока и стока.
			Ndprofile[i][j]=NdUpLeg;
		}
		else if (((y[j]>=ystartdelta)&&(y[j]<=yenddelta))) {
			// концентрация дельта слоя.
			Ndprofile[i][j]=Nddelta;
		}
		else {
			// нелегированный слой.
			Ndprofile[i][j]=NdUndopped;
		}
	}

} // загружает распределение K1Nd в случае AlGaNGaN транзистора.

// Загружает относительную диэлектрическую проницаемость для AlGaNGaN транзистора.
void loadK300(Real** &K300,Real epsilonGaN, Real xgold,
			  Real ystartsourceanddrainLEG, Real xendsource, Real xstartdrain,
			  Real yenddelta, Real ystartdelta, 
			    Real* x, Real *y, int m, int n) {

	// AlxgoldGa1-xgoldN
	// xgold=0.28;

	for (int i=0; i<m+2; i++) for (int j=0; j<n+2; j++) {

		if ((y[j]>=ystartsourceanddrainLEG)&&((x[i]<=xendsource)||(x[i]>=xstartdrain))) {
			// хорошо пролегированная область под контактами истока и стока.
			// GaN
			K300[i][j]=epsilonGaN;
		}
		else if ((y[j]>yenddelta)&&((x[i]>xendsource)&&(x[i]<xstartdrain))) {
			// верхний подзатворный слой соединённый с контактами истока и стока.
			// AlGaN
			K300[i][j]=dielectric_const_AlxGa1_xN(xgold);
		}
		else if (((y[j]>=ystartdelta)&&(y[j]<=yenddelta))) {
			// концентрация дельта слоя.
			K300[i][j]=2.0*epsilonGaN*dielectric_const_AlxGa1_xN(xgold)/(epsilonGaN+dielectric_const_AlxGa1_xN(xgold));
		}
		else {
			// нелегированный слой.
			K300[i][j]=epsilonGaN;
		}
	}

} // loadK300

// Коэффициент диффузии при переносе электроннного газа.
void loadK300Dn(Real** &K300Dn, Real **mobility, Real Tamb, int m, int n) {

	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;

	for (int i=0; i<m+2; i++) for (int j=0; j<n+2; j++) {
		K300Dn[i][j]=mobility[i][j]*k_bolcman*Tamb/elementary_q;
	}

} //loadK300Dn

// Загружает подвижность с учётом неоднородного легирования и дельта слоя.
void loadmobility(Real** &mobility, Real **Ndprofile, Real xendsource, Real xstartgate, Real xendgate, Real xstartdrain, Real ystartdelta, Real yenddelta, Real yendundopedUpAlGaN, Real ystartsourceanddrainLEG, Real ns, Real Tamb,
				  int m, int n, Real *x, Real *y) {
	for (int i=0; i<m+2; i++) for (int j=0; j<n+2; j++) {

		if ((y[j]>=ystartsourceanddrainLEG)&&((x[i]<=xendsource)||(x[i]>=xstartdrain))) {
			// хорошо пролегированная область под контактами истока и стока.
			// GaN
			mobility[i][j]=electron_mobility_GaN(Tamb, Ndprofile[i][j]);
		}
		else if ((y[j]>yenddelta)&&((x[i]>xendsource)&&(x[i]<xstartdrain))) {
			// верхний подзатворный слой соединённый с контактами истока и стока.
			// AlGaN
			Real x_gold=0.28;
			mobility[i][j]=electron_mobilityAlxGa1_xN(x_gold, Tamb, Ndprofile[i][j]);
		}
		else if (((y[j]>=ystartdelta)&&(y[j]<=yenddelta))) {
			// концентрация дельта слоя.
			mobility[i][j]=electron_mobility_delta_layer(ns,Tamb);
		}
		else {
			// нелегированный слой.
			mobility[i][j]=electron_mobility_GaN(Tamb,Ndprofile[i][j]);
		}
	}
} // loadmobility

Real anderson_patch(int i,int j, Real* x, Real* y, Real ystartdelta, Real yenddelta) {
	
	// дополнительный потенциал вызванный разницей энергий сродства электрону для GaN и AlGaN.
	// Xe_GaN=4.1; Xe_AlN=1.9; Xe_AlGaN=2.516;
	// Al0.28GaN.
	// deltaEn=-delta(Xe)/q=-(Xe_GaN-Xe_AlGaN)/(q*(yenddelta- ystartdelta));добавок к напряжённости.
	// E=-grad(u);
	Real dXe = 1.584;
	Real ret = 0.0;
	Real r = 1.005*(yenddelta - ystartdelta);
	Real a = 0.5*(yenddelta + ystartdelta);
	if (((y[j] >= ystartdelta) && (y[j] <= yenddelta))) {
		// Андерсовая модификация потенциала.
		ret = dXe*2.718281828*exp(-r*r/(r*r-(y[j]-a)*(y[j]-a)));

	}
	return ret;
}

// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Нитрид Галлия.
// Пробивные напряжения в GaN равны 3.3e6 В/см.
// Гетеро переход и дельта канал.
void startMESFETAlGaNGaN() {

    int inumcore=1; // только два потока. // четыре потока. // восемь потоков. // 12 потоков. // 9 это 8 плюс один поток для вызова акселератора 
	omp_set_dynamic(0); // не давать системе использовать количество нитей которое она хочет.
	omp_set_num_threads(inumcore); // два потока


	amgGM.a = NULL;
	amgGM.f = NULL;
	amgGM.ia = NULL;
	amgGM.ig = NULL;
	amgGM.ja = NULL;
	amgGM.u = NULL;


#if MY_FLOAT   
	// V
	
	Real ug=0.0f; // напряжение на затворе. -1V
	Real ud=28.0f;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	// Сильное легирование истока и стока.
	Real NdnoOhmic=1.0e19f; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real NdUndopped=1.0e15f; // нелегированный слой.
	Real NdUpLeg=8.0e18f; // легированная верхушка примыкающая к затвору и соединяющая исток и сток.
	//Real ns=8.0e12f; // cm^-2. // Поверхностная концентрация.
	Real ns = 1.3e13f; // cm^-2
	int din=1;
	Real Tamb=400.0f; // температура полупроводника.

	// cm
	Real xendsource=0.5e-4f; // позиция конца истока.
	Real xstartgate=1.0e-4f; // позиция начала затвора
	Real xendgate=1.25e-4f; // позиция конца затвора
	Real xstartdrain=1.75e-4f; // позиция начала стока.
	lengthx=2.25e-4f; // протяжённость всей моделируемой области.
	//Real ystartdelta=0.1e-4f; // Начало дельта слоя.
	//Real yenddelta=0.101e-4f; // позиция окончания дельта слоя.
	//Real yendundopedUpAlGaN=0.107e-4f; // Позиция окончания нелигированного слоя сверху от дельта слоя. 
	//Real ystartsourceanddrainLEG=0.09e-4f; // позиция начала сильного легирования истока и стока.
	//lengthy=0.12e-4f; // высота канала.
	// На основе статьи про TCAD моделирование AlGaNGaN толщина области всего 600нм.
	// Максимальный ток 1А с 1мм ширины затвора.
	Real ystartdelta = 0.03e-4f; // Начало дельта слоя.
	Real yenddelta = 0.031e-4f; // позиция окончания дельта слоя.
	Real yendundopedUpAlGaN = 0.037e-4f; // Позиция окончания нелигированного слоя сверху от дельта слоя. 
	Real ystartsourceanddrainLEG = 0.02e-4f; // позиция начала сильного легирования истока и стока.
	lengthy = 0.05e-4f; // высота канала как в статье про TCAD.

#else
    // V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	// Сильное легирование истока и стока.
	Real NdnoOhmic=1.0e19; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real NdUndopped=1.0e15; // нелегированный слой.
	Real NdUpLeg=8.0e18; // легированная верхушка примыкающая к затвору и соединяющая исток и сток.
	//Real ns=8.0e12; // cm^-2. // Поверхностная концентрация.
	Real ns = 1.3e13f; // cm^-2
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=0.5e-4; // позиция конца истока.
	Real xstartgate=1.0e-4; // позиция начала затвора
	Real xendgate=1.25e-4; // позиция конца затвора
	Real xstartdrain=1.75e-4; // позиция начала стока.
	lengthx=2.25e-4; // протяжённость всей моделируемой области.
	//Real ystartdelta=0.1e-4; // Начало дельта слоя.
	//Real yenddelta=0.101e-4; // позиция окончания дельта слоя.
	//Real yendundopedUpAlGaN=0.107e-4; // Позиция окончания нелигированного слоя сверху от дельта слоя. 
	//Real ystartsourceanddrainLEG=0.09e-4; // позиция начала сильного легирования истока и стока.
	//lengthy=0.12e-4; // высота канала.
	// Максимальный ток 1А с 1мм ширины затвора.
	Real ystartdelta = 0.03e-4f; // Начало дельта слоя.
	Real yenddelta = 0.031e-4f; // позиция окончания дельта слоя.
	Real yendundopedUpAlGaN = 0.037e-4f; // Позиция окончания нелигированного слоя сверху от дельта слоя. 
	Real ystartsourceanddrainLEG = 0.02e-4f; // позиция начала сильного легирования истока и стока.
	lengthy = 0.05e-4f; // высота канала.



#endif	

	FILE *fp_input;
	errno_t err1_input;
	//if ((err1_input = fopen_s(&fp_input, "./v1/input.txt", "r")) != 0) {
	if ((err1_input = fopen_s(&fp_input, "input.txt", "r")) != 0) {
	    printf("Not Found and open file input.txt\n");
		// Vd and Vg останутся заданными как выше.
		getchar();
		exit(1);
	}
	else {
		float fin;
		fscanf_s(fp_input, "%f", &fin);
		ud = fin;
		fscanf_s(fp_input, "%f", &fin);
		ug = fin;
		fclose(fp_input);
	}

	
	FILE *fp;
	errno_t err1;
	/*
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}
	*/
	
	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	//M=(3*q*30-1); // количество линий сетки по горизонтали
    //N=(q*10-1);// количество линий сетки по вертикали
	M = (  3*q * 30 - 1); // количество линий сетки по горизонтали
	N = (q * 15 - 1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
#if MY_FLOAT
	Real alpha=0.1f; //0.1f; // нижняя релаксация вводимая в матрицу для концентрации.
#else
	Real alpha=0.1; // 0.1; нижняя релаксация вводимая в матрицу для концентрации.
#endif
	



	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	

	
	// Относительная диэлектрическая проницаемость среды в уравнении для потенциала при 300К
	Real **K300=NULL; // относительная диэлектрическая проницаемость вещества в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=FLT_MAX;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=FLT_MAX;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	// построение y сетки в дельта слое без отладочной печати.


    //Real* yf=new Real[N+2+14];
	//Real* yf = new Real[N + 2 + 14+14];
	//Real* yf = new Real[N + 2 + 14 + 7];
	Real* yf = new Real[N + 2 + 14 + 7+3];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	const Real eps_dopusk = 1.0e-20;
	int icy=0;
	int iincrementi=0;
	bool bf1=false, bf2=false, bf3=false;
	for (int i=0; i<N-1; i++) {
		if ((((Real)(i*h2))>ystartdelta)&&(!bf1)) {
			
			// 8 дополнительных линий в дельта слое.
			if (fabs(ystartdelta-yf[icy-1])>eps_dopusk) {

			     yf[icy]=yf[icy-1]+0.5*(ystartdelta-yf[icy-1]);
			     yf[icy+1]=yf[icy-1]+0.75*(ystartdelta-yf[icy-1]);
			     icy=icy+2;
			     yf[icy++]=ystartdelta;
			  
			}
			else {

				yf[icy-1]=yf[icy-2]+0.5*(ystartdelta-yf[icy-2]);
				yf[icy-1+1]=yf[icy-2]+0.75*(ystartdelta-yf[icy-2]);
				yf[icy-1+2]=yf[icy-2]+0.875*(ystartdelta-yf[icy-2]);
				yf[icy-1+3]=ystartdelta;
				icy=icy+3;
			}
			//Real hdelta=(yenddelta-ystartdelta)/7.0;
			//Real hdelta = (yenddelta - ystartdelta) / 21.0;
			Real hdelta = (yenddelta - ystartdelta) / 14.0;

			//for (int j = 1; j <= 7; j++) yf[icy++] = ystartdelta + j*hdelta;
			//for (int j=1; j<=21; j++) yf[icy++]=ystartdelta+j*hdelta;
			for (int j = 1; j <= 14; j++) {
				// 1 2 3 4 5 6 6.5 7 7.5 8 8.5 9 10 11 12 13 14
				if ((j == 7)||(j==8)||(j==6)) {
					yf[icy++] = ystartdelta + (j-1)*hdelta+0.5*hdelta;
				}

				yf[icy++] = ystartdelta + j*hdelta;
			}

			// Толщина дельта слоя может быть больше чем h2
			// поэтому здесь потребуется локально увеличить i 
			// на несколько единиц. На сколько увеличено i необходимо запомнить чтобы скоректировать N.
			// Правило то каким должно быть i: найти минимальное i для которого yf[icy-1]<i*h2.
			if (yf[icy-1]<(Real)(i*h2)) 
			{
				//i не нужно увеличивать
			}
			else if (yf[icy-1]<(Real)((i+1)*h2))
			{
				// i нужно увеличить на единицу.
                iincrementi=1;
				i++;
			}
			else if (yf[icy-1]<(Real)((i+2)*h2))
			{
				// i нужно увеличить на двойку.
                iincrementi=2;
				i=i+2;
			}
			else if (yf[icy-1]<(Real)((i+3)*h2))
			{
				// i нужно увеличить на тройку.
                iincrementi=3;
				i=i+3;
			}
			else if (yf[icy-1]<(Real)((i+4)*h2))
			{
				// i нужно увеличить на 4.
                iincrementi=4;
				i=i+4;
			}
			else if (yf[icy-1]<(Real)((i+5)*h2))
			{
				// i нужно увеличить на 5.
                iincrementi=5;
				i=i+5;
			}
			else if (yf[icy-1]<(Real)((i+6)*h2))
			{
				// i нужно увеличить на 6.
                iincrementi=6;
				i=i+6;
			}
			else if (yf[icy-1]<(Real)((i+7)*h2))
			{
				// i нужно увеличить на 7.
                iincrementi=7;
				i=i+7;
			}
			else if (yf[icy-1]<(Real)((i+8)*h2))
			{
				// i нужно увеличить на 8.
                iincrementi=8;
				i=i+8;
			}
			else if (yf[icy-1]<(Real)((i+9)*h2))
			{
				// i нужно увеличить на 9.
                iincrementi=9;
				i=i+9;
			}
			else if (yf[icy - 1]<(Real)((i + 10)*h2))
			{
				// i нужно увеличить на 10.
				iincrementi = 10;
				i = i + 10;
			}
			else if (yf[icy - 1]<(Real)((i + 11)*h2))
			{
				// i нужно увеличить на 11.
				iincrementi = 11;
				i = i + 11;
			}
			else if (yf[icy - 1]<(Real)((i + 12)*h2))
			{
				// i нужно увеличить на 12.
				iincrementi = 12;
				i = i + 12;
			}
			else if (yf[icy - 1]<(Real)((i + 13)*h2))
			{
				// i нужно увеличить на 13.
				iincrementi = 13;
				i = i + 13;
			}
			else if (yf[icy - 1]<(Real)((i + 14)*h2))
			{
				// i нужно увеличить на 14.
				iincrementi = 14;
				i = i + 14;
			}
			else if (yf[icy - 1]<(Real)((i + 15)*h2))
			{
				// i нужно увеличить на 15.
				iincrementi = 15;
				i = i + 15;
			}
			else if (yf[icy - 1]<(Real)((i + 16)*h2))
			{
				// i нужно увеличить на 16.
				iincrementi = 16;
				i = i + 16;
			}
			else if (yf[icy - 1]<(Real)((i + 17)*h2))
			{
				// i нужно увеличить на 17.
				iincrementi = 17;
				i = i + 17;
			}
			else if (yf[icy - 1]<(Real)((i + 18)*h2))
			{
				// i нужно увеличить на 18.
				iincrementi = 18;
				i = i + 18;
			}
			else if (yf[icy - 1]<(Real)((i + 19)*h2))
			{
				// i нужно увеличить на 19.
				iincrementi = 19;
				i = i + 19;
			}
			else if (yf[icy - 1]<(Real)((i + 20)*h2))
			{
				// i нужно увеличить на 20.
				iincrementi = 20;
				i = i + 20;
			}
			else if (yf[icy - 1]<(Real)((i + 21)*h2))
			{
				// i нужно увеличить на 21.
				iincrementi = 21;
				i = i + 21;
			}
			else if (yf[icy - 1]<(Real)((i + 22)*h2))
			{
				// i нужно увеличить на 22.
				iincrementi = 22;
				i = i + 22;
			}
			else if (yf[icy - 1]<(Real)((i + 23)*h2))
			{
				// i нужно увеличить на 23.
				iincrementi = 23;
				i = i + 23;
			}
			else if (yf[icy - 1]<(Real)((i + 24)*h2))
			{
				// i нужно увеличить на 24.
				iincrementi = 24;
				i = i + 24;
			}
			else if (yf[icy - 1]<(Real)((i + 25)*h2))
			{
				// i нужно увеличить на 25.
				iincrementi = 25;
				i = i + 25;
			}
			else if (yf[icy - 1]<(Real)((i + 26)*h2))
			{
				// i нужно увеличить на 26.
				iincrementi = 26;
				i = i + 26;
			}

			yf[icy]=yf[icy-1]+0.25*((Real)(i*h2)-yf[icy-1]);
			yf[icy+1]=yf[icy-1]+0.5*((Real)(i*h2)-yf[icy-1]);
			icy=icy+2;

			yf[icy++]=(Real)(i*h2);
			bf1=true;

		}
		else if ((((Real)(i*h2))>yendundopedUpAlGaN)&&(!bf2)) {
			// одна дополнительная линия
			if (fabs(yendundopedUpAlGaN-((Real)(i*h2)))<eps_dopusk) {
				yf[icy++]=yendundopedUpAlGaN-0.5*h2;
				yf[icy++]=yendundopedUpAlGaN;
			}
			else {
			    yf[icy++]=yendundopedUpAlGaN;
			    yf[icy++]=(Real)(i*h2);
			}
			bf2=true;
		}
		else if ((fabs((((Real)(i*h2))-ystartsourceanddrainLEG))<eps_dopusk)&&(!bf3)) {
			yf[icy++]=(Real)(i*h2)-0.5*h2;
			yf[icy++]=ystartsourceanddrainLEG;
			bf3=true;
		}
		else if ((((Real)(i*h2))>ystartsourceanddrainLEG)&&(!bf3)) {
			// одна дополнительная линия
			//printf("%e %e",((Real)(i*h2))-ystartsourceanddrainLEG,h2); // debug
			if (fabs(((Real)(i*h2))-ystartsourceanddrainLEG-h2)<eps_dopusk) {
				 yf[icy++]=(Real)(i*h2)-0.5*h2;
			     yf[icy++]=ystartsourceanddrainLEG;
			}
			else {
			   yf[icy++]=ystartsourceanddrainLEG;
			   yf[icy++]=(Real)(i*h2);
			}
			bf3=true;
		}
		else {
		    yf[icy++]=(Real)(i*h2);
		}
	}
	//N=N+14-iincrementi;
	//N=N+14+14-iincrementi;
	//N = N + 14 + 7  - iincrementi;
	N = N + 14 + 7 +3 - iincrementi;
	//yf[N+1]=(Real)((N-1-14+iincrementi)*h2);
	//yf[N + 1] = (Real)((N - 1 - 14 -14+ iincrementi)*h2);
	//yf[N + 1] = (Real)((N - 1 - 14 - 7  + iincrementi)*h2);
	yf[N + 1] = (Real)((N - 1 - 14 - 7 -3 + iincrementi)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;

	
	for (int i = 0; i < N + 2; i++) {
		if (i < N + 1) {
			if ((yf[i + 1]>yf[i])&&(fabs(yf[i+1]-yf[i])>1.0e-10)) {
				printf("y[%d]=%e OK\n", i, yf[i]);
			}
			else {
				printf("y[%d]=%e BAD\n", i, yf[i]);
			}
		}
		else {
			printf("y[%d]=%e\n", i, yf[i]);
		}
	}
	//getchar();
	 
	// Общеупотребительные константы:
#if MY_FLOAT
	const Real epsilonGaN=9.5f;
	const Real epsilon0=8.8542e-14f;
	const Real elementary_q=1.6022e-19f;
	const Real k_bolcman=1.38e-23f;
	//const Real mu_GaAs=4967.0f; // подвижность электронов в кремнии. 
#else
	const Real epsilonGaN=9.5;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	//const Real mu_GaAs=4966.999; // подвижность электронов в кремнии. 
#endif
	
	
	// подвижность в нитриде Галлия
	// Поскольку профиль легирования сильно зависит от пространственных координат, то и подвижность зависит от пространственных координат.
	Real **mu_GaN=NULL; // Подвижность зависящая от концентрации носителей и температуры кристаллической решётки.
	Real K1=elementary_q/epsilon0;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	//Real K300Dn=mu_GaN*k_bolcman*Tamb/elementary_q;
	// Поскольку подвижность зависит от пространственных координат то и коэффициент диффузии электронов также зависит от пространственных координат.
	Real **K300Dn=NULL;
	Real tauM=epsilonGaN*epsilon0/(elementary_q*NdnoOhmic*electron_mobility_GaN(Tamb, NdnoOhmic)); // рекомендовано Гарбером.
#if MY_FLOAT
	//Real dtimestep=1.0e-12f; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0f*tauM; // два времени максвеловской релаксации.
	dtimestep=8000.0f*tauM;
#else
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	dtimestep=8000.0*tauM;
#endif
	
	int imaxnumbertimestep=40000;//не менее 18400 шагов по времени с tau=2.0*tauM; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.


	FILE *fpreport_delta = NULL;
	errno_t err_report;

	//if ((err_report = fopen_s(&fpreport_delta, "./v1/report.txt", "w")) != 0) {
	if ((err_report = fopen_s(&fpreport_delta, "report.txt", "w")) != 0) {
	    printf("Not Found and open file report.txt\n");
		getchar();
		exit(0);
	}
	
	


	printf("AlGaN/GaN delta layer modelling\n");
	printf("solving is : 2.0 tauM UDS. NO artifical diffusion !\n");
	printf("M=%d, N=%d, maxnod=%d\n",M,N,(M+2)*(N+2));
	printf("ug=%e  ud=%e\n",ug,ud);
	//getchar();

	// Будем ли использовать алгебраический многосеточный метод.
	bool buse_amg1r5 = true;
	if (buse_amg1r5) {
		printf("use Algebraic Multigrid Method Fedorenko R.P. 1961 (amg1r5 code.)\n");
	}

	if (fpreport_delta != NULL) {
		fprintf_s(fpreport_delta,"AlGaN/GaN delta layer modelling\n");
		fprintf_s(fpreport_delta,"solving is : 2.0 tauM UDS. NO artifical diffusion !\n");
		fprintf_s(fpreport_delta,"M=%d, N=%d, maxnod=%d\n", M, N, (M + 2)*(N + 2));
		fprintf_s(fpreport_delta,"ug=%e  ud=%e\n", ug, ud);
		if (buse_amg1r5) {
			fprintf_s(fpreport_delta,"use Algebraic Multigrid Method Fedorenko R.P. 1961 (amg1r5 code.)\n");
		}

	}

	
	// Хеш таблица возможно реализована с багом.
	if (buse_amg1r5) {
		imaxnumbertimestep = 720000;//240000;
		inumberinternaliter = 1; // безитерационный
		alpha = 0.8;
		//alpha = 0.1;
		//alphanu = 0.8;
		dtimestep = 2.0f*tauM;
		//dtimestep = 9.0f*tauM;
	}




	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=2;//6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=6;//21;//21;//21;

	Real** u=NULL; // рассчитываемый потенциал.
	Real** u_shadow = NULL; // потенциал не модифицированный Андерсоном.
	Real** Ndprofile=NULL; // относится к источниковому члену для потенциала.
    Real** u_old=NULL; // потенциал с предыдущей итерации.
    Real** r=NULL; // невязка
	Real** rthdsd_internal=NULL; // внутренность : правая часть
	Real** rthdsd=NULL; // правая часть.
	MATRNODE** A=NULL; // матрица СЛАУ для потенциала
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;
	bool bflagconstrA1=true;

	Real** jacobi=NULL; // вспомогательный массив для метода якоби.
	Real** n=NULL; // рассчитываемая концентрация электронов.
	Real** n_buf=NULL; // для метода Зейделя.
    Real** n_oldi=NULL; // концентрация с предыдущей итерации.
	Real** n_old=NULL; // концентрация с предыдущего временного слоя.
	Real** x_vel=NULL; // компоненты дрейфовой скорости электронов
	Real** y_vel=NULL; // по x и по y.
	Real** x_vel_face_we=NULL; // для иксовой скорости.
	Real** y_vel_face_we=NULL;
	Real** x_vel_face_sn=NULL; // для игриковой скорости. 
	Real** y_vel_face_sn=NULL;
	Real** vel_mag=NULL; // модуль скорости.
	Real** ex=NULL; // напряжённость электрического поля по x
	Real** ey=NULL; // напряжённость электрического поля по y
	Real** nx=NULL; // градиент концентрации по x.
	Real** ny=NULL; // градиент концентрации по y.
    Real** emag=NULL; // модуль напряжённости электрического поля.
	Real** curent_x=NULL; // ток по икс.
	Real** curent_y=NULL; // ток по y
	Real** curent_mag=NULL; // модуль тока.	
	Real** rn=NULL; // невязка
	Real** rthdsd_internaln=NULL; // внутренность : правая часть
	Real** rthdsdn=NULL; // правая часть.
	MATRNODE** An=NULL; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v=NULL;
    Real** v_old=NULL;
    Real** r_coarse=NULL;
	Real** rthdsd_c=NULL; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al=NULL; // матрица СЛАУ

	// для алгебраического многосеточного метода:
	Real *dX0 = new Real[(M + 2)*(N + 2)];

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	if (fpreport_delta != NULL) {
		fprintf_s(fpreport_delta, "Multigrd Fedorenko 1961 algorithm \n");
	}
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N); // выделение памяти под матрицу потенциала.
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(u_shadow, M, N);
	my_alloc_universal(jacobi, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(Ndprofile, M, N);  // относится к источниковому члену для уравнения электрического потенциала.
	my_alloc_universal(K300, M, N); // относительная диэлектрическая проницаемость полупроводника.
	my_alloc_universal(mu_GaN, M, N); // подвижность электронного газа как функция пространственных координат.
    my_alloc_universal(K300Dn, M, N); // коэффициент диффузии в уравнении переноса электронного газа зависяций от подвижности.
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);

	


#if MY_FLOAT
	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, NdnoOhmic, xf, 0.0f, n, n_oldi, n_old, M, N);
	my_init_zero(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, x_vel, M, N);
	my_init_zero(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, y_vel, M, N);
	my_init_zero(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, vel_mag, M, N);
	my_init_zero(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, u_shadow, M, N);
	// Загружает профиль легирования.
	loadK1Nd(Ndprofile, xendsource, xstartgate, xendgate, xstartdrain, ystartdelta, yenddelta, yendundopedUpAlGaN, ystartsourceanddrainLEG, NdnoOhmic, NdUndopped, NdUpLeg, ns, M, N, xf, yf);
	//exporttecplot(Ndprofile,xf,yf,M,N);
	// Загружает относительную диэлектрическую проницаемость среды для AlGaNGaN транзистора.
	loadK300(K300, epsilonGaN, 0.28f, ystartsourceanddrainLEG, xendsource, xstartdrain, yenddelta, ystartdelta, xf, yf, M, N);
	//exporttecplot(K300,xf,yf,M,N);
	// Загружает подвижность электронного газа с учётом дельта канала.
	loadmobility(mu_GaN,Ndprofile,xendsource, xstartgate, xendgate, xstartdrain, ystartdelta, yenddelta, yendundopedUpAlGaN, ystartsourceanddrainLEG, ns,Tamb,M,N,xf,yf);
	//exporttecplot(mu_GaN,xf,yf,M,N);
	// Загружает коэффициент диффузии при переносе электронного газа.
	loadK300Dn(K300Dn,mu_GaN,Tamb,M,N);
	//exporttecplot(K300Dn,xf,yf,M,N);
#else
	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, NdnoOhmic, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);
	my_init_zero(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, u_shadow, M, N);
	// Загружает профиль легирования.
	loadK1Nd(Ndprofile, xendsource, xstartgate, xendgate, xstartdrain, ystartdelta, yenddelta, yendundopedUpAlGaN, ystartsourceanddrainLEG, NdnoOhmic, NdUndopped, NdUpLeg, ns, M, N, xf, yf);
	//exporttecplot(Ndprofile,xf,yf,M,N);
	// Загружает относительную диэлектрическую проницаемость среды для AlGaNGaN транзистора.
	loadK300(K300, epsilonGaN, 0.28, ystartsourceanddrainLEG, xendsource, xstartdrain, yenddelta, ystartdelta, xf, yf, M, N);
	//exporttecplot(K300,xf,yf,M,N);
	// Загружает подвижность электронного газа с учётом дельта канала.
	loadmobility(mu_GaN,Ndprofile,xendsource, xstartgate, xendgate, xstartdrain, ystartdelta, yenddelta, yendundopedUpAlGaN, ystartsourceanddrainLEG, ns,Tamb,M,N,xf,yf);
	//exporttecplot(mu_GaN,xf,yf,M,N);
	// Загружает коэффициент диффузии при переносе электронного газа.
	loadK300Dn(K300Dn,mu_GaN,Tamb,M,N);
	//exporttecplot(K300Dn,xf,yf,M,N);
#endif
	


    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

#if MY_FLOAT
	Real time=0.0f;
#else
	Real time=0.0;
#endif
	

	Real ***hash_table_loc_x=NULL;
	hash_table_loc_x = new Real**[M + 1];
	for (int i = 0; i < M + 1; i++) hash_table_loc_x[i] = new Real*[N + 2];
	for (int i = 0; i < M + 1; i++) {
		for (int j = 0; j < N + 2; j++) {
			hash_table_loc_x[i][j] = new Real[hash_table_size];
			hash_table_loc_x[i][j][0] = 0.0;
		}
	}

	Real ***hash_table_loc_y = NULL;
	hash_table_loc_y = new Real**[M + 2];
	for (int i = 0; i < M + 2; i++) hash_table_loc_y[i] = new Real*[N + 1];
	for (int i = 0; i < M + 2; i++) {
		for (int j = 0; j < N + 1; j++) {
			hash_table_loc_y[i][j] = new Real[hash_table_size];
			hash_table_loc_y[i][j][0] = 0.0;
		}
	}

	for (int i = 0; i < M + 1; i++) {
		for (int j = 0; j < N + 2; j++) {
			for (int k = 1; k < hash_table_size; k++) {
				Real Emag1 = exp(0.0953101+k*(14.0-0.0953101)/(hash_table_size-1));
				Real speed1=Field_velocity_magAlGaNGaN(Emag1, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]), Tamb);
				if (_finite(speed1) != 0) {
					hash_table_loc_x[i][j][k] = speed1;
				}
				else {
					printf("infinity velocity X i=%d j=%d k=%d",i,j,k);
				}
			}
		}
	}

	for (int i = 0; i < M + 2; i++) {
		for (int j = 0; j < N + 1; j++) {
			for (int k = 1; k < hash_table_size; k++) {
				Real Emag1 = exp(0.0953101 + k*(14.0 - 0.0953101) / (hash_table_size - 1));
				Real speed1 = Field_velocity_magAlGaNGaN(Emag1, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]), Tamb);
				if (_finite(speed1) != 0) {
					hash_table_loc_y[i][j][k] = speed1;
				}
				else {
					printf("infinity velocity Y i=%d j=%d k=%d", i, j, k);
				}
			}
		}
	}


	//imaxnumbertimestep=200;
	dtimestep = 2.0f*tauM;
	

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		/*
		// адаптивный шаг по времени
		if (inumbertimestep > itol+4) {
			Real TOL = start_tolerance;
			//dtimestep = pow(en_1 / en, 0.075)*pow(TOL/en,0.175)*pow((en_1*en_1)/(en*en_2),0.01)*dtimestep;
			//dtimestep = pow(en_1 / en, 0.00075)*pow(TOL / en, 0.00015)*pow((en_1*en_1) / (en*en_2), 0.0001)*dtimestep;
			if (en / en_1 < 0.98) {
				dtimestep *= 1.005;
			}
			else {
				dtimestep /= 1.005;
			}

			// 2tauM
			if (dtimestep < 0.1f*tauM) {
				dtimestep = 0.1f*tauM;
			}
			if (dtimestep > 7.0f*tauM) {
				dtimestep = 7.0f*tauM;
			}
		}*/

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

             
	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    //constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				// Сборка матрицы СЛАУ для электрического потенциала в случае пространственного распределения диэлектрической проницаемости.
				constrA0MCVMESFETAlGaNGaN(A,  K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain);
				bflagconstrA=false;
			}
	        
#if MY_FLOAT
			for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0f;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1*Ndprofile[i][j]-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1*Ndprofile[i][j]-K1*n[i][j])*0.25f*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }
#else
			for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1*Ndprofile[i][j]-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1*Ndprofile[i][j]-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }
#endif

#if MY_FLOAT
#else
#endif
	         

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.
				 if (bflagconstrA1) {
				    // exporttecplot(rthdsd,xf,yf,M,N);
				    // exporttecplotM(A,xf,yf,M,N);
					 bflagconstrA1=false;
                 }
				 

				 if (buse_amg1r5) {

					 //amg_loc_memory(u_shadow, rthdsd, A, M, N, 0, dX0);
					 amg_global_memory(u_shadow, rthdsd, A, M, N, 0, dX0);

				 }
				 else {

					 // itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
					 for (int i = 0; i < iend; i++) {
						 // Метод Гаусса, Зейделя, Ричардсона, Либмана
						// Seidel(u, rthdsd, A, M, N);
						 // метод последовательной верхней релаксации с коэффициентом 1.855.
#if MY_FLOAT
						 Real URF = 1.0f;//1.855f
#else
						 Real URF = 1.0;//1.855
#endif

					  //SORDirichlet(u, rthdsd, A, URF, M, N);
					  //SORDirichlet_test(u, rthdsd, A, URF, M, N);
					//  SORDirichlet_P(u, rthdsd, A, URF, M, N, inumcore);
					//SORDirichlet_P(u, rthdsd, A, URF, M, N, 8);
					 // SORDirichlet_P(u, rthdsd, A, URF, M, N, 8);
					 // Только метод Якоби может выполняться массово и параллельно :
						 Jacobi_parallel(u_shadow, jacobi, rthdsd, A, M, N);
					 }
					 //Ilyin1985quick(u, rthdsd, A, M, N, iend);
				 }
				 

				 {
					 // Модификация Андерсона.

					 // дополнительный потенциал вызванный разницей энергий сродства электрону для GaN и AlGaN.
					 // Xe_GaN=4.1; Xe_AlN=1.9; Xe_AlGaN=2.516;
					 // Al0.28GaN.
					 // deltaEn=-delta(Xe)/q=-(Xe_GaN-Xe_AlGaN)/(q*(yenddelta- ystartdelta));добавок к напряжённости.
					 // E=-grad(u);
					 // dXe=1.584;
					 // Из-за различий плотностей сотстояний в зоне проводимости.
					 Real effective_massGaN = 0.2;
					 Real effective_massAlN = 0.48;
					 Real gold = 0.28;
					 Real NcGaN = 2.5e19*pow(effective_massGaN, 1.5)*pow(Tamb / 300, 1.5);
					 Real NcAlGaN = 2.5e19*pow((1.0 - gold)*effective_massAlN + gold*effective_massGaN, 1.5)*pow(Tamb / 300, 1.5);
					 Real dXem = -(1.38066e-23/1.60218e-19)*Tamb*(log(NcGaN)-log(NcAlGaN));
					 //printf("dXem=%1.4f \n", dXem); getchar();
					 Real dXe = 1.584-dXem;
					 for (int i = 0; i < M + 2; i++) {
						 /*
						 // детектирование максимума не подходит, т.к. вблизи стока максимум может не приходится на 
						 // центр деьта слоя.
						 Real max = -1.0e30;
						 int jposmax = 0;
						 for (int j = 0; j < N + 2; j++) {
							 if (u_shadow[i][j]>max) {
								 jposmax = j;
								 max = u_shadow[i][j];
							 }
						 }
						 */


						 // считаем что максимум потенциала достигается в центре дельта слоя.
						 for (int j = 0; j < N + 2; j++) {
							 if (yf[j] >= 0.5*(ystartdelta + yenddelta)) {
								 u[i][j] = u_shadow[i][j];
							 }
							 if (yf[j] < ystartdelta) {
								 u[i][j] = u_shadow[i][j] - dXe; // опускаем на разницу потенциалов вызванную разницей сродства электронов на границе.
							 }
							 // Нам нужна функция на нижней границе дельта слоя уменьшающая потенциал на dXe вольт,
							 // и не меняющая его и его производную в середине дельта слоя.
							 Real r = 1.005*(yenddelta - ystartdelta);
							 Real a = (ystartdelta);
							 if ((yf[j] >= ystartdelta) && (yf[j] < 0.5*(ystartdelta + yenddelta))) {
								 u[i][j] = u_shadow[i][j] -dXe*2.718281828*exp(-r*r / (r*r - (yf[j] - a)*(yf[j] - a)));
							 }
						 }
					 }
				 }
		
			 }
			 else
			 {
				 /*
				 // Сделано неактивно 31 июля 2014 года в связи с тем что диэлектрическая проницаемость в AlGaNGaN транзисторе стала зависить от пространственных координат. 

				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            */

			 }
            // exporttecplot(u,xf,yf,M,N);
	
			

	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			  if (0) {
	             // Найдём компоненты скорости не ограниченной сверху они соноправлены градиету потенциала :
	             calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			     for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
					     // Напряжённости же поля противоположны градиенту потенциала.
					     ex[i][j]=-x_vel[i][j];
					     ey[i][j]=-y_vel[i][j];
					     emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				     }
			     }
			 }
			

	         // Применение реальной полескоростной характеристики Нитрида Галлия :
			
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   Real velocity_magnitude=Field_velocity_magAlGaNGaN(vel_mag[i][j],mu_GaN[i][j],Tamb);
					   if (vel_mag[i][j]>1.0e-30) {
	                       x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
						   if (sizeof(Real)==8) {
						      vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					       }
			                if (sizeof(Real)==4) {
						      vel_mag[i][j]=sqrtf(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					       }
					   }
					   else {
						   x_vel[i][j]=0.0;
						   y_vel[i][j]=0.0;
						   vel_mag[i][j]=0.0;
					   }
		          }
	           }
			 }

			

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			 // аппроксимация Крёмера.
			 if (inumcore==1) {

				 /* Код нахождения производных верен.
				 // проверка сделана 25 сент 2014.
				 printf("test differentials\n");
				 for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
					  u[i][j]=xf[i];
				  }
				 }

			    // Vx
			    universalgradx(u, x_vel_face_we, xf, M, N);
				exporttecplot(x_vel_face_we,xf,yf,M-1,N);
				printf("gradx finish 1.0");

				universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
				exporttecplot(x_vel_face_sn,xf, yf, M, N-1);
				printf("gradx finish 1.0");

				for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
					  u[i][j]=yf[j];
				  }
				}
				universalgrady(u, y_vel_face_sn, yf, M, N);
				exporttecplot(y_vel_face_sn, xf, yf, M, N-1);
				printf("grady finish 1.0");

				universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
				exporttecplot(y_vel_face_we,xf, yf, M-1, N);
				printf("grady finish 1.0");

				printf("finish 1.0");
				*/

				// Эти функции проверены и оказались верными.
				universalgradx(u, x_vel_face_we, xf, M, N);
				//exporttecplot(x_vel_face_we,xf,yf,M-1,N);
			    universalgrady(u, y_vel_face_sn, yf, M, N);
			    // Vy
			    universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			    universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
				
			 }
			 if (inumcore>1) {
#pragma omp parallel shared(u,x_vel_face_we,y_vel_face_sn,y_vel_face_we,x_vel_face_sn,xf,yf,M,N)
				 {
#pragma omp sections
					 {
#pragma omp section
						 {
                             universalgradx(u, x_vel_face_we, xf, M, N);
						 }
#pragma omp section
						 {
							 universalgrady(u, y_vel_face_sn, yf, M, N);
						 }
					 }
				 }
				 #pragma omp parallel shared(u,x_vel_face_we,y_vel_face_sn,y_vel_face_we,x_vel_face_sn,xf,yf,M,N)
				 {
#pragma omp sections
					 {
#pragma omp section
						 {
							 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
						 }
#pragma omp section
						 {
							 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
						 }
					 }
				 }
			 }
			
			 /*
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc;
					 if (sizeof(Real)==8) {
					     velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 }
					 if (sizeof(Real)==4) {
					     velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 }
					 Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					 if (velmag_loc>1.0e-30) {
					    x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }*/
			 //Vx
			 /*
			 if (sizeof(Real)==8) {
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					 if (velmag_loc>1.0e-30) {
					    x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
			 }*/
			 /*
			 if (sizeof(Real)==4) {
#pragma omp parallel shared(x_vel_face_we,y_vel_face_we,mu_GaN) private(Tamb)
				 {
#pragma omp for
			    for (int i=0; i<M+1; i++) {
	    	        for (int j=0; j<N+2; j++) {
					    Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					    if (velmag_loc>1.0e-30) {
					        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					    }
					    else {
					    	 x_vel_face_we[i][j]=0.0;
					    }
		            }
	            }
				 }
			 }*/
			 /*
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc;
					 if (sizeof(Real)==8) {
					     velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 }
					 if (sizeof(Real)==4) {
					     velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 }
					 Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						  y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }
			 *//*
			 // Vy
			 if (sizeof(Real)==8) {

			    for (int i=0; i<M+2; i++) {
	    	        for (int j=0; j<N+1; j++) {
				    	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					     Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					     if (velmag_loc>1.0e-30) {
					        y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					     }
					     else {
						     y_vel_face_sn[i][j]=0.0;
					     }
		            }
	            }
			 }*/
			 /*
			  if (sizeof(Real)==4) {

#pragma omp parallel shared(x_vel_face_sn,y_vel_face_sn,mu_GaN) private(Tamb)
				 {

#pragma omp for
			    for (int i=0; i<M+2; i++) {
	    	        for (int j=0; j<N+1; j++) {
				    	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					     Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					     if (velmag_loc>1.0e-30) {
					        y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					     }
					     else {
						     y_vel_face_sn[i][j]=0.0;
					     }
		            }
	            }
				 }
			 }*/

			  if (inumcore==1) {
				  
#if MY_FLOAT
				  // float
   // Vx
				
			        for (int i=0; i<M+1; i++) {
	    	            for (int j=0; j<N+2; j++) {
					        Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
							//u[i][j]=velmag_loc; //debug
					       
					        if (velmag_loc>1.0e-30f) {
								Real velocity_magnitude=0.0;
								if (1) {
									if (velmag_loc > 1.0e6) {
										velmag_loc=1.8e7 / ((1.0 - 0.15) + 0.15*(Tamb / 300.0));
									}
									else {
										//velocity_magnitude = 0.5*(hash_table_loc[i][j][hashAlGaNGaN(fabs(velmag_loc))] + hash_table_loc[i+1][j][hash(velmag_loc)]);
										velocity_magnitude = hash_table_loc_x[i][j][hashAlGaNGaN(fabs(velmag_loc))];
									}
								}
								else {
									velocity_magnitude = Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j] + mu_GaN[i + 1][j]), Tamb);
								}
							   
					           x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					        }
					        else {
					    	   x_vel_face_we[i][j]=0.0f;
					        }
		                }
	                }

					//exporttecplot(u,xf,yf,M-1,N);

					// Vy
					 for (int i=0; i<M+2; i++) {
	    	        for (int j=0; j<N+1; j++) {
				    	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					     //u[i][j]=velmag_loc; // debug
					     
					     if (velmag_loc>1.0e-30f) {
							 Real velocity_magnitude = 0.0;
							 if (1) {
								 if (velmag_loc > 1.0e6) {
									 velmag_loc = 1.8e7 / ((1.0 - 0.15) + 0.15*(Tamb / 300.0));
								 }
								 else {
									 // velocity_magnitude = 0.5*(hash_table_loc[i][j][hashAlGaNGaN(fabs(velmag_loc))] + hash_table_loc[i][j+1][hash(velmag_loc)]);
									 velocity_magnitude = hash_table_loc_y[i][j][hashAlGaNGaN(fabs(velmag_loc))];
								 }
							 }
							 else {
								 velocity_magnitude = Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j] + mu_GaN[i][j + 1]), Tamb);
							 }
							 y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					     }
					     else {
						     y_vel_face_sn[i][j]=0.0f;
					     }
		            }
	            }

               // exporttecplot(u,xf,yf,M,N-1);

#else
				  // double
                    // Vx



			          for (int i=0; i<M+1; i++) {
	    	              for (int j=0; j<N+2; j++) {
				           	 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
				         	
					         if (velmag_loc>1.0e-30) {
								Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					            x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					         }
					         else {
						        x_vel_face_we[i][j]=0.0;
					         }
		              }
	               }

					// Vy
					for (int i=0; i<M+2; i++) {
	    	           for (int j=0; j<N+1; j++) {
				    	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					     
					     if (velmag_loc>1.0e-30) {
							Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					        y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					     }
					     else {
						     y_vel_face_sn[i][j]=0.0;
					     }
		            }
	            }
#endif
	 
			  }

			 if( inumcore==2) {

#if MY_FLOAT
 // float
#pragma omp parallel shared(x_vel_face_we,y_vel_face_we, x_vel_face_sn,y_vel_face_sn,mu_GaN,Tamb) 
				  {
#pragma omp sections
					  {
#pragma omp section
						  {
							   for (int i=0; i<M+1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							  for (int i=0; i<M+2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
					  }
				  }
#else
// double
#pragma omp parallel shared(x_vel_face_we,y_vel_face_we, x_vel_face_sn,y_vel_face_sn,mu_GaN,Tamb)
				  {
#pragma omp sections
					  {
#pragma omp section
						  {
							   for (int i=0; i<M+1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							  for (int i=0; i<M+2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
					  }
				  }
#endif


			  

			 }

			  if (inumcore==4) {
				  int iM2=(int)((M+2)/2); // пополам !!!

#if MY_FLOAT
// float
#pragma omp parallel shared(x_vel_face_we,y_vel_face_we, x_vel_face_sn,y_vel_face_sn,mu_GaN,Tamb)
				  {
#pragma omp sections
					  {
#pragma omp section
						  {
							   for (int i=0; i<iM2; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=iM2+1; i<M+1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							  for (int i=0; i<iM2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=iM2+1; i<M+2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
					  }
				  }

				  #pragma omp parallel shared(x_vel_face_we,y_vel_face_we, x_vel_face_sn,y_vel_face_sn,mu_GaN,Tamb) 
				  {
#pragma omp sections
					  {
#pragma omp section
						  {
				   for (int i=iM2; i<iM2+1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
						  #pragma omp section
						  {
				   for (int i=iM2; i<iM2+1; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
					  }
				  }

#else
 // double
				    int iM2=(int)((M+2)/2); // пополам !!!
#pragma omp parallel shared(x_vel_face_we,y_vel_face_we, x_vel_face_sn,y_vel_face_sn,mu_GaN,Tamb) 
				  {
#pragma omp sections
					  {
#pragma omp section
						  {
							   for (int i=0; i<iM2; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=iM2; i<M+1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							  for (int i=0; i<iM2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=iM2; i<M+2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
					  }
				  }

 #pragma omp parallel shared(x_vel_face_we,y_vel_face_we, x_vel_face_sn,y_vel_face_sn,mu_GaN,Tamb)
				  {
#pragma omp sections
					  {
#pragma omp section
						  {
				   for (int i=iM2; i<iM2+1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
						  #pragma omp section
						  {
				   for (int i=iM2; i<iM2+1; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
					  }
				  }

			  
#endif
				  
			 }


			  if (inumcore==8) {
				  

#if MY_FLOAT

int iM2=(int)((M+2)/2); // пополам !!!
int iM4=(int)(iM2/2);
int iM5=iM2+iM4;
				   // float
#pragma omp parallel shared(x_vel_face_we,y_vel_face_we, x_vel_face_sn,y_vel_face_sn,mu_GaN, Tamb) 
				  {
#pragma omp sections
					  {
#pragma omp section
						  {
							   for (int i=0; i<iM4; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=iM4; i<iM2; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=iM2; i<iM5; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=iM5; i<M+1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							  for (int i=0; i<iM4; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=iM4; i<iM2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=iM2; i<iM5; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=iM5; i<M+2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
					  }
				  }
#else
// double
int iM2=(int)((M+2)/2); // пополам !!!
int iM4=(int)(iM2/2);
int iM5=iM2+iM4;

#pragma omp parallel shared(x_vel_face_we,y_vel_face_we, x_vel_face_sn,y_vel_face_sn,mu_GaN,Tamb) 
				  {
#pragma omp sections
					  {
#pragma omp section
						  {
							   for (int i=0; i<iM4; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=iM4; i<iM2; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=iM2; i<iM5; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=iM5; i<M+1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							  for (int i=0; i<iM4; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=iM4; i<iM2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=iM2; i<iM5; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=iM5; i<M+2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
					  }
				  }
			  

#endif


}  // 8 core

 


if (inumcore==12) {

#if MY_FLOAT
	 // float
				  int im1=(int)((M+2)/3);
				  int im2=2*im1;
				  int im3=(int)(im1/2);
				  int im4=im1+im3;
				  int im5=im2+im3;

#pragma omp parallel shared(x_vel_face_we,y_vel_face_we, x_vel_face_sn,y_vel_face_sn,mu_GaN,Tamb) 
				  {
#pragma omp sections
					  {
#pragma omp section
						  {
							   for (int i=0; i<im3; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=im3; i<im1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=im1; i<im4; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=im4; i<im2; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=im2; i<im5; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=im5; i<M+1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrtf(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30f) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0f;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							  for (int i=0; i<im3; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=im3; i<im1; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=im1; i<im4; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=im4; i<im2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=im2; i<im5; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=im5; i<M+2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrtf(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30f) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5f*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0f;
					                 }
		                          }
	                          }
						  }
					  }
				  }
#else

 // double
				   int im1=(int)((M+2)/3);
				  int im2=2*im1;
				  int im3=(int)(im1/2);
				  int im4=im1+im3;
				  int im5=im2+im3;

#pragma omp parallel shared(x_vel_face_we,y_vel_face_we, x_vel_face_sn,y_vel_face_sn,mu_GaN,Tamb) 
				  {
#pragma omp sections
					  {
#pragma omp section
						  {
							   for (int i=0; i<im3; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=im3; i<im1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=im1; i<im4; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=im4; i<im2; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=im2; i<im5; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							   for (int i=im5; i<M+1; i++) {
	    	                       for (int j=0; j<N+2; j++) {
					                   Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					   
					                   if (velmag_loc>1.0e-30) {
						                    Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i+1][j]),Tamb);
					                        x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					                   }
					                   else {
					    	                x_vel_face_we[i][j]=0.0;
					                   }
		                           }
	                           }
						  }
#pragma omp section
						  {
							  for (int i=0; i<im3; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=im3; i<im1; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=im1; i<im4; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=im4; i<im2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=im2; i<im5; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
#pragma omp section
						  {
							  for (int i=im5; i<M+2; i++) {
	    	                      for (int j=0; j<N+1; j++) {
				                 	 Real  velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					                 if (velmag_loc>1.0e-30) {
							             Real velocity_magnitude=Field_velocity_magAlGaNGaN(velmag_loc, 0.5*(mu_GaN[i][j]+mu_GaN[i][j+1]),Tamb);
					                     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					                 }
					                 else {
						                 y_vel_face_sn[i][j]=0.0;
					                 }
		                          }
	                          }
						  }
					  }
				  }
#endif

			  

			   
			 } //12 core



			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn[i][j]*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn[i][j]*ny[i][j]-n[i][j]*y_vel[i][j];
					 #if MY_FLOAT
					 curent_mag[i][j]=sqrtf(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
#else
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
#endif
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			//load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn, rthdsdn, M, N); 
			 load_my_bound_n2AlGaNGaN(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Ndprofile, xf, yf, K300Dn, rthdsdn, M, N);

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			//constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);	
			 //constrAPatankarMESFET2AlGaNGaN(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);
			  //constrAPatankarMESFET2AlGaNGaNP(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N,inumcore);
			 constrAPatankarMESFET2AlGaNGaNP(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N,8);

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

#if MY_FLOAT
             for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0f;
			     	 rthdsd_internaln[i][j]=0.0f;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0f*0.25f*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0f*0.25f*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0f-alpha)*n_oldi[i][j];
		         }
		     }
#else
			 for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
#endif

		     
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
#if MY_FLOAT
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0f-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0f-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0f-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0f-alpha)*n_oldi[i][N+1];
			     }
		     }
#else
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
#endif

			 
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

			 if (buse_amg1r5) {
				 //amg_loc_memory(n, rthdsdn, An, M, N, 1, dX0);
				 amg_global_memory(n, rthdsdn, An, M, N, 1, dX0);
			 }
			 else {


				 //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
				 for (int i = 0; i < iendn; i++) {
					 //Seidel(n, rthdsdn, An, M, N);
					//-->/SeidelP(n, rthdsdn, An, M, N, 4);
					//SeidelP(n, rthdsdn, An, M, N, inumcore);
					//Real drf=1.0f;
					 //   SORDirichlet_test(n, rthdsdn, An, drf, M, N);
					 // Только метод Якоби может выполняться массово и параллельно :
					 Jacobi_parallel(n, jacobi, rthdsdn, An, M, N);
				 }
			 }

		    // Переход к следующей итерации.
			 /*
			 if (iter<11) {
				 printf("\b%d",iter);
			 }
			 else {
				 printf("\b\b%d",iter);
			 }
			 */
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/

		

#if MY_FLOAT
		Real idrain_loc=0.0f; // ток стока
    	Real isource_loc=0.0f; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn[i][N+1]*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5f*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5f*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5f*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn[i][N+1]*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5f*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5f*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5f*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14f) {
		if (fabs(isource_loc+idrain_loc)/(0.5f*(fabs(isource_loc)+fabs(idrain_loc))) <0.005f) {
			// досрочное прекращение вычислений
			if (fabs(isource_loc + idrain_loc) < 0.1) {
				inumbertimestep = imaxnumbertimestep + 1;
				break;
			}
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}
#else
		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn[i][N+1]*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn[i][N+1]*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			if (fabs(isource_loc + idrain_loc) < 0.1) {
				inumbertimestep = imaxnumbertimestep + 1;
				break;
			}
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}
#endif

		

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b\b\b\b");		   
		}
		printf("\b\b\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b\b\b");
		printf("\b\b\b\b\b\b\b\b\b\b\b\b");
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.

#if MY_FLOAT
		printf("%d%% %f %1.4e %1.4f  %e %e",compleate,fabs(isource_loc+idrain_loc)/(0.5f*(fabs(isource_loc)+fabs(idrain_loc))),0.1f*elementary_q*isource_loc, dtimestep / tauM, en, en/en_1);
#else
        printf("%d%% %f %1.4e %1.4f %e %e",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))),0.1*elementary_q*isource_loc, dtimestep/tauM, en, en/en_1);
#endif
		

	} // конец шагов по времени.




	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	if (fpreport_delta != NULL) {
		fprintf_s(fpreport_delta, " %1d:%2d:%3d \n", im, is, ims);
	}

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);

#if MY_FLOAT
	Real idrain_loc=0.0f; // ток стока
    Real isource_loc=0.0f; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1f*(K300Dn[i][N+1]*y_diffn_face_sn[i][N]-0.5f*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5f*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1f*(K300Dn[i][N+1]*y_diffn_face_sn[i][N]-0.5f*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5f*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5f*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14f) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5f*(fabs(isource_loc)+fabs(idrain_loc))));
			if (fpreport_delta != NULL) {
				fprintf_s(fpreport_delta, "tolerance=%f\n", fabs(isource_loc + idrain_loc) / (0.5f*(fabs(isource_loc) + fabs(idrain_loc))));
			}
		}
		else {
			printf("zero current");
			if (fpreport_delta != NULL) {
				fprintf_s(fpreport_delta, "zero current");
			}
		}
#else
	Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn[i][N+1]*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn[i][N+1]*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
#endif

    
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

	 
	calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
#if MY_FLOAT
	for (int i=0; i<M+2; i++) {
	     for (int j=0; j<N+2; j++) {
		      vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		      Real velocity_magnitude=Field_velocity_magAlGaNGaN(vel_mag[i][j],mu_GaN[i][j],Tamb);
			   if (vel_mag[i][j]>1.0e-30f) {
				    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
               }
			   else {
				   x_vel[i][j]=0.0f;
				   y_vel[i][j]=0.0f;
				   vel_mag[i][j]=0.0f;
				}
	         
		 }
	}	 
#else
	for (int i=0; i<M+2; i++) {
	     for (int j=0; j<N+2; j++) {
		      vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		      Real velocity_magnitude=Field_velocity_magAlGaNGaN(vel_mag[i][j],mu_GaN[i][j],Tamb);
			   if (vel_mag[i][j]>1.0e-30) {
				    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
               }
			   else {
				   x_vel[i][j]=0.0;
				   y_vel[i][j]=0.0;
				   vel_mag[i][j]=0.0;
				}
	         
		 }
	}	 
#endif
	
	


	  

	if (1) {
			  // найдём токи Сверено с Федотовым стр. 648.
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn[i][j]*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn[i][j]*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					  // напряжённость электрического поля направлена в сторону противоположную 
					 // градиенту электрического потенциала.
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		
	   Real rgold_gate = 0.5*(xstartgate + xendgate);
	   int igold_gate = -1;
	   Real rmin_gatecenterpos = 1.0e30;
	   for (int i = 1; i < M + 1; i++) {
		   if (fabs(xf[i] - rgold_gate) < rmin_gatecenterpos) {
			   rmin_gatecenterpos = fabs(xf[i] - rgold_gate);
			   igold_gate = i;
		   }
	   }
	   FILE *fp_gate_info;
	   errno_t err1_gate_info;
	   //if ((err1_input = fopen_s(&fp_input, "./v1/input.txt", "r")) != 0) {
	   if ((err1_gate_info = fopen_s(&fp_gate_info, "gate_info.txt", "w")) != 0) {
		   printf("Not Found and open file gate_info.txt\n");
		   // Vd and Vg останутся заданными как выше.
		   getchar();
		   exit(1);
	   }
	   else {
		   fprintf_s(fp_gate_info, "y u ex ey emag n\n");
		   for (int j = 0; j < N + 2; j++) {
			   fprintf_s(fp_gate_info, "%e %e %e %e %e %e\n", yf[j], u[igold_gate][j],ex[igold_gate][j],ey[igold_gate][j],emag[igold_gate][j],n[igold_gate][j]);
		   }
		   fclose(fp_gate_info);
	   }


    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

#if MY_FLOAT
	Real idrain=0.0f; // ток стока
	Real isource=0.0f; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5f*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5f*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1f; // на мм ширины затвора А/мм
	idrain*=0.1f; // на мм ширины затвора А/мм
#else
	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм
#endif

	

	
	if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		printf("Not Found and open file task.txt\n");
		// данные записаны не будут
	}
	else {
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		fclose(fp);

		if (fpreport_delta != NULL) {
			fprintf_s(fpreport_delta, "source=%e\n",isource);
			fprintf_s(fpreport_delta, "drain=%e\n", idrain);
		}
		
	}
	
	// Освобождение оперативной памяти.
	my_free_universal(rthdsd_internal, M, N);
	my_free_universal(rthdsd, M, N);
	my_free_universal(r, M, N);
	my_free_universal(jacobi, M, N);
	my_free_universal(u_old, M, N);
	my_free_universal(u, M, N);
	my_free_universal(u_shadow, M, N);
	my_free_universal(rthdsd_internaln, M, N);
	my_free_universal(rthdsdn, M, N);
	my_free_universal(rn, M, N);
	my_free_universal(n_oldi, M, N);
	my_free_universal(n, M, N);
	my_free_universal(n_old, M, N);
	my_free_universal(n_buf, M, N);
	my_free_universal(Ndprofile, M, N);
	my_free_universal(K300, M, N);
	my_free_universal(mu_GaN, M, N);
	my_free_universal(K300Dn, M, N);
	my_free_universal(x_vel, M, N);
	my_free_universal(y_vel, M, N);
	my_free_universal(x_vel_face_we, M-1, N);
	my_free_universal(y_vel_face_we, M-1, N);
    my_free_universal(x_vel_face_sn, M, N-1);
	my_free_universal(y_vel_face_sn, M, N-1);
	my_free_universal(vel_mag, M, N);
	my_free_universal(ex, M, N);
	my_free_universal(ey, M, N);
	my_free_universal(nx, M, N);
	my_free_universal(ny, M, N);
	my_free_universal(emag, M, N);
	my_free_universal(curent_x, M, N);
	my_free_universal(curent_y, M, N);
	my_free_universal(curent_mag, M, N);

	
	
	
	for (int i = 0; i < M + 1; i++) {
		for (int j = 0; j < N + 2; j++) {
			delete[] hash_table_loc_x[i][j];
			hash_table_loc_x[i][j] = NULL;
		}
	}
	for (int i = 0; i < M + 1; i++) {
		delete[] hash_table_loc_x[i];
		hash_table_loc_x[i] = NULL;
	}
	delete[] hash_table_loc_x;
	hash_table_loc_x = NULL;

	for (int i = 0; i < M + 2; i++) {
		for (int j = 0; j < N + 1; j++) {
			delete[] hash_table_loc_y[i][j];
			hash_table_loc_y[i][j] = NULL;
		}
	}
	for (int i = 0; i < M + 2; i++) {
		delete[] hash_table_loc_y[i];
		hash_table_loc_y[i] = NULL;
	}
	delete[] hash_table_loc_y;
	hash_table_loc_y = NULL;



	// Внутренние переменные алгебраического многосеточного метода.
	delete[] dX0;
	dX0 = NULL;

	if (amgGM.a != NULL) {
		delete[] amgGM.a;
	}
	if (amgGM.f != NULL) {
		delete[] amgGM.f;
	}
	if (amgGM.ia != NULL) {
		delete[] amgGM.ia;
	}
	if (amgGM.ig != NULL) {
		delete[] amgGM.ig;
	}
	if (amgGM.ja != NULL) {
		delete[] amgGM.ja;
	}
	if (amgGM.u != NULL) {
		delete[] amgGM.u;
	}

	bfirst_use_amgGM = true;




   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();
	if (fpreport_delta != NULL) {
		fprintf_s(fpreport_delta, "calculation complete...\n");
		fprintf_s(fpreport_delta, "please, press any key to continue...\n");
	}

	fclose(fpreport_delta);

} // startMESFETAlGaNGaN

// обкладка типа А 
// см. стр 257 Р.Куэй.
typedef struct TpleteA {
	// 8 параметров.
	Real Vo; // напряжение на обкладке
	Real hM; // высота металлизаци затвора истока и стока.
	Real hz; // высота зазора между обкладкой и металлизацией затвора.
	Real a; // протяжённость металлизации над затвором вправо от начала затвора.
	Real h0; // толщина металлизации обкладки.
	Real b; // протяжённость нижнего куска обкладки вправо.
	Real delta; // толщина металлизации перемычки между a и b.
	Real hdelta; // высота перемычки между a и b
} plateA;

//******************** наработки из  Alice Flow v0.02 *************************** 
// Метод Гаусса Зейделя Ричардсона Либмана для произвольной четырёхугольной сетки. 
// Файл Seidel_flattener.cpp из AliceFlow v0.02 содержит сглаживатель Гаусса-Зейделя Ричардсона Либмана.
// begin 27 мая 2012 года.

typedef struct TONE_MATRIX_STRING {
	// все элементы неотрицательные.
	Real ap; // диагональный элемент
	int irow; // номер строки
	int isize; // количество внедиагональных элементов.
	Real* anb; // внедиагональные элементы
	int* icol; // номер столбца внедиагонального элемента.
} ONE_MATRIX_STRING;

// ONE_MATRIX_STRING* seidel_matrix;

 // Инициализация матрицы для сглаживателя.
 void init_Seidel_matrix(ONE_MATRIX_STRING* &SM, int nodes) {
	 SM=new ONE_MATRIX_STRING[nodes];
	 for (int i=0; i<nodes; i++) {
		 SM[i].anb=NULL;
		 SM[i].ap=0.0;
		 SM[i].icol=NULL;
		 SM[i].irow=i;
		 SM[i].isize=0;
	 }
 } // init_Seidel_matrix

 // Добавление Элемента в матрицу сглаживателя.
 void add_value_Seidel_matrix(ONE_MATRIX_STRING* &SM, int irow, int icol, Real value, bool bset) {
	 // Если bset==true то мы просто присваиваем иначе просто добавляем.
	 if (irow==icol) {
		 // диагональный элемент.
		 if (bset)  {
			 SM[irow].ap=fabs(value);
		 }
		 else {
			 SM[irow].ap+=fabs(value);
		 }
	 }
	 else {
		 if (SM[irow].isize==0) {
			 SM[irow].anb=new Real[1];
			 SM[irow].icol=new int[1];
			 SM[irow].anb[0]=fabs(value);
			 SM[irow].icol[0]=icol;
			 SM[irow].isize++;
		 }
		 else {

			 // Если нужно просто добавить к существующему элементу:
			 bool badditional=false; // false это новый элемент добавлять не надо.
			 for (int i=0; i<SM[irow].isize; i++) {
				 if (SM[irow].icol[i]==icol) {
                     badditional=true;
					 if (bset) {
						 SM[irow].anb[i]=fabs(value);
					 }
					 else {
						 SM[irow].anb[i]+=fabs(value);
					 }
				 }
			 }

			 if (badditional==false) {
				 // Это действительно новый элемент.
				 Real* rbuf=new Real[SM[irow].isize];
			     int* ibuf=new int[SM[irow].isize];
			     for (int i=0; i<SM[irow].isize; i++) {
				      rbuf[i]=SM[irow].anb[i];
				      ibuf[i]=SM[irow].icol[i];
			     }
			     delete SM[irow].anb;
			     delete SM[irow].icol;
			     SM[irow].anb=new Real[SM[irow].isize+1];
			     SM[irow].icol=new int[SM[irow].isize+1];
			     for (int i=0; i<SM[irow].isize; i++) {
				     SM[irow].anb[i]=rbuf[i];
				     SM[irow].icol[i]=ibuf[i];
			     }
			     SM[irow].anb[SM[irow].isize]=fabs(value);
			     SM[irow].icol[SM[irow].isize]=icol;
			     SM[irow].isize++;
			     delete rbuf;
			     delete ibuf;
			 }
		 }

	 }
 } // add_value_Seidel_matrix 

 // Освобождение памяти из под матрицы Зейделя.
 void free_Seidel_matrix(ONE_MATRIX_STRING* &SM, int nodes) {
	 for (int i=0; i<nodes; i++) {
		 if (SM[i].anb!=NULL) delete SM[i].anb;
		 if (SM[i].icol!=NULL) delete SM[i].icol;
		 SM[i].isize=0;
	 }
	 delete SM;
 } // free_Seidel_matrix

 
 void set_zero_Seidel_matrix(ONE_MATRIX_STRING* &SM, int nodes) {
	 for (int i=0; i<nodes; i++) {
		 SM[i].ap=0.0;
		 for (int i1=0; i1<SM[i].isize; i1++) {
			 SM[i].anb[i1]=0.0;
		 }		 
	 }
  }

 // Невязка и одна итерация метода Гаусса Зейделя составляют основу метода Федоренко, но это только
 // необходимое но недостаточное условие.

 // Несколько итераций метода Гаусса-Зейделя даже с учётом АЛИС !!!.
 void solve_puas(ONE_MATRIX_STRING* &SM, 
	             int nodes, Real* rthdsd,
				 Real** potent,  Real omega)
 {
	 //int irepeat=1; // количество итераций метода Зейделя. (значение предполагается малым не более 5).
	 //Real omega=1.0; // параметр релаксации
	 

	
		 for (int j=0; j<nodes; j++) {
			 Real rsum=0.0;
			 for (int k=0; k<SM[j].isize; k++) {
				 rsum+=SM[j].anb[k]*potent[0][SM[j].icol[k]];
			 }
			 // Знак именно плюс перед rsum так все элемнты в матрице Зейделя заранее предусмотрительно сделаны неотрицательными.
			 potent[0][j]=omega*(rthdsd[j]+rsum)/SM[j].ap+(1.0-omega)*potent[0][j];
		 }
	 

 } // solve_puas 

 // Невязка на основе метода Гаусса-Зейделя уже с учётом АЛИС !!!.
 void nevjazka(ONE_MATRIX_STRING* &SM, 
	             int nodes, Real* rthdsd,
				 Real* potent, Real* &residual,
				 Real &res_style_Fluent)
 {
	 // residual - вектор текущей невязки.

	 if (residual==NULL) {
		 // В случае если память ещё не выделена то выделяем память.
		 residual=new Real[nodes];
	 }
	 for (int i=0; i<nodes; i++) {
		 residual[i]=0.0; // обнуление.
	 }

	 Real diagsum=0.0; // для невязки в стиле Fluent
	 res_style_Fluent=0.0; // невязка в стиле Fluent

	 for (int j=0; j<nodes; j++) {
		 Real rsum=0.0;
		 for (int k=0; k<SM[j].isize; k++) {
			 rsum+=SM[j].anb[k]*potent[SM[j].icol[k]];
		 }
		 diagsum+=fabs(SM[j].ap*potent[j]);
		 // Знак именно плюс перед rsum так все элемнты в матрице Зейделя заранее предусмотрительно сделаны неотрицательными.
		 //residual[j]= fabs(rsum +  rthdsd[j] - SM[j].ap*potent[j]); // невязка .
		 residual[j]=  SM[j].ap*potent[j] - rsum -  rthdsd[j]; // невязка (согласно работе Федоренко).
		 // невязка показывает на сколько точно выполняются уравнения СЛАУ при подстановке в них текущего приближения.
         res_style_Fluent+=fabs(residual[j]);
	 }

     res_style_Fluent/=diagsum; // нормированное значение.


 } // nevjazka 


// Расстояние между двумя точками на плоскости.
Real rdistance2point(Real x1, Real y1, Real x2, Real y2) {
	Real r=0.0;
	r=sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)); // длина отрезка.
	return r;
} // rdistance2point

// угол между двумя векторами выходящими из начала координат
Real angle2vector0(Real x1, Real y1, Real x2, Real y2) {
	Real scal=x1*x2+y1*y2; // скалярное произведение двух векторов выходящих из начала координат.
	Real d1=rdistance2point(0.0, 0.0, x1, y1); // длина вектора выходящего из начала координат.
	Real d2=rdistance2point(0.0, 0.0, x2, y2);

	Real r=0.0;

	r=acos(scal/(d1*d2));
	// возвращает угол в радианах между двумя векторами выходящими из начала координат.
	return r;
} // angle2vector0

// площадь выпуклого четырёхугольника.
Real rsquarerectangle(Real x1, Real y1, Real x2, Real y2, Real x3, Real y3, Real x4, Real y4) {
	// Внимание вершины должны быть упорядочены как в nvtx.

	Real xc, yc;
	xc=0.25*(x1+x2+x3+x4);
	yc=0.25*(y1+y2+y3+y4);

	// площади треугольников.
	Real s1, s2, s3, s4;

	// длины сторон треугольников.
	Real a1, b1, c1, p1;
	Real a2, b2, c2, p2;
	Real a3, b3, c3, p3;
	Real a4, b4, c4, p4;

	a1=rdistance2point(x1, y1, x2, y2);
	b1=rdistance2point(xc, yc, x2, y2);
	c1=rdistance2point(x1, y1, xc, yc);
	p1=0.5*(a1+b1+c1); // полупериметр
	s1=sqrt(p1*(p1-a1)*(p1-b1)*(p1-c1)); // площадь.

    a2=rdistance2point(x2, y2, x3, y3);
	b2=rdistance2point(xc, yc, x3, y3);
	c2=rdistance2point(x2, y2, xc, yc);
	p2=0.5*(a2+b2+c2);
	s2=sqrt(p2*(p2-a2)*(p2-b2)*(p2-c2));

	a3=rdistance2point(x3, y3, x4, y4);
	b3=rdistance2point(xc, yc, x4, y4);
	c3=rdistance2point(x3, y3, xc, yc);
	p3=0.5*(a3+b3+c3);
	s3=sqrt(p3*(p3-a3)*(p3-b3)*(p3-c3));

	a4=rdistance2point(x4, y4, x1, y1);
	b4=rdistance2point(xc, yc, x1, y1);
	c4=rdistance2point(x4, y4, xc, yc);
	p4=0.5*(a4+b4+c4);
	s4=sqrt(p4*(p4-a4)*(p4-b4)*(p4-c4));

	return (s1+s2+s3+s4);

} // rsquarerectangle

// находит каноническое уравнение прямой.
void line_equation(Real &A, Real &B, Real x1, Real x2, Real y1, Real y2) {
	Real epsilon=1e-30; // для определения вещественного нуля.

    if (fabs(x2-x1)>epsilon) {
        A=(y2-y1)/(x2-x1);
	    B=-1.0;  
	}
	else {
		A=-1.0;
		B=(x2-x1)/(y2-y1);
	}
} // line_equation

// находит полное каноническое уравнение прямой.
void full_line_equation(Real &A, Real &B, Real &C, Real x1, Real x2, Real y1, Real y2) {
	Real epsilon=1e-30; // для определения вещественного нуля.

    if (fabs(x2-x1)>epsilon) {
        A=(y2-y1)/(x2-x1);
	    B=-1.0;  
		C=y1-(y2-y1)*x1/(x2-x1);
	}
	else {
		A=-1.0;
		B=(x2-x1)/(y2-y1);
		C=x1-(x2-x1)*y1/(y2-y1);
	}
} // line_equation


// Функция A(|P|) 
// для различных схем:
// fabsPe - модуль числа Пекле.
// ishconvection - номер схемы:
// 1 - центрально-разностная схема,
// 2 - с разностями против потока,
// 3 - комбинированная,
// 4 - со степенным законом,
// 5 - экспоненциальная (точная),
// 6 - схема В.К. Булгакова (23) из статьи,
// 7 - показательная зависимость.
Real ApproxConvective(Real fabsPe, int ishconvection) {
	Real r=1; // по умолчанию с разностью против потока
	Real rCR, rpoly, rpoly2, rpoly5;
	if (ishconvection<6) {
 	   rCR=1.0-0.5*fabsPe;
	   rpoly=1.0-0.1*fabsPe;
	   rpoly2=rpoly*rpoly;
	   rpoly5=rpoly2*rpoly2*rpoly; // со степенным законом
	}

	switch (ishconvection) {
		case 1: // Центрально разностная схема пригодна только 
			    // для небольших чисел Пекле меньших по модулю 1.0.
			    if (fabsPe<1.0) r=rCR; 
				// поэтому при числах Пекле по модулю больших 1.0 но
				// меньших 10.0 осуществляется переход на рекомендуемую
				// Патанкаром схему со степенным законом.
			    if ((fabsPe>=1.0)&&(fabsPe<10.0)) r=rpoly5;
				else r=0.0; // при числах Пекле больших 10.0 аппроксимация нулём.
			    break;
		case 2: // с разностями против потока
			    if (fabsPe<1.0) r=1.0; else r=0.0;
			    break;
		case 3: // комбинированная
			    r=maxf(0.0, rCR);
			    break;
		case 4: // со степенным законом
			    if (fabsPe<10.0) r=rpoly5; else r=0.0;
			    break;
		case 5: // экспоненциальная (точная)
			    if (fabsPe<10.0) {
			    	if (fabsPe<0.01) r=rCR; else r=fabsPe/(exp(fabsPe)-1.0);
			    }
			    else r=0.0;
			    break;
		case 6: // В.К. Булгаков, Н.В. Булгаков
			    // Хабаровкий Государственный Технический Университет
			    // зависимость (23) из статьи.
			    r=1.0/(1.0+0.6712*fabsPe*fabsPe);
			    break;
		case 7: // показательная зависимость
			    r=pow(0.553,fabsPe);
			    break;
		default: r=1.0/(1.0+0.6712*fabsPe*fabsPe); break;
	}
	return r;
} // ApproxConvective


 // Здесь мы сделаем аппроксимацию первого порядка для уравнения конвекции-диффузии
// для произвольных четырёхугольных ячеек (скошенные, т.е. углы которых не прямые).
// Сборка локальных матриц размерности 4x4.
// Прямоугольный элемент.
// ie - номер элемента,
// btimedep - нестационарный (true), стационарный (false).
// Свойства материалов храняться в позициях отличных от центров контрольных объёмов,
// а конкретно храняться в центрах квадратных ячеек сетки (связи контрольных объёмов).
// Таким образом материалы храняться с учётом естественных границ расчётной области, что очень важно.
// Rho - коэффициент перед нестационарным членом, 
// Gam - коэффициент диффузии.
// ishconvection - схема аппроксимации конвективного члена.
// Sc, Sp - аппроксимация источникового члена, (их нужно приписывать к вершинам ячейки т.е. они должны хранится в тех же точках что и вектор potent).
// dtau - шаг по времени.
// iVar - переменная для которой составляется дискретный аналог.
void my_elmatr_quad(int ie, bool btimedep,
	                Real Rho, Real Gam,
					int ishconvection,
					Real Sc1, Real Sc2, Real Sc3, Real Sc4, Real Sp,
					Real dtau, 
					int nve, Real* x, Real* y,
					int **nvtx,  Real **potent,
					Real** &aelm, Real* &rloc) 
{

	//
	//   4---------3
	//   |         |
	//   |         | 
	//   1---------2
	//
	
	// Номера вершин упорядочены таким образом, что ели их последовательно соединять
	// то можно получить данный четырхугольник.
	// Запишем координаты вершин:
	Real x1=x[nvtx[0][ie]-1];
	Real x2=x[nvtx[1][ie]-1];
	Real x3=x[nvtx[2][ie]-1];
	Real x4=x[nvtx[3][ie]-1];
	Real y1=y[nvtx[0][ie]-1];
	Real y2=y[nvtx[1][ie]-1];
	Real y3=y[nvtx[2][ie]-1];
	Real y4=y[nvtx[3][ie]-1];

	
	// Коррдинаты середин отрезков.
	Real x12=0.5*(x1+x2);
	Real x23=0.5*(x2+x3);
	Real x34=0.5*(x3+x4);
	Real x41=0.5*(x4+x1);
	Real y12=0.5*(y1+y2);
	Real y23=0.5*(y2+y3);
	Real y34=0.5*(y3+y4);
	Real y41=0.5*(y4+y1);

	// Уравнения диагоналей.
	Real A1, B1, C1;
	full_line_equation(A1, B1, C1, x3, x1, y3, y1);
	Real A2, B2, C2;
    full_line_equation(A2, B2, C2, x2, x4, y2, y4);

	// точка пересечения диагоналей.
	Real xD=0.0;
	if (fabs((A1*B2-A2*B1))>1e-20) {
	   xD=-(C1*B2-C2*B1)/(A1*B2-A2*B1);
	}
	else {
		xD=0.25*(x1+x2+x3+x4);
	}
	Real yD=0.0;
	if (fabs(A1*B2-A2*B1)>1e-20) {
	   yD=-(A1*C2-A2*C1)/(A1*B2-A2*B1);
	}
	else {
		yD=0.25*(y1+y2+y3+y4);
	}

	
	

	// Мы имеем четыре четвертинки контрольных объёмов. 
	// Каждая четвертинка контрольного объёма образована 
	// четырёхугольником натянутым на точку пересечения диагоналей,
	// две смежные середины сторон и центр контрольного объёма (один из четырёх).
	Real Vol1=rsquarerectangle( x1, y1, x12, y12, xD, yD, x41, y41);
	Real Vol2=rsquarerectangle( x2, y2, x23, y23, xD, yD, x12, y12);
	Real Vol3=rsquarerectangle( x3, y3, x34, y34, xD, yD, x23, y23);
	Real Vol4=rsquarerectangle( x4, y4, x41, y41, xD, yD, x34, y34);


	// площади :
	Real S12=rdistance2point(x12, y12, xD, yD);
	Real S23=rdistance2point(x23, y23, xD, yD);
	Real S34=rdistance2point(x34, y34, xD, yD);
	Real S41=rdistance2point(x41, y41, xD, yD);

	Real lambdae=0.5; // грань контрольного объёма расположена по центру между узлами
	Real Vx12=(lambdae*potent[VX][nvtx[0][ie]-1]+(1-lambdae)*potent[VX][nvtx[1][ie]-1]);
	Real Vy12=(lambdae*potent[VY][nvtx[0][ie]-1]+(1-lambdae)*potent[VY][nvtx[1][ie]-1]);
	Real Vx23=(lambdae*potent[VX][nvtx[1][ie]-1]+(1-lambdae)*potent[VX][nvtx[2][ie]-1]);
	Real Vy23=(lambdae*potent[VY][nvtx[1][ie]-1]+(1-lambdae)*potent[VY][nvtx[2][ie]-1]);
	Real Vx34=(lambdae*potent[VX][nvtx[2][ie]-1]+(1-lambdae)*potent[VX][nvtx[3][ie]-1]);
	Real Vy34=(lambdae*potent[VY][nvtx[2][ie]-1]+(1-lambdae)*potent[VY][nvtx[3][ie]-1]);
	Real Vx41=(lambdae*potent[VX][nvtx[0][ie]-1]+(1-lambdae)*potent[VX][nvtx[3][ie]-1]);
	Real Vy41=(lambdae*potent[VY][nvtx[0][ie]-1]+(1-lambdae)*potent[VY][nvtx[3][ie]-1]);

	// Единичная нормаль
	// к границе контрольного объёма.
	Real A, B;
	Real alpha;

	line_equation(A, B, xD, x12, yD, y12);
	Real S12x=A/sqrt(A*A+B*B);
	Real S12y=B/sqrt(A*A+B*B);
	alpha=angle2vector0(1,1, S12x, S12y);
	if (!((alpha>-0.5*3.141)&&(alpha<0.5*3.141))) {
	   // угол тупой
	   S12x*=-1.0;
	   S12y*=-1.0;
	}

	line_equation(A, B, x23, xD, y23, yD);
	Real S23x=A/sqrt(A*A+B*B);
	Real S23y=B/sqrt(A*A+B*B);
	alpha=angle2vector0(1,1, S23x, S23y);
	if (!((alpha>-0.5*3.141)&&(alpha<0.5*3.141))) {
		// угол тупой
		S23x*=-1.0;
		S23y*=-1.0;
	}

	line_equation(A, B, x34, xD, y34, yD);
	Real S34x=A/sqrt(A*A+B*B);
	Real S34y=B/sqrt(A*A+B*B);
	alpha=angle2vector0(1,1, S34x, S34y);
	if (!((alpha>-0.5*3.141)&&(alpha<0.5*3.141))) {
		// угол тупой
		S34x*=-1.0;
		S34y*=-1.0;
	}

	line_equation(A, B, x41, xD, y41, yD);
	Real S41x=A/sqrt(A*A+B*B);
	Real S41y=B/sqrt(A*A+B*B);
	alpha=angle2vector0(1,1, S41x, S41y);
	if (!((alpha>-0.5*3.141)&&(alpha<0.5*3.141))) {
		// угол тупой
		S41x*=-1.0;
		S41y*=-1.0;
	}

	// длины :
	Real dr12=rdistance2point(x1, y1, x2, y2);
	Real dr23=rdistance2point(x2, y2, x3, y3);
	Real dr34=rdistance2point(x3, y3, x4, y4);
	Real dr41=rdistance2point(x4, y4, x1, y1);

	// Единичный касательный вектор :
	line_equation(A, B, x2, x1, y2, y1);
	Real nu12x=-B/sqrt(A*A+B*B);
	Real nu12y=A/sqrt(A*A+B*B);
	alpha=angle2vector0(1,1, nu12x, nu12y);
	if (!((alpha>-0.5*3.141)&&(alpha<0.5*3.141))) {
		// угол тупой
		nu12x*=-1.0;
		nu12y*=-1.0;
	}

	line_equation(A, B, x3, x2, y3, y2);
	Real nu23x=-B/sqrt(A*A+B*B);
	Real nu23y=A/sqrt(A*A+B*B);
	alpha=angle2vector0(1,1, nu23x, nu23y);
	if (!((alpha>-0.5*3.141)&&(alpha<0.5*3.141))) {
		// угол тупой
		nu23x*=-1.0;
		nu23y*=-1.0;
	}

	line_equation(A, B, x4, x3, y4, y3);
	Real nu34x=-B/sqrt(A*A+B*B);
	Real nu34y=A/sqrt(A*A+B*B);
	alpha=angle2vector0(1,1, nu34x, nu34y);
	if (!((alpha>-0.5*3.141)&&(alpha<0.5*3.141))) {
		// угол тупой
		nu34x*=-1.0;
		nu34y*=-1.0;
	}

	line_equation(A, B, x1, x4, y1, y4);
	Real nu41x=-B/sqrt(A*A+B*B);
	Real nu41y=A/sqrt(A*A+B*B);
	alpha=angle2vector0(1,1, nu41x, nu41y);
	if (!((alpha>-0.5*3.141)&&(alpha<0.5*3.141))) {
		// угол тупой
		nu41x*=-1.0;
		nu41y*=-1.0;
	}


    int l,m; // счётчики цикла for
	
    // Вычисление локальной матрицы элемента

    for (l=0; l<nve; l++) for (m=0; m<nve; m++) aelm[l][m]=0.0; // обнуление

	Real F12, F23, F34, F41; // интенсивность конвекции
	
	F12=Rho*S12*(Vx12*S12x + Vy12*S12y);
	F23=Rho*S23*(Vx23*S23x + Vy23*S23y);
	F34=Rho*S34*(Vx34*S34x + Vy34*S34y);
	F41=Rho*S41*(Vx41*S41x + Vy41*S41y);

	// коэффициент диффузии всегда положителен !!!
	Real D12, D23, D34, D41; // дифузионная проводимость
	D12=Gam*fabs(S12x*nu12x + S12y*nu12y)*S12/dr12;
	D23=Gam*fabs(S23x*nu23x + S23y*nu23y)*S23/dr23; 
    D34=Gam*fabs(S34x*nu34x + S34y*nu34y)*S34/dr34; 
	D41=Gam*fabs(S41x*nu41x + S41y*nu41y)*S41/dr41;

	Real Pe12, Pe23, Pe34, Pe41; // числа Пекле
	Pe12=F12/D12; Pe23=F23/D23; Pe34=F34/D34; Pe41=F41/D41;

	aelm[0][1]=-D12*ApproxConvective(fabs(Pe12),ishconvection)-maxf(-F12,0.0);
    aelm[0][3]=-D41*ApproxConvective(fabs(Pe41),ishconvection)-maxf(-F41,0.0);
	aelm[0][2]=0.0; 
	aelm[0][0]=-aelm[0][1]-aelm[0][3]-Sp*Vol1;
    if (btimedep) aelm[0][0]+=(Rho*Vol1)/(dtau);

    aelm[1][0]=-D12*ApproxConvective(fabs(Pe12),ishconvection)-maxf(F12,0.0);
    aelm[1][2]=-D23*ApproxConvective(fabs(Pe23),ishconvection)-maxf(-F23,0.0);
	aelm[1][3]=0.0; 
	aelm[1][1]=-aelm[1][0]-aelm[1][2]-Sp*Vol2;
    if (btimedep) aelm[1][1]+=(Rho*Vol2)/(dtau);

    aelm[2][1]=-D23*ApproxConvective(fabs(Pe23),ishconvection)-maxf(F23,0.0);
    aelm[2][3]=-D34*ApproxConvective(fabs(Pe34),ishconvection)-maxf(F34,0.0);
	aelm[2][0]=0.0; 
	aelm[2][2]=-aelm[2][1]-aelm[2][3]-Sp*Vol3;
    if (btimedep) aelm[2][2]+=(Rho*Vol3)/(dtau);

	aelm[3][0]=-D41*ApproxConvective(fabs(Pe41),ishconvection)-maxf(F41,0.0);
    aelm[3][2]=-D34*ApproxConvective(fabs(Pe34),ishconvection)-maxf(-F34,0.0);
	aelm[3][1]=0.0; 
	aelm[3][3]=-aelm[3][0]-aelm[3][2]-Sp*Vol4;
    if (btimedep) aelm[3][3]+=(Rho*Vol4)/(dtau);
	
	
	// Источниковый член.
    rloc[0]=Sc1*Vol1;
	rloc[1]=Sc2*Vol2;
	rloc[2]=Sc3*Vol3;
	rloc[3]=Sc4*Vol4;
	if (potent!=NULL) {
    if (btimedep) {
		rloc[0]+=(Rho*Vol1*potent[0][nvtx[0][ie]-1])/(dtau);
		rloc[1]+=(Rho*Vol2*potent[0][nvtx[1][ie]-1])/(dtau);
		rloc[2]+=(Rho*Vol3*potent[0][nvtx[2][ie]-1])/(dtau);
	    rloc[3]+=(Rho*Vol4*potent[0][nvtx[3][ie]-1])/(dtau);
	}
	}
	
} // my_elmatr_quad(ie);

// Включение одиночных матричных элементов (aelm, rloc)
// в глобальную матрицу сглаживателя Гаусса-Зейделя и 
// (если bsecond_member_of_equation=true) правую часть.
// Используются следующие данные: nve, nvtx, constr, potent,
// rthdsd, rloc, aelm.
// Нужно сделать так чтобы было как можно меньше данных с глобальной областью видимости.
void elembdSeidelMatrix(int ie, bool bsecond_member_of_equation,
	                     ONE_MATRIX_STRING* &SM, 
						int **nvtx, int nve, 
						Real **aelm, Real **potent, bool *constr,
						Real* &rthdsd, Real *rloc) {
	// перебор матричных элементов (aelm, rloc)
	// и корректировка глобальной матрицы SeidelMatrix (SM) и правой части

	int i,j; // счётчики цикла for
	int irow, icol; // строка, столбец
	for (i=0; i<nve; i++) {
		irow = nvtx[i][ie]-1;
	
		// Строка соответствует фиксированному потенциалу ?
		if (constr[irow]) { // да
			add_value_Seidel_matrix(SM, irow, irow, 1.0, true);
			if (bsecond_member_of_equation) rthdsd[irow]=potent[0][irow];
		}
		else { // нет
			// нет, потенциал переменный, просмотр nve-столбцов
			for (j=0; j<nve; j++) {
				icol=nvtx[j][ie]-1;
				// Столбец соответствует фиксированному потенциалу ?
				if (constr[icol]) { // да
					// Тогда увеличение только правой части
                    if (bsecond_member_of_equation) rthdsd[irow]+=rloc[i]-aelm[i][j]*potent[0][icol];
				}
				else { // нет
					// тогда увеличение глобальной матрицы SM и правой части
                    //add_value_Seidel_matrix(SM, irow, icol, fabs(aelm[i][j]));
					if (fabs(aelm[i][j])>1e-20) {
						// Мы будем добавлять лишь ненулевые элементы.
					   add_value_Seidel_matrix(SM, irow, icol, aelm[i][j], false);
					}
                    if (bsecond_member_of_equation) rthdsd[irow]+=rloc[i];
				}
			}			
		}
	}
} // elembdSeidelMatrix



 //******************** наработки из  Alice Flow v0.02 *************************** 

// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Нитрид Галлия.
// С обкладкой геометрии типа А.
void startMESFETGaN_obkladkaA() {

    
	// V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.

	// Параметры обкладки вида А.
	plateA pA; // cm
	pA.hM=0.1e-4;
	pA.Vo=-1.0; // V
	pA.hz=0.05e-4;
	pA.h0=0.05e-4;
	pA.a=1.2*(xendgate-xstartgate);
	pA.b=0.5e-4;
	pA.delta=pA.h0;
	pA.hdelta=0.0;

	// epsilon  SiO2  Si3N4
	//          3.9    7.5
	Real epsilon_dielectric=3.9;
	// Общеупотребительные константы:
	const Real epsilonGaN=9.5;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;

	
	
	FILE *fp;
	errno_t err1;
	/*
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}
	*/





	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	int Mglx=M+2+3;
	//Real* xf=new Real[M+2];
	Real* xf=new Real[Mglx];

	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	

	
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);

	Real distminf=1.0e30;
	for (int i=0; i<M+1; i++) {
		if ((xf[i+1]-xf[i])<distminf) {
			distminf=(xf[i+1]-xf[i]);
		}
	}

	Real foundx=xstartgate+pA.a;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+2; i++) {
		if (fabs(foundx-xf[i])<eps2) {
			eps2=fabs(foundx-xf[i]);
			ifound=i;
		}
	}
	
	if (eps2<0.001*distminf) {
		// совпадение с узлом.
		xf[ifound]=foundx;
		for (int i=M+2; i>ifound+1; i--) {
			xf[i]=xf[i-1];
		}
		xf[ifound+1]=xf[ifound]+0.5*(xf[ifound+2]-xf[ifound]);
	}
	else {
		if (xf[ifound]>foundx) {
            for (int i=M+2; i>ifound; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound]=foundx;
		}
		else {
			for (int i=M+2; i>ifound+1; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound+1]=foundx;
		}
	}


 distminf=1.0e30;
	for (int i=0; i<M+2; i++) {
		if ((xf[i+1]-xf[i])<distminf) {
			distminf=(xf[i+1]-xf[i]);
		}
	}

	foundx=xstartgate+pA.a+pA.delta;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+3; i++) {
		if (fabs(foundx-xf[i])<eps2) {
			eps2=fabs(foundx-xf[i]);
			ifound=i;
		}
	}
	
	if (eps2<0.001*distminf) {
		// совпадение с узлом.
		xf[ifound]=foundx;
		for (int i=M+3; i>ifound+1; i--) {
			xf[i]=xf[i-1];
		}
		xf[ifound+1]=xf[ifound]+0.5*(xf[ifound+2]-xf[ifound]);
	}
	else {
		if (xf[ifound]>foundx) {
            for (int i=M+3; i>ifound; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound]=foundx;
		}
		else {
			for (int i=M+3; i>ifound+1; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound+1]=foundx;
		}
	}

	 distminf=1.0e30;
	for (int i=0; i<M+3; i++) {
		if ((xf[i+1]-xf[i])<distminf) {
			distminf=(xf[i+1]-xf[i]);
		}
	}

	foundx=xstartgate+pA.a+pA.delta+pA.b;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+4; i++) {
		if (fabs(foundx-xf[i])<eps2) {
			eps2=fabs(foundx-xf[i]);
			ifound=i;
		}
	}
	
	if (eps2<0.001*distminf) {
		// совпадение с узлом.
		xf[ifound]=foundx;
		for (int i=M+4; i>ifound+1; i--) {
			xf[i]=xf[i-1];
		}
		xf[ifound+1]=xf[ifound]+0.5*(xf[ifound+2]-xf[ifound]);
	}
	else {
		if (xf[ifound]>foundx) {
            for (int i=M+4; i>ifound; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound]=foundx;
		}
		else {
			for (int i=M+4; i>ifound+1; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound+1]=foundx;
		}
	}


	M=M+3;

	int Ngly=N+2+19+9+9+2;
	// Старое значение используется для концентрации.
	//Real* yf=new Real[N+2];
	// Новое значение используется для потенциала.
	Real* yf=new Real[Ngly];
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;

	// Параметры обкладки:
	yf[N+2+18]=yf[N+1]+pA.hM;
	for (int i=N+2; i<N+2+18; i++) {
		yf[i]=yf[N+1]+(i-(N+1))*pA.hM/19.0;
	}
	yf[N+2+19+8]=yf[N+1]+pA.hM+pA.hz;
	for (int i=N+2+19; i<N+2+19+8; i++) {
		yf[i]=yf[N+1]+pA.hM+(i-(N+1+19))*pA.hz/9.0;
	}
	yf[N+2+19+9+8]=yf[N+1]+pA.hM+pA.hz+pA.h0;
	for (int i=N+2+19+9; i<N+2+19+9+8; i++) {
		yf[i]=yf[N+1]+pA.hM+pA.hz+(i-(N+1+19+9))*pA.h0/9.0;
	}

	distminf=1.0e30;
	for (int i=0; i<N+2+19+9+8; i++) {
		if ((yf[i+1]-yf[i])<distminf) {
			distminf=(yf[i+1]-yf[i]);
		}
	}

	Real foundy=yf[N+1]+pA.hM+pA.hz-pA.hdelta-pA.h0;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<N+2+19+9+8+1; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	
	if (eps2<0.001*distminf) {
		// совпадение с узлом.
		yf[ifound]=foundy;
		for (int i=N+2+19+9+8+1; i>ifound+1; i--) {
			yf[i]=yf[i-1];
		}
		yf[ifound+1]=yf[ifound]+0.5*(yf[ifound+2]-yf[ifound]);
	}
	else {
		if (yf[ifound]>foundy) {
            for (int i=N+2+19+9+8+1; i>ifound; i--) {
		     	yf[i]=yf[i-1];
		    }
            yf[ifound]=foundy;
		}
		else {
			for (int i=N+2+19+9+8+1; i>ifound+1; i--) {
		     	yf[i]=yf[i-1];
		    }
            yf[ifound+1]=foundy;
		}
	}

	distminf=1.0e30;
	for (int i=0; i<N+2+19+9+8+1; i++) {
		if ((yf[i+1]-yf[i])<distminf) {
			distminf=(yf[i+1]-yf[i]);
		}
	}

	foundy=yf[N+1]+pA.hM+pA.hz-pA.hdelta;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<N+2+19+9+8+2; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	
	if (eps2<0.001*distminf) {
		// совпадение с узлом.
		yf[ifound]=foundy;
		for (int i=N+2+19+9+8+2; i>ifound+1; i--) {
			yf[i]=yf[i-1];
		}
		yf[ifound+1]=yf[ifound]+0.5*(yf[ifound+2]-yf[ifound]);
	}
	else {
		if (yf[ifound]>foundy) {
            for (int i=N+2+19+9+8+2; i>ifound; i--) {
		     	yf[i]=yf[i-1];
		    }
            yf[ifound]=foundy;
		}
		else {
			for (int i=N+2+19+9+8+2; i>ifound+1; i--) {
		     	yf[i]=yf[i-1];
		    }
            yf[ifound+1]=foundy;
		}
	}

	 
	// i1, i2, i3, i4, i5, i6, i7 0 .. M+1
	// j1, j2, j3, j4, j5, j6  0.. Ngly-1
	int j1=N+1;
	int j2=N+2+18;
	distminf=1.0e30;
	for (int i=0; i<Ngly-1; i++) {
		if ((yf[i+1]-yf[i])<distminf) {
			distminf=(yf[i+1]-yf[i]);
		}
	}
	foundy=yf[N+1]+pA.hM+pA.hz-pA.hdelta-pA.h0;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<Ngly; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	int j3=-1;
	if (eps2<0.001*distminf) {
	 j3=ifound;
	}
	if (j3==-1) {
		printf("problem definition j3\n");
		getchar();
	}
	foundy=yf[N+1]+pA.hM+pA.hz-pA.hdelta;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<Ngly; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	int j4=-1;
	if (eps2<0.001*distminf) {
	 j4=ifound;
	}
	if (j4==-1) {
		printf("problem definition j4\n");
		getchar();
	}
	foundy=yf[N+1]+pA.hM+pA.hz;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<Ngly; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	int j5=-1;
	if (eps2<0.001*distminf) {
	 j5=ifound;
	}
	if (j5==-1) {
		printf("problem definition j5\n");
		getchar();
	}
	foundy=yf[N+1]+pA.hM+pA.hz+pA.h0;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<Ngly; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	int j6=-1;
	if (eps2<0.001*distminf) {
	 j6=ifound;
	}
	if (j6==-1) {
		printf("problem definition j6\n");
		getchar();
	}
	distminf=1.0e30;
	for (int i=0; i<M+1; i++) {
		if ((xf[i+1]-xf[i])<distminf) {
			distminf=(xf[i+1]-xf[i]);
		}
	}
	foundy=xendsource;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i1=-1;
	if (eps2<0.001*distminf) {
	 i1=ifound;
	}
	if (i1==-1) {
		printf("problem definition i1\n");
		getchar();
	}
	foundy=xstartgate;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i2=-1;
	if (eps2<0.001*distminf) {
	 i2=ifound;
	}
	if (i2==-1) {
		printf("problem definition i2\n");
		getchar();
	}
	foundy=xendgate;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i3=-1;
	if (eps2<0.001*distminf) {
	 i3=ifound;
	}
	if (i3==-1) {
		printf("problem definition i3\n");
		getchar();
	}
	foundy=xstartgate+pA.a;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i4=-1;
	if (eps2<0.001*distminf) {
	 i4=ifound;
	}
	if (i4==-1) {
		printf("problem definition i4\n");
		getchar();
	}
	foundy=xstartgate+pA.a+pA.delta;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i5=-1;
	if (eps2<0.001*distminf) {
	 i5=ifound;
	}
	if (i5==-1) {
		printf("problem definition i5\n");
		getchar();
	}
	foundy=xstartgate+pA.a+pA.delta+pA.b;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i6=-1;
	if (eps2<0.001*distminf) {
	 i6=ifound;
	}
	if (i6==-1) {
		printf("problem definition i6\n");
		getchar();
	}
	foundy=xstartdrain;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i7=-1;
	if (eps2<0.001*distminf) {
	 i7=ifound;
	}
	if (i7==-1) {
		printf("problem definition i7\n");
		getchar();
	}
	if (i5-i4==2) {
		// нужно добавить узлов между i4 и i5.
		Real *xfloc=new Real[M+2];
		for (int i=0; i<M+2; i++) {
			xfloc[i]=xf[i];
		}
		delete xf;
		xf=new Real[M+2+5];
		for (int i=0; i<=i4; i++) {
			xf[i]=xfloc[i];
		}
		for (int i=M+1; i>=i5; i--) {
			xf[i+5]=xfloc[i];
		}
		Real d7=(xfloc[i5]-xfloc[i4])/7.0;
		for (int i=i4+1; i<=i4+6; i++) {
			xf[i]=xfloc[i4]+(i-i4)*d7;
		}
		M=M+5;
		delete xfloc;
distminf=1.0e30;
	for (int i=0; i<M+1; i++) {
		if ((xf[i+1]-xf[i])<distminf) {
			distminf=(xf[i+1]-xf[i]);
		}
	}
	foundy=xendsource;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i1=-1;
	if (eps2<0.001*distminf) {
	 i1=ifound;
	}
	if (i1==-1) {
		printf("problem definition i1\n");
		getchar();
	}
	foundy=xstartgate;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
    i2=-1;
	if (eps2<0.001*distminf) {
	 i2=ifound;
	}
	if (i2==-1) {
		printf("problem definition i2\n");
		getchar();
	}
	foundy=xendgate;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i3=-1;
	if (eps2<0.001*distminf) {
	 i3=ifound;
	}
	if (i3==-1) {
		printf("problem definition i3\n");
		getchar();
	}
	foundy=xstartgate+pA.a;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i4=-1;
	if (eps2<0.001*distminf) {
	 i4=ifound;
	}
	if (i4==-1) {
		printf("problem definition i4\n");
		getchar();
	}
	foundy=xstartgate+pA.a+pA.delta;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i5=-1;
	if (eps2<0.001*distminf) {
	 i5=ifound;
	}
	if (i5==-1) {
		printf("problem definition i5\n");
		getchar();
	}
	foundy=xstartgate+pA.a+pA.delta+pA.b;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i6=-1;
	if (eps2<0.001*distminf) {
	 i6=ifound;
	}
	if (i6==-1) {
		printf("problem definition i6\n");
		getchar();
	}
	foundy=xstartdrain;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i7=-1;
	if (eps2<0.001*distminf) {
	 i7=ifound;
	}
	if (i7==-1) {
		printf("problem definition i7\n");
		getchar();
	}
	}
	//printf("i1=%d, i2=%d, i3=%d, i4=%d, i5=%d, i6=%d, i7=%d, M+1=%d\n",i1,i2,i3,i4,i5, i6,i7,M+1);
	//printf("j1=%d, j2=%d, j3=%d, j4=%d, j5=%d, j6=%d,  Ngly-1=%d\n",j1,j2,j3,j4,j5, j6,Ngly-1);
	int nodes_u=0;
	int **inum=NULL;
	Real *xexport=NULL, *yexport=NULL, *epsilon_export=NULL, **u_export=NULL, *rthdsd_gl=NULL, *rthdsd_gl_internal=NULL;
	int **nvtx_export=NULL; // нумерация начинается с единицы.
	bool *constr;

	inum=new int*[M+2];
	for (int i=0; i<M+2; i++) inum[i]=new int[Ngly];
	for (int i=0; i<M+2; i++) for (int j=0; j<Ngly; j++) {
		inum[i][j]=-1; // несуществующий узел.
	}
	int icountnum=1; // счётчик вершин
	for (int j=0; j<Ngly; j++) for (int i=0; i<M+2; i++)  {
		if (j<=j1) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>=i1) && (i<=i2) && (j>j1) && (j<Ngly)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>i2) && (i<=i3) && (j>=j2) && (j<=j5)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>=i3) && (i<=i4) && (j>j1) && (j<=j5)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>i4) && (i<i6) && (j>j1) && (j<=j3)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>=i6) && (i<=i7) && (j>j1) && (j<Ngly)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>=i5) && (i<i6) && (j>=j4) && (j<Ngly)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
	}
	icountnum--;
	xexport=new Real[icountnum];
	yexport=new Real[icountnum];
	constr=new bool[icountnum];
	u_export=new Real*[3];
	for (int i=0; i<3; i++) {
		u_export[i]=new Real[icountnum];
	}	
	rthdsd_gl=new Real[icountnum];
	rthdsd_gl_internal=new Real[icountnum];
	int icount2=0;
	for (int j=0; j<Ngly; j++) for (int i=0; i<M+2; i++)  {
		if (inum[i][j]>-1) {
			xexport[icount2]=xf[i]; // индексация начинается с нуля.
			yexport[icount2]=yf[j];
			constr[icount2]=false;
			u_export[0][icount2]=0.0;
			u_export[1][icount2]=0.0;
			u_export[2][icount2]=0.0;
			icount2++;
		}
	}
	int maxnode=icountnum;
	int maxelm=0; // количество элементов.
	for (int j=0; j<Ngly-1; j++) for (int i=0; i<M+2-1; i++)  {
		if ((inum[i][j]>-1)&&(inum[i+1][j]>-1)&&(inum[i][j+1]>-1)&&(inum[i+1][j+1]>-1)) {
			maxelm++;
		}
	}
	nvtx_export=new int*[4];
    for (int i=0; i<4; i++) nvtx_export[i]=new int[maxelm];
	epsilon_export=new Real[maxelm];
	int ie=0;
	for (int j=0; j<Ngly-1; j++) for (int i=0; i<M+2-1; i++)  {
		if ((inum[i][j]>-1)&&(inum[i+1][j]>-1)&&(inum[i][j+1]>-1)&&(inum[i+1][j+1]>-1)) {
			nvtx_export[0][ie]=inum[i][j];
			nvtx_export[1][ie]=inum[i+1][j];
			nvtx_export[2][ie]=inum[i+1][j+1];
			nvtx_export[3][ie]=inum[i][j+1];
			if (j<j1) {
                epsilon_export[ie]=epsilonGaN;
			}
			else {
				epsilon_export[ie]=epsilon_dielectric; 
			}
			ie++;
		}
	}

	// Граничные условия Дирихле :
	for (int i=0; i<=i1; i++) {
		// source
		if (inum[i][j1]>0) { 
		constr[inum[i][j1]-1]=true;
		u_export[0][inum[i][j1]-1]=0.0;
		}
		else {
			printf("negativ inum source j1\n");
		}
	}
	for (int j=j1+1; j<Ngly; j++) {
		// source
		if (inum[i1][j]>0) {
		constr[inum[i1][j]-1]=true;
		u_export[0][inum[i1][j]-1]=0.0;
		}
		else {
			printf("negativ inum source i1\n");
		}
	}
	for (int i=i7; i<=M+1; i++) {
		// drain
		if (inum[i][j1]>0) {
		constr[inum[i][j1]-1]=true;
		u_export[0][inum[i][j1]-1]=ud;
		}
		else {
			printf("negativ inum drain j1\n");
		}
	}
	for (int j=j1+1; j<Ngly; j++) {
		// drain
		if (inum[i7][j]>0) {
		constr[inum[i7][j]-1]=true;
		u_export[0][inum[i7][j]-1]=ud;
		}
		else {
			printf("negativ inum drain i7\n");
		}
	}
	for (int i=i2; i<=i3; i++) {
		// gate
		if (inum[i][j1]>0) {
		constr[inum[i][j1]-1]=true;
		u_export[0][inum[i][j1]-1]=ug;
		}
		else {
			printf("negativ inum gate j1\n");
		}
		if (inum[i][j2]>0) {
        constr[inum[i][j2]-1]=true;
		u_export[0][inum[i][j2]-1]=ug;
		}
		else {
			printf("negativ inum gate j2\n");
		}
	}
	for (int j=j1; j<=j2; j++) {
		// gate
		if (inum[i2][j]>0) {
        constr[inum[i2][j]-1]=true;
		u_export[0][inum[i2][j]-1]=ug;
		}
		else {
			printf("negativ inum gate i2\n");
		}
		if (inum[i3][j]>0) {
        constr[inum[i3][j]-1]=true;
		u_export[0][inum[i3][j]-1]=ug;
		}
		else {
			printf("negativ inum gate i3\n");
		}
	}
	// Обкладка :
	for (int i=i4; i<=i6; i++) {
		if (inum[i][j3]>0) {
		constr[inum[i][j3]-1]=true;
		u_export[0][inum[i][j3]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka j3\n");
		}
	}
	for (int i=i2; i<=i4; i++) {
       if (inum[i][j5]>0) {
		constr[inum[i][j5]-1]=true;
		u_export[0][inum[i][j5]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka j5\n");
		}
	}
	for (int j=j3+1; j<j5; j++) {
		if (inum[i4][j]>0) {
		constr[inum[i4][j]-1]=true;
		u_export[0][inum[i4][j]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka i4\n");
		}
	}
	for (int j=j5+1; j<=j6; j++) {
		if (inum[i2][j]>0) {
		constr[inum[i2][j]-1]=true;
		u_export[0][inum[i2][j]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka i2\n");
		}
	}
	for (int i=i5; i<=i6; i++) {
		if (inum[i][j4]>0) {
		constr[inum[i][j4]-1]=true;
		u_export[0][inum[i][j4]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka j4\n");
		}
	}
	for (int j=j3+1; j<j4; j++) {
		if (inum[i6][j]>0) {
		constr[inum[i6][j]-1]=true;
		u_export[0][inum[i6][j]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka i6\n");
		}
	}
	for (int j=j4+1; j<=j6; j++) {
		if (inum[i5][j]>0) {
		constr[inum[i5][j]-1]=true;
		u_export[0][inum[i5][j]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka i5\n");
		}
	}

	/*
	FILE *fpexport;
	errno_t err3;
	
	if ((err1=fopen_s(&fpexport,"export.txt","wt"))!=0) {
		printf("Not create file export.txt\n");
		// не могу создать файл для перезаписи.
	}
	else {
		/*
		for (int i=0; i<=M+1; i++) {
			fprintf(fpexport,"%e\n",xf[i]);
		}
		for (int i=0; i<Ngly; i++) {
			fprintf(fpexport,"%e\n",yf[i]);
		}*//*
		
		printf("maxnode=%d\n",maxnode);
		for (int i=0; i<maxnode; i++) {
		    fprintf(fpexport, "%d %e %e\n", i+1, xexport[i], yexport[i]);
		}
		fprintf(fpexport,"\n");
		for (ie=0; ie<maxelm; ie++) {
			fprintf(fpexport,"4 %d %d %d %d %e %e %e\n",nvtx_export[0][ie],nvtx_export[1][ie],nvtx_export[2][ie],nvtx_export[3][ie], 1.0, 1.0, epsilon_export[ie]);
		}
		fprintf(fpexport,"\n");
		for (int i=0; i<maxnode; i++) {
			if (constr[i]) {
				fprintf(fpexport,"%d %e\n",i+1,u_export[i]);
			}
		}
		fclose(fpexport);
		
	}

	*/
	
	// 1. Инициализация матрицы.
	ONE_MATRIX_STRING* seidel_matrix;
	init_Seidel_matrix(seidel_matrix,  maxnode);
	// 2. Сборка матрицы.
	int nve=4; // четырёхугольный элемент.
	// Локальная матрица СЛАУ и локальная правая часть.
	Real** aelm;
	aelm=new Real*[nve];
	for (int i=0; i<nve; i++) aelm[i]=new Real[nve];
	Real* rloc;
	rloc=new Real[nve];




	//const Real mu_GaAs=4966.999; // подвижность электронов в кремнии. 
	
	// подвижность в нитриде Галлия
	const Real mu_GaN=electron_mobility_GaN(Tamb, Nd);
	//Real K1=elementary_q/epsilon0/epsilonGaN;
	Real K1=elementary_q/epsilon0; // пространственное распределение диэлектрической постоянной учитывается в матрице СЛАУ.
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_GaN*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaN*epsilon0/(elementary_q*Nd*mu_GaN); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//не менее 18400 шагов по времени с tau=2.0*tauM; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ для потенциала
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N); // выделение памяти под матрицу потенциала.
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			   // constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					//rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
					 // на объём контрольного объёма домножение будет производится при сборке СЛАУ.
					rthdsd_internal[i][j]=(K1Nd-K1*n[i][j]);
		         }
	         }

			 // инициализация :
			 for (int j=0; j<Ngly; j++) for (int i=0; i<M+2; i++)  {
		           if (inum[i][j]>-1) {
			            rthdsd_gl_internal[inum[i][j]-1]=0.0; // по умолчанию везде диэлектрик и заряда нет.
						rthdsd_gl[inum[i][j]-1]=0.0; // TODO взможно это важно.
		            }
			    }

			  for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
					  if (inum[i][j]>-1) {
						  //rthdsd_gl[inum[i][j]-1]=rthdsd_internal[i][j]; // Заряд в полупроводнике.
						  rthdsd_gl_internal[inum[i][j]-1]=rthdsd_internal[i][j]; 
					  }
				 }
			  }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			//  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	

	         set_zero_Seidel_matrix(seidel_matrix,maxnode);

				 // Сборка матрицы СЛАУ.
			 int ie;
			 for (ie=0; ie<maxelm; ie++) {
				 bool btimedep=false; // стационарный солвер.
				 
				 Real dtau=0.001; // шаг по времени.
				 Real Sc1=0.0, Sc2=0.0, Sc3=0.0, Sc4=0.0; // источниковый член (явная составляющая).
				 Real Sp=0.0; // источниковый член (неявная составляющая).
				 int ishconvection=6; // схема Патанкара.

				 Sc1=rthdsd_gl_internal[nvtx_export[0][ie]-1];
				 Sc2=rthdsd_gl_internal[nvtx_export[1][ie]-1];
				 Sc3=rthdsd_gl_internal[nvtx_export[2][ie]-1];
				 Sc4=rthdsd_gl_internal[nvtx_export[3][ie]-1];

				 // инициализирующий сброс значений.
				 for (int i=0; i<nve; i++) {
					 for (int j=0; j<nve; j++) {
						 aelm[i][j]=0.0;
					 }
					 rloc[i]=0.0;
				 }

				 // Сборка локальных матриц размерности 4x4.
                 // Прямоугольный элемент.
                 // ie - номер элемента,
                 // btimedep - нестационарный (true), стационарный (false).
                 // Свойства материалов храняться в позициях отличных от центров контрольных объёмов,
                 // а конкретно храняться в центрах квадратных ячеек сетки (связи контрольных объёмов).
                 // Таким образом материалы храняться с учётом естественных границ расчётной области, что очень важно.
                 // Rho - коэффициент перед нестационарным членом, 
                 // Gam - коэффициент диффузии.
                 // ishconvection - схема аппроксимации конвективного члена.
                 // Sc, Sp - аппроксимация источникового члена, (их нужно приписывать к вершинам ячейки т.е. они должны хранится в тех же точках что и вектор potent).
                 // dtau - шаг по времени.
                 // iVar - переменная для которой составляется дискретный аналог.
                 my_elmatr_quad(ie, btimedep,
	                1.0, epsilon_export[ie],
					ishconvection,
					Sc1,Sc2,Sc3,Sc4, Sp,
					dtau, 
					nve, xexport, yexport,
					nvtx_export,  u_export,
					aelm, rloc);

				

				    bool bsecond_member_of_equation=true; // собираем также и правую часть.
                    // Включение одиночных матричных элементов (aelm, rloc)
                    // в глобальную матрицу сглаживателя Гаусса-Зейделя и 
                    // (если bsecond_member_of_equation=true) правую часть.
                    // Используются следующие данные: nve, nvtx, constr, potent,
                    // rthdsd, rloc, aelm.
                    // Нужно сделать так чтобы было как можно меньше данных с глобальной областью видимости.
                    elembdSeidelMatrix(ie, bsecond_member_of_equation,
	                    seidel_matrix, 
						nvtx_export, nve, 
						aelm, u_export,
						constr,
						rthdsd_gl, rloc);

			 }
            



			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				     // SORDirichlet(u, rthdsd, A, URF, M, N);
					  solve_puas(seidel_matrix, 
	                          maxnode, rthdsd_gl,
				              u_export, URF);

			       
					 
                 }
				 //Ilyin1985quick(u, rthdsd, A, M, N, iend);
				 
				 // Обратное копирование.
				 icountnum=0; // счётчик вершин
	             for (int j=0; j<=j1; j++) for (int i=0; i<M+2; i++)  {
		             u[i][j]=u_export[0][icountnum++];    
		         }
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			 if (0) {
	             // Найдём компоненты скорости не ограниченной сверху они соноправлены градиету потенциала :
	             calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			     for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
					     // Напряжённости же поля противоположны градиенту потенциала.
					     ex[i][j]=-x_vel[i][j];
					     ey[i][j]=-y_vel[i][j];
					     emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				     }
			     }
			 }
			

	         // Применение реальной полескоростной характеристики Нитрида Галлия :
			
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
					   if (vel_mag[i][j]>1.0e-30) {
	                       x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   }
					   else {
						   x_vel[i][j]=0.0;
						   y_vel[i][j]=0.0;
						   vel_mag[i][j]=0.0;
					   }
		          }
	           }
			 }

			

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			 // аппроксимация Крёмера.
			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 // Vy
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					    x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						  y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }

			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn, rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/

		

	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		    printf("%d%% %f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			// zero current
			printf("%d%% %f",100,0.0);
			break;
		}

	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

	 
	calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	
	for (int i=0; i<M+2; i++) {
	     for (int j=0; j<N+2; j++) {
		      vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		      Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
			   if (vel_mag[i][j]>1.0e-30) {
				    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
               }
			   else {
				   x_vel[i][j]=0.0;
				   y_vel[i][j]=0.0;
				   vel_mag[i][j]=0.0;
				}
	         
		 }
	}	 


	  

	if (1) {
			  // найдём токи Сверено с Федотовым стр. 648.
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	//exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	    exporttecplotMESFET3(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N,maxnode,maxelm,xexport,yexport,nvtx_export,u_export[0]);
	
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		printf("Not Found and open file task.txt\n");
		// данные записаны не будут
	}
	else {
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		fclose(fp);
	}
	
	// Освобождение оперативной памяти.
	
	for (int i=0; i<nve; i++) delete aelm[i];
	delete aelm;
	delete rloc;
	// Освобождение памяти из под матрицы Зейделя.
    free_Seidel_matrix(seidel_matrix, maxnode);
	delete xexport;
	delete yexport;
	delete constr;
	for (int i=0; i<3; i++) {
		delete u_export[i];
	}
	delete u_export;
	delete rthdsd_gl;
	delete rthdsd_gl_internal;

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	getchar();

} // startMESFETGaN_obkladkaA

// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Нитрид Галлия.
// С обкладкой геометрии типа А.
// На данном варианте нарабатываются оптимизирующие скорость счёта варианты.
void startMESFETGaN_obkladkaAquick() {

    
	// V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.

	// Параметры обкладки вида А.
	plateA pA; // cm
	pA.hM=0.1e-4;
	pA.Vo=-1.0; // V
	pA.hz=0.05e-4;
	pA.h0=0.05e-4;
	pA.a=1.2*(xendgate-xstartgate);
	pA.b=0.5e-4;
	pA.delta=pA.h0;
	pA.hdelta=0.0;

	// epsilon  SiO2  Si3N4
	//          3.9    7.5
	Real epsilon_dielectric=3.9;
	// Общеупотребительные константы:
	const Real epsilonGaN=9.5;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;

	
	
	FILE *fp;
	errno_t err1;
	/*
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}
	*/





	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	int Mglx=M+2+3;
	//Real* xf=new Real[M+2];
	Real* xf=new Real[Mglx];

	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	

	
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);

	Real distminf=1.0e30;
	for (int i=0; i<M+1; i++) {
		if ((xf[i+1]-xf[i])<distminf) {
			distminf=(xf[i+1]-xf[i]);
		}
	}

	Real foundx=xstartgate+pA.a;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+2; i++) {
		if (fabs(foundx-xf[i])<eps2) {
			eps2=fabs(foundx-xf[i]);
			ifound=i;
		}
	}
	
	if (eps2<0.001*distminf) {
		// совпадение с узлом.
		xf[ifound]=foundx;
		for (int i=M+2; i>ifound+1; i--) {
			xf[i]=xf[i-1];
		}
		xf[ifound+1]=xf[ifound]+0.5*(xf[ifound+2]-xf[ifound]);
	}
	else {
		if (xf[ifound]>foundx) {
            for (int i=M+2; i>ifound; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound]=foundx;
		}
		else {
			for (int i=M+2; i>ifound+1; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound+1]=foundx;
		}
	}


 distminf=1.0e30;
	for (int i=0; i<M+2; i++) {
		if ((xf[i+1]-xf[i])<distminf) {
			distminf=(xf[i+1]-xf[i]);
		}
	}

	foundx=xstartgate+pA.a+pA.delta;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+3; i++) {
		if (fabs(foundx-xf[i])<eps2) {
			eps2=fabs(foundx-xf[i]);
			ifound=i;
		}
	}
	
	if (eps2<0.001*distminf) {
		// совпадение с узлом.
		xf[ifound]=foundx;
		for (int i=M+3; i>ifound+1; i--) {
			xf[i]=xf[i-1];
		}
		xf[ifound+1]=xf[ifound]+0.5*(xf[ifound+2]-xf[ifound]);
	}
	else {
		if (xf[ifound]>foundx) {
            for (int i=M+3; i>ifound; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound]=foundx;
		}
		else {
			for (int i=M+3; i>ifound+1; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound+1]=foundx;
		}
	}

	 distminf=1.0e30;
	for (int i=0; i<M+3; i++) {
		if ((xf[i+1]-xf[i])<distminf) {
			distminf=(xf[i+1]-xf[i]);
		}
	}

	foundx=xstartgate+pA.a+pA.delta+pA.b;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<M+4; i++) {
		if (fabs(foundx-xf[i])<eps2) {
			eps2=fabs(foundx-xf[i]);
			ifound=i;
		}
	}
	
	if (eps2<0.001*distminf) {
		// совпадение с узлом.
		xf[ifound]=foundx;
		for (int i=M+4; i>ifound+1; i--) {
			xf[i]=xf[i-1];
		}
		xf[ifound+1]=xf[ifound]+0.5*(xf[ifound+2]-xf[ifound]);
	}
	else {
		if (xf[ifound]>foundx) {
            for (int i=M+4; i>ifound; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound]=foundx;
		}
		else {
			for (int i=M+4; i>ifound+1; i--) {
		     	xf[i]=xf[i-1];
		    }
            xf[ifound+1]=foundx;
		}
	}


	M=M+3;

	int Ngly=N+2+19+9+9+2;
	// Старое значение используется для концентрации.
	//Real* yf=new Real[N+2];
	// Новое значение используется для потенциала.
	Real* yf=new Real[Ngly];
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;

	// Параметры обкладки:
	yf[N+2+18]=yf[N+1]+pA.hM;
	for (int i=N+2; i<N+2+18; i++) {
		yf[i]=yf[N+1]+(i-(N+1))*pA.hM/19.0;
	}
	yf[N+2+19+8]=yf[N+1]+pA.hM+pA.hz;
	for (int i=N+2+19; i<N+2+19+8; i++) {
		yf[i]=yf[N+1]+pA.hM+(i-(N+1+19))*pA.hz/9.0;
	}
	yf[N+2+19+9+8]=yf[N+1]+pA.hM+pA.hz+pA.h0;
	for (int i=N+2+19+9; i<N+2+19+9+8; i++) {
		yf[i]=yf[N+1]+pA.hM+pA.hz+(i-(N+1+19+9))*pA.h0/9.0;
	}

	distminf=1.0e30;
	for (int i=0; i<N+2+19+9+8; i++) {
		if ((yf[i+1]-yf[i])<distminf) {
			distminf=(yf[i+1]-yf[i]);
		}
	}

	Real foundy=yf[N+1]+pA.hM+pA.hz-pA.hdelta-pA.h0;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<N+2+19+9+8+1; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	
	if (eps2<0.001*distminf) {
		// совпадение с узлом.
		yf[ifound]=foundy;
		for (int i=N+2+19+9+8+1; i>ifound+1; i--) {
			yf[i]=yf[i-1];
		}
		yf[ifound+1]=yf[ifound]+0.5*(yf[ifound+2]-yf[ifound]);
	}
	else {
		if (yf[ifound]>foundy) {
            for (int i=N+2+19+9+8+1; i>ifound; i--) {
		     	yf[i]=yf[i-1];
		    }
            yf[ifound]=foundy;
		}
		else {
			for (int i=N+2+19+9+8+1; i>ifound+1; i--) {
		     	yf[i]=yf[i-1];
		    }
            yf[ifound+1]=foundy;
		}
	}

	distminf=1.0e30;
	for (int i=0; i<N+2+19+9+8+1; i++) {
		if ((yf[i+1]-yf[i])<distminf) {
			distminf=(yf[i+1]-yf[i]);
		}
	}

	foundy=yf[N+1]+pA.hM+pA.hz-pA.hdelta;
	ifound=1;
	eps2=1e30;
	for (int i=ifound+1; i<N+2+19+9+8+2; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	
	if (eps2<0.001*distminf) {
		// совпадение с узлом.
		yf[ifound]=foundy;
		for (int i=N+2+19+9+8+2; i>ifound+1; i--) {
			yf[i]=yf[i-1];
		}
		yf[ifound+1]=yf[ifound]+0.5*(yf[ifound+2]-yf[ifound]);
	}
	else {
		if (yf[ifound]>foundy) {
            for (int i=N+2+19+9+8+2; i>ifound; i--) {
		     	yf[i]=yf[i-1];
		    }
            yf[ifound]=foundy;
		}
		else {
			for (int i=N+2+19+9+8+2; i>ifound+1; i--) {
		     	yf[i]=yf[i-1];
		    }
            yf[ifound+1]=foundy;
		}
	}

	 
	// i1, i2, i3, i4, i5, i6, i7 0 .. M+1
	// j1, j2, j3, j4, j5, j6  0.. Ngly-1
	int j1=N+1;
	int j2=N+2+18;
	distminf=FLT_MAX;
	for (int i=0; i<Ngly-1; i++) {
		if ((yf[i+1]-yf[i])<distminf) {
			distminf=(yf[i+1]-yf[i]);
		}
	}
	foundy=yf[N+1]+pA.hM+pA.hz-pA.hdelta-pA.h0;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<Ngly; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	int j3=-1;
	if (eps2<0.001*distminf) {
	 j3=ifound;
	}
	if (j3==-1) {
		printf("problem definition j3\n");
		getchar();
	}
	foundy=yf[N+1]+pA.hM+pA.hz-pA.hdelta;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<Ngly; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	int j4=-1;
	if (eps2<0.001*distminf) {
	 j4=ifound;
	}
	if (j4==-1) {
		printf("problem definition j4\n");
		getchar();
	}
	foundy=yf[N+1]+pA.hM+pA.hz;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<Ngly; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	int j5=-1;
	if (eps2<0.001*distminf) {
	 j5=ifound;
	}
	if (j5==-1) {
		printf("problem definition j5\n");
		getchar();
	}
	foundy=yf[N+1]+pA.hM+pA.hz+pA.h0;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<Ngly; i++) {
		if (fabs(foundy-yf[i])<eps2) {
			eps2=fabs(foundy-yf[i]);
			ifound=i;
		}
	}
	int j6=-1;
	if (eps2<0.001*distminf) {
	 j6=ifound;
	}
	if (j6==-1) {
		printf("problem definition j6\n");
		getchar();
	}
	distminf=FLT_MAX;
	for (int i=0; i<M+1; i++) {
		if ((xf[i+1]-xf[i])<distminf) {
			distminf=(xf[i+1]-xf[i]);
		}
	}
	foundy=xendsource;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i1=-1;
	if (eps2<0.001*distminf) {
	 i1=ifound;
	}
	if (i1==-1) {
		printf("problem definition i1\n");
		getchar();
	}
	foundy=xstartgate;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i2=-1;
	if (eps2<0.001*distminf) {
	 i2=ifound;
	}
	if (i2==-1) {
		printf("problem definition i2\n");
		getchar();
	}
	foundy=xendgate;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i3=-1;
	if (eps2<0.001*distminf) {
	 i3=ifound;
	}
	if (i3==-1) {
		printf("problem definition i3\n");
		getchar();
	}
	foundy=xstartgate+pA.a;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i4=-1;
	if (eps2<0.001*distminf) {
	 i4=ifound;
	}
	if (i4==-1) {
		printf("problem definition i4\n");
		getchar();
	}
	foundy=xstartgate+pA.a+pA.delta;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i5=-1;
	if (eps2<0.001*distminf) {
	 i5=ifound;
	}
	if (i5==-1) {
		printf("problem definition i5\n");
		getchar();
	}
	foundy=xstartgate+pA.a+pA.delta+pA.b;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i6=-1;
	if (eps2<0.001*distminf) {
	 i6=ifound;
	}
	if (i6==-1) {
		printf("problem definition i6\n");
		getchar();
	}
	foundy=xstartdrain;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	int i7=-1;
	if (eps2<0.001*distminf) {
	 i7=ifound;
	}
	if (i7==-1) {
		printf("problem definition i7\n");
		getchar();
	}
	if (i5-i4==2) {
		// нужно добавить узлов между i4 и i5.
		Real *xfloc=new Real[M+2];
		for (int i=0; i<M+2; i++) {
			xfloc[i]=xf[i];
		}
		delete xf;
		xf=new Real[M+2+5];
		for (int i=0; i<=i4; i++) {
			xf[i]=xfloc[i];
		}
		for (int i=M+1; i>=i5; i--) {
			xf[i+5]=xfloc[i];
		}
		Real d7=(xfloc[i5]-xfloc[i4])/7.0;
		for (int i=i4+1; i<=i4+6; i++) {
			xf[i]=xfloc[i4]+(i-i4)*d7;
		}
		M=M+5;
		delete xfloc;
distminf=FLT_MAX;
	for (int i=0; i<M+1; i++) {
		if ((xf[i+1]-xf[i])<distminf) {
			distminf=(xf[i+1]-xf[i]);
		}
	}
	foundy=xendsource;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i1=-1;
	if (eps2<0.001*distminf) {
	 i1=ifound;
	}
	if (i1==-1) {
		printf("problem definition i1\n");
		getchar();
	}
	foundy=xstartgate;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
    i2=-1;
	if (eps2<0.001*distminf) {
	 i2=ifound;
	}
	if (i2==-1) {
		printf("problem definition i2\n");
		getchar();
	}
	foundy=xendgate;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i3=-1;
	if (eps2<0.001*distminf) {
	 i3=ifound;
	}
	if (i3==-1) {
		printf("problem definition i3\n");
		getchar();
	}
	foundy=xstartgate+pA.a;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i4=-1;
	if (eps2<0.001*distminf) {
	 i4=ifound;
	}
	if (i4==-1) {
		printf("problem definition i4\n");
		getchar();
	}
	foundy=xstartgate+pA.a+pA.delta;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i5=-1;
	if (eps2<0.001*distminf) {
	 i5=ifound;
	}
	if (i5==-1) {
		printf("problem definition i5\n");
		getchar();
	}
	foundy=xstartgate+pA.a+pA.delta+pA.b;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i6=-1;
	if (eps2<0.001*distminf) {
	 i6=ifound;
	}
	if (i6==-1) {
		printf("problem definition i6\n");
		getchar();
	}
	foundy=xstartdrain;
	ifound=1;
	eps2=FLT_MAX;
	for (int i=ifound+1; i<M+1; i++) {
		if (fabs(foundy-xf[i])<eps2) {
			eps2=fabs(foundy-xf[i]);
			ifound=i;
		}
	}
	 i7=-1;
	if (eps2<0.001*distminf) {
	 i7=ifound;
	}
	if (i7==-1) {
		printf("problem definition i7\n");
		getchar();
	}
	}
	//printf("i1=%d, i2=%d, i3=%d, i4=%d, i5=%d, i6=%d, i7=%d, M+1=%d\n",i1,i2,i3,i4,i5, i6,i7,M+1);
	//printf("j1=%d, j2=%d, j3=%d, j4=%d, j5=%d, j6=%d,  Ngly-1=%d\n",j1,j2,j3,j4,j5, j6,Ngly-1);
	int nodes_u=0;
	int **inum=NULL;
	Real *xexport=NULL, *yexport=NULL, *epsilon_export=NULL, **u_export=NULL, *rthdsd_gl=NULL, *rthdsd_gl_internal=NULL;
	int **nvtx_export=NULL; // нумерация начинается с единицы.
	bool *constr;

	inum=new int*[M+2];
	for (int i=0; i<M+2; i++) inum[i]=new int[Ngly];
	for (int i=0; i<M+2; i++) for (int j=0; j<Ngly; j++) {
		inum[i][j]=-1; // несуществующий узел.
	}
	int icountnum=1; // счётчик вершин
	for (int j=0; j<Ngly; j++) for (int i=0; i<M+2; i++)  {
		if (j<=j1) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>=i1) && (i<=i2) && (j>j1) && (j<Ngly)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>i2) && (i<=i3) && (j>=j2) && (j<=j5)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>=i3) && (i<=i4) && (j>j1) && (j<=j5)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>i4) && (i<i6) && (j>j1) && (j<=j3)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>=i6) && (i<=i7) && (j>j1) && (j<Ngly)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
		if ((i>=i5) && (i<i6) && (j>=j4) && (j<Ngly)) {
			if (inum[i][j]==-1) {
			inum[i][j]=icountnum++;
			}
		}
	}
	icountnum--;
	xexport=new Real[icountnum];
	yexport=new Real[icountnum];
	constr=new bool[icountnum];
	u_export=new Real*[3];
	for (int i=0; i<3; i++) {
		u_export[i]=new Real[icountnum];
	}	
	rthdsd_gl=new Real[icountnum];
	rthdsd_gl_internal=new Real[icountnum];
	int icount2=0;
	for (int j=0; j<Ngly; j++) for (int i=0; i<M+2; i++)  {
		if (inum[i][j]>-1) {
			xexport[icount2]=xf[i]; // индексация начинается с нуля.
			yexport[icount2]=yf[j];
			constr[icount2]=false;
			u_export[0][icount2]=0.0;
			u_export[1][icount2]=0.0;
			u_export[2][icount2]=0.0;
			icount2++;
		}
	}
	int maxnode=icountnum;
	int maxelm=0; // количество элементов.
	for (int j=0; j<Ngly-1; j++) for (int i=0; i<M+2-1; i++)  {
		if ((inum[i][j]>-1)&&(inum[i+1][j]>-1)&&(inum[i][j+1]>-1)&&(inum[i+1][j+1]>-1)) {
			maxelm++;
		}
	}
	nvtx_export=new int*[4];
    for (int i=0; i<4; i++) nvtx_export[i]=new int[maxelm];
	epsilon_export=new Real[maxelm];
	int ie=0;
	for (int j=0; j<Ngly-1; j++) for (int i=0; i<M+2-1; i++)  {
		if ((inum[i][j]>-1)&&(inum[i+1][j]>-1)&&(inum[i][j+1]>-1)&&(inum[i+1][j+1]>-1)) {
			nvtx_export[0][ie]=inum[i][j];
			nvtx_export[1][ie]=inum[i+1][j];
			nvtx_export[2][ie]=inum[i+1][j+1];
			nvtx_export[3][ie]=inum[i][j+1];
			if (j<j1) {
                epsilon_export[ie]=epsilonGaN;
			}
			else {
				epsilon_export[ie]=epsilon_dielectric; 
			}
			ie++;
		}
	}

	// Граничные условия Дирихле :
	for (int i=0; i<=i1; i++) {
		// source
		if (inum[i][j1]>0) { 
		constr[inum[i][j1]-1]=true;
		u_export[0][inum[i][j1]-1]=0.0;
		}
		else {
			printf("negativ inum source j1\n");
		}
	}
	for (int j=j1+1; j<Ngly; j++) {
		// source
		if (inum[i1][j]>0) {
		constr[inum[i1][j]-1]=true;
		u_export[0][inum[i1][j]-1]=0.0;
		}
		else {
			printf("negativ inum source i1\n");
		}
	}
	for (int i=i7; i<=M+1; i++) {
		// drain
		if (inum[i][j1]>0) {
		constr[inum[i][j1]-1]=true;
		u_export[0][inum[i][j1]-1]=ud;
		}
		else {
			printf("negativ inum drain j1\n");
		}
	}
	for (int j=j1+1; j<Ngly; j++) {
		// drain
		if (inum[i7][j]>0) {
		constr[inum[i7][j]-1]=true;
		u_export[0][inum[i7][j]-1]=ud;
		}
		else {
			printf("negativ inum drain i7\n");
		}
	}
	for (int i=i2; i<=i3; i++) {
		// gate
		if (inum[i][j1]>0) {
		constr[inum[i][j1]-1]=true;
		u_export[0][inum[i][j1]-1]=ug;
		}
		else {
			printf("negativ inum gate j1\n");
		}
		if (inum[i][j2]>0) {
        constr[inum[i][j2]-1]=true;
		u_export[0][inum[i][j2]-1]=ug;
		}
		else {
			printf("negativ inum gate j2\n");
		}
	}
	for (int j=j1; j<=j2; j++) {
		// gate
		if (inum[i2][j]>0) {
        constr[inum[i2][j]-1]=true;
		u_export[0][inum[i2][j]-1]=ug;
		}
		else {
			printf("negativ inum gate i2\n");
		}
		if (inum[i3][j]>0) {
        constr[inum[i3][j]-1]=true;
		u_export[0][inum[i3][j]-1]=ug;
		}
		else {
			printf("negativ inum gate i3\n");
		}
	}
	// Обкладка :
	for (int i=i4; i<=i6; i++) {
		if (inum[i][j3]>0) {
		constr[inum[i][j3]-1]=true;
		u_export[0][inum[i][j3]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka j3\n");
		}
	}
	for (int i=i2; i<=i4; i++) {
       if (inum[i][j5]>0) {
		constr[inum[i][j5]-1]=true;
		u_export[0][inum[i][j5]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka j5\n");
		}
	}
	for (int j=j3+1; j<j5; j++) {
		if (inum[i4][j]>0) {
		constr[inum[i4][j]-1]=true;
		u_export[0][inum[i4][j]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka i4\n");
		}
	}
	for (int j=j5+1; j<=j6; j++) {
		if (inum[i2][j]>0) {
		constr[inum[i2][j]-1]=true;
		u_export[0][inum[i2][j]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka i2\n");
		}
	}
	for (int i=i5; i<=i6; i++) {
		if (inum[i][j4]>0) {
		constr[inum[i][j4]-1]=true;
		u_export[0][inum[i][j4]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka j4\n");
		}
	}
	for (int j=j3+1; j<j4; j++) {
		if (inum[i6][j]>0) {
		constr[inum[i6][j]-1]=true;
		u_export[0][inum[i6][j]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka i6\n");
		}
	}
	for (int j=j4+1; j<=j6; j++) {
		if (inum[i5][j]>0) {
		constr[inum[i5][j]-1]=true;
		u_export[0][inum[i5][j]-1]=pA.Vo;
		}
		else {
			printf("negativ inum okladka i5\n");
		}
	}

	/*
	FILE *fpexport;
	errno_t err3;
	
	if ((err1=fopen_s(&fpexport,"export.txt","wt"))!=0) {
		printf("Not create file export.txt\n");
		// не могу создать файл для перезаписи.
	}
	else {
		/*
		for (int i=0; i<=M+1; i++) {
			fprintf(fpexport,"%e\n",xf[i]);
		}
		for (int i=0; i<Ngly; i++) {
			fprintf(fpexport,"%e\n",yf[i]);
		}*//*
		
		printf("maxnode=%d\n",maxnode);
		for (int i=0; i<maxnode; i++) {
		    fprintf(fpexport, "%d %e %e\n", i+1, xexport[i], yexport[i]);
		}
		fprintf(fpexport,"\n");
		for (ie=0; ie<maxelm; ie++) {
			fprintf(fpexport,"4 %d %d %d %d %e %e %e\n",nvtx_export[0][ie],nvtx_export[1][ie],nvtx_export[2][ie],nvtx_export[3][ie], 1.0, 1.0, epsilon_export[ie]);
		}
		fprintf(fpexport,"\n");
		for (int i=0; i<maxnode; i++) {
			if (constr[i]) {
				fprintf(fpexport,"%d %e\n",i+1,u_export[i]);
			}
		}
		fclose(fpexport);
		
	}

	*/
	
	// 1. Инициализация матрицы.
	ONE_MATRIX_STRING* seidel_matrix;
	init_Seidel_matrix(seidel_matrix,  maxnode);
	// 2. Сборка матрицы.
	int nve=4; // четырёхугольный элемент.
	// Локальная матрица СЛАУ и локальная правая часть.
	Real** aelm;
	aelm=new Real*[nve];
	for (int i=0; i<nve; i++) aelm[i]=new Real[nve];
	Real* rloc;
	rloc=new Real[nve];




	//const Real mu_GaAs=4966.999; // подвижность электронов в кремнии. 
	
	// подвижность в нитриде Галлия
	const Real mu_GaN=electron_mobility_GaN(Tamb, Nd);
	//Real K1=elementary_q/epsilon0/epsilonGaN;
	Real K1=elementary_q/epsilon0; // пространственное распределение диэлектрической постоянной учитывается в матрице СЛАУ.
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_GaN*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaN*epsilon0/(elementary_q*Nd*mu_GaN); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//не менее 18400 шагов по времени с tau=2.0*tauM; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ для потенциала
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N); // выделение памяти под матрицу потенциала.
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			   // constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					//rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
					 // на объём контрольного объёма домножение будет производится при сборке СЛАУ.
					rthdsd_internal[i][j]=(K1Nd-K1*n[i][j]);
		         }
	         }

			 // инициализация :
			 for (int j=0; j<Ngly; j++) for (int i=0; i<M+2; i++)  {
		           if (inum[i][j]>-1) {
			            rthdsd_gl_internal[inum[i][j]-1]=0.0; // по умолчанию везде диэлектрик и заряда нет.
						rthdsd_gl[inum[i][j]-1]=0.0; // TODO взможно это важно.
		            }
			    }

			  for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
					  if (inum[i][j]>-1) {
						  //rthdsd_gl[inum[i][j]-1]=rthdsd_internal[i][j]; // Заряд в полупроводнике.
						  rthdsd_gl_internal[inum[i][j]-1]=rthdsd_internal[i][j]; 
					  }
				 }
			  }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			//  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	

	         set_zero_Seidel_matrix(seidel_matrix,maxnode);

				 // Сборка матрицы СЛАУ.
			 int ie;
			 for (ie=0; ie<maxelm; ie++) {
				 bool btimedep=false; // стационарный солвер.
				 
				 Real dtau=0.001; // шаг по времени.
				 Real Sc1=0.0, Sc2=0.0, Sc3=0.0, Sc4=0.0; // источниковый член (явная составляющая).
				 Real Sp=0.0; // источниковый член (неявная составляющая).
				 int ishconvection=6; // схема Патанкара.

				 Sc1=rthdsd_gl_internal[nvtx_export[0][ie]-1];
				 Sc2=rthdsd_gl_internal[nvtx_export[1][ie]-1];
				 Sc3=rthdsd_gl_internal[nvtx_export[2][ie]-1];
				 Sc4=rthdsd_gl_internal[nvtx_export[3][ie]-1];

				 // инициализирующий сброс значений.
				 for (int i=0; i<nve; i++) {
					 for (int j=0; j<nve; j++) {
						 aelm[i][j]=0.0;
					 }
					 rloc[i]=0.0;
				 }

				 // Сборка локальных матриц размерности 4x4.
                 // Прямоугольный элемент.
                 // ie - номер элемента,
                 // btimedep - нестационарный (true), стационарный (false).
                 // Свойства материалов храняться в позициях отличных от центров контрольных объёмов,
                 // а конкретно храняться в центрах квадратных ячеек сетки (связи контрольных объёмов).
                 // Таким образом материалы храняться с учётом естественных границ расчётной области, что очень важно.
                 // Rho - коэффициент перед нестационарным членом, 
                 // Gam - коэффициент диффузии.
                 // ishconvection - схема аппроксимации конвективного члена.
                 // Sc, Sp - аппроксимация источникового члена, (их нужно приписывать к вершинам ячейки т.е. они должны хранится в тех же точках что и вектор potent).
                 // dtau - шаг по времени.
                 // iVar - переменная для которой составляется дискретный аналог.
                 my_elmatr_quad(ie, btimedep,
	                1.0, epsilon_export[ie],
					ishconvection,
					Sc1,Sc2,Sc3,Sc4, Sp,
					dtau, 
					nve, xexport, yexport,
					nvtx_export,  u_export,
					aelm, rloc);

				

				    bool bsecond_member_of_equation=true; // собираем также и правую часть.
                    // Включение одиночных матричных элементов (aelm, rloc)
                    // в глобальную матрицу сглаживателя Гаусса-Зейделя и 
                    // (если bsecond_member_of_equation=true) правую часть.
                    // Используются следующие данные: nve, nvtx, constr, potent,
                    // rthdsd, rloc, aelm.
                    // Нужно сделать так чтобы было как можно меньше данных с глобальной областью видимости.
                    elembdSeidelMatrix(ie, bsecond_member_of_equation,
	                    seidel_matrix, 
						nvtx_export, nve, 
						aelm, u_export,
						constr,
						rthdsd_gl, rloc);

			 }
            



			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				     // SORDirichlet(u, rthdsd, A, URF, M, N);
					  solve_puas(seidel_matrix, 
	                          maxnode, rthdsd_gl,
				              u_export, URF);

			       
					 
                 }
				 //Ilyin1985quick(u, rthdsd, A, M, N, iend);
				 
				 // Обратное копирование.
				 icountnum=0; // счётчик вершин
	             for (int j=0; j<=j1; j++) for (int i=0; i<M+2; i++)  {
		             u[i][j]=u_export[0][icountnum++];    
		         }
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			  if (0) {
	             // Найдём компоненты скорости не ограниченной сверху они соноправлены градиету потенциала :
	             calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			     for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
					     // Напряжённости же поля противоположны градиенту потенциала.
					     ex[i][j]=-x_vel[i][j];
					     ey[i][j]=-y_vel[i][j];
					     emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				     }
			     }
			 }
			

	         // Применение реальной полескоростной характеристики Нитрида Галлия :
			
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
					   if (vel_mag[i][j]>1.0e-30) {
	                       x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   }
					   else {
						   x_vel[i][j]=0.0;
						   y_vel[i][j]=0.0;
						   vel_mag[i][j]=0.0;
					   }
		          }
	           }
			 }

			

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			 // аппроксимация Крёмера.
			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 // Vy
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					    x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						  y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }

			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn, rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/

		

	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		    printf("%d%% %f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			// zero current
			printf("%d%% %f",100,0.0);
			break;
		}

	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

	 
	calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	
	for (int i=0; i<M+2; i++) {
	     for (int j=0; j<N+2; j++) {
		      vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		      Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
			   if (vel_mag[i][j]>1.0e-30) {
				    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
               }
			   else {
				   x_vel[i][j]=0.0;
				   y_vel[i][j]=0.0;
				   vel_mag[i][j]=0.0;
				}
	         
		 }
	}	 


	  

	if (1) {
			  // найдём токи Сверено с Федотовым стр. 648.
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	    exporttecplotMESFET3(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N,maxnode,maxelm,xexport,yexport,nvtx_export,u_export[0]);
	
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		printf("Not Found and open file task.txt\n");
		// данные записаны не будут
	}
	else {
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		fclose(fp);
	}
	
	// Освобождение оперативной памяти.
	
	for (int i=0; i<nve; i++) delete aelm[i];
	delete aelm;
	delete rloc;
	// Освобождение памяти из под матрицы Зейделя.
    free_Seidel_matrix(seidel_matrix, maxnode);
	delete xexport;
	delete yexport;
	delete constr;
	for (int i=0; i<3; i++) {
		delete u_export[i];
	}
	delete u_export;
	delete rthdsd_gl;
	delete rthdsd_gl_internal;

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	getchar();

} // startMESFETGaN_obkladkaAquick


// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Нитрид Галлия.
void startMESFETGaN_VAX() {

    inithashtable(); // инициализация хэш  таблицы.


	// V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.

	
	
	FILE *fp;
	errno_t err1;
	
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}
	
	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
#if MY_FLOAT
	xf[ifound]=xf[ifound-1]+0.5f*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5f*(xf[ifound+2]-xf[ifound+1]);
#else
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);
#endif
	


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы:
	const Real epsilonGaN=9.5;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	//const Real mu_GaAs=4966.999; // подвижность электронов в кремнии. 
	
	// подвижность в нитриде Галлия
	const Real mu_GaN=electron_mobility_GaN(Tamb, Nd);
	Real K1=elementary_q/epsilon0/epsilonGaN;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_GaN*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaN*epsilon0/(elementary_q*Nd*mu_GaN); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//не менее 18400 шагов по времени с tau=2.0*tauM; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ для потенциала
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N); // выделение памяти под матрицу потенциала.
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;

	FILE *fpvax;
	errno_t err2;

	if ((err2=fopen_s(&fpvax,"vetka.txt","r"))!=0) {
		printf("Not Found and open file vekta.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {

		if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		     printf("Not Found and open file task.txt\n");
		     // данные записаны не будут
	     }
	     else {

			 int dincount=0;
			 fscanf_s(fpvax, "%d", &dincount);
		
			 for (int ivd=0; ivd<dincount; ivd++) {

				 float fin;
				 fscanf_s(fpvax, "%f", &fin);
				 ud=fin;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				      SORDirichlet(u, rthdsd, A, URF, M, N);
					 
                 }
				 //Ilyin1985quick(u, rthdsd, A, M, N, iend);
				 
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			 if (0) {
	             // Найдём компоненты скорости не ограниченной сверху они соноправлены градиету потенциала :
	             calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			     for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
					     // Напряжённости же поля противоположны градиенту потенциала.
					     ex[i][j]=-x_vel[i][j];
					     ey[i][j]=-y_vel[i][j];
					     emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				     }
			     }
			 }
			

	         // Применение реальной полескоростной характеристики Нитрида Галлия :
			
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
					   if (vel_mag[i][j]>1.0e-30) {
	                       x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   }
					   else {
						   x_vel[i][j]=0.0;
						   y_vel[i][j]=0.0;
						   vel_mag[i][j]=0.0;
					   }
		          }
	           }
			 }

			

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			 // аппроксимация Крёмера.
			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 // Vy
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			
			 /* Первоначальный стабильно работающий вариант не использующий хэш таблицу.
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					    x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						  y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }
			 */

			 //Вариант работающий с использованием хэш таблицы.
			  //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 
					 if (velmag_loc>1.0e-30) {
						 x_vel_face_we[i][j]=x_vel_face_we[i][j]*GaNDriftVel(velmag_loc, Nd, Tamb);
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=y_vel_face_sn[i][j]*GaNDriftVel(velmag_loc, Nd, Tamb);
					 }
					 else {
						  y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }

			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn, rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

#if MY_FLOAT
			 for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0f;
			     	 rthdsd_internaln[i][j]=0.0f;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0f*0.25f*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0f*0.25f*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0f-alpha)*n_oldi[i][j];
		         }
		     }
#else
            for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
#endif

		     
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/

		

	

		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		    printf("%d%% %f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			// zero curent
			printf("%d%% %f",100,0.0);
			break;
		}

	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

	 
	calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	
	for (int i=0; i<M+2; i++) {
	     for (int j=0; j<N+2; j++) {
		      vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		      Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
			   if (vel_mag[i][j]>1.0e-30) {
				    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
               }
			   else {
				   x_vel[i][j]=0.0;
				   y_vel[i][j]=0.0;
				   vel_mag[i][j]=0.0;
				}
	         
		 }
	}	 


	  

	if (1) {
			  // найдём токи Сверено с Федотовым стр. 648.
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		
	
	

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

   }

}

   }

   // закрытие файлов :
   fclose(fpvax);
   fclose(fp);


	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();

} // startMESFETGaN_VAX

void dichtomiq_kvasiField_GaN(Real mu_GaN, Real neg, Real elementary_q, Real taue, Real nu, Real Nd, Real Tamb, Real &kvasiFieldMag)
{
	// правая часть.
	Real rthdsd=0.0;
	
	
	

	Real ra=0.0;
	Real rb=8.0e10;
	Real x=ra;

	if (nu<=0.0) {
		x=0.0;
	}
	else {

		if (fabs(neg)>1.0e-17)
	    {
		    // 1e6 1e7 = 1e13
		    // 7e10 1.6e16 1e-17=1e9
		    // taue - сокращается, в терминах nu.
	       // rthdsd=nu/elementary_q/taue/neg;
			rthdsd=nu/(elementary_q*taue*neg);
	    }
		else {
			printf("error ! dichtomiq kvazifield neg is zero. %e\n",neg);
			getchar();
		}

	    while (fabs(x-0.5*(ra+rb))>1.0e-10) {

              x=0.5*(ra+rb);
			  // начинать лучше с правой границы чтобы стремиться к минимальному значению поля.
		      //  if ((rb*(mu_Si*rb/SiliconDriftVel(rb, K2))-rthdsd)*(x*(mu_Si*x/SiliconDriftVel(x, K2))-rthdsd)>0.0) {
			  if ((rb*rb*GaNDriftVel(rb,Nd,Tamb)-rthdsd)*(x*x*GaNDriftVel(x,Nd,Tamb)-rthdsd)>0.0) {
			      rb=x;
		      }
		      else {
			      ra=x;
		      }
		      // printf("rthdsd=%e %e\n",rthdsd,x);

	    }
	}
    //	getchar();

	// возвращаем найденное значение 
	kvasiFieldMag=x;

} // dichtomiq_kvasiField_GaN

// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал GaN нитрид галлия.
// Версия PARIS2 содержащее третье уравнение для энергии электронного газа.
void startMESFETGaNPARIS2()
{

	amgGM.a = NULL;
	amgGM.f = NULL;
	amgGM.ia = NULL;
	amgGM.ig = NULL;
	amgGM.ja = NULL;
	amgGM.u = NULL;
	
	inithashtable(); // обязательная инициализация hash table.

#if MY_FLOAT    
	// V
	Real ug=-1.0f; // напряжение на затворе. -1V
	Real ud=10.0f; //50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17f; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0f; // температура полупроводника.
	const Real k_bolcman=1.38066e-23f;
	Real energy_source=1.5f*k_bolcman*Tamb; // однородное граничное условие Дирихле для nu
	Real taue=1.0e-12f; // 1пс время релаксации энергии.

	// cm
	Real xendsource=2.0e-4f; // позиция конца истока.
	Real xstartgate=3.0e-4f; // позиция начала затвора
	Real xendgate=5.0e-4f; // позиция конца затвора
	Real xstartdrain=7.0e-4f; // позиция начала стока.
	lengthx=9.0e-4f; // протяжённость всей моделируемой области.
	lengthy=0.3e-4f; // высота канала.
#else
	// V
	Real ug=-8.0; // напряжение на затворе. -1V
	Real ud=101.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.
	const Real k_bolcman=1.38066e-23;
	Real energy_source=1.5*k_bolcman*Tamb; // однородное граничное условие Дирихле для nu
	Real taue=1.0e-12; // 1пс время релаксации энергии.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.
#endif
	
	
	FILE *fp;
	errno_t err1;

	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		//printf("ND=%e\n",Nd);
		//getchar();
		fclose(fp);
	}

	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестационарное моделирование.
	Real alpha_u=1.0; // решили без нижней релаксации для потенциала.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.
	Real alphanu=0.1; // нижняя релаксация для решения уравнения переноса энергии электронного газа.
	int iendnu=1; // количество итераций для решения уравнения  энергии электронного газа.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы :
	const Real epsilonGaN=9.5;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	
	
	//const Real mu_Si=700; // подвижность электронов в кремнии. 
	//const Real mu_Si=5.5e6*exp(-1.5*log(Tamb)); // подвижность электронов в кремнии. 
	// В действительности подвижность зависит также и от концентрации, поэтому :
	// подвижность зависит от концентрации и от температуры решетки.
    const Real mu_GaN=electron_mobility_GaN(Tamb, Nd); // подвижность электронов в нитриде Галлия. 
	//Real K1=3858.51; // Безразмерный комплекс.
	Real K1=elementary_q/(epsilon0*epsilonGaN);
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_GaN*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaN*epsilon0/(elementary_q*Nd*mu_GaN); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации.
	printf("GaN modelling\n");
	printf("solving is : 0.5 tauM UDS. NO artifical diffusion !\n");

	// Будем ли использовать алгебраический многосеточный метод.
	bool buse_amg1r5 = true;
	if (buse_amg1r5) {
		printf("use Algebraic Multigrid Method Fedorenko R.P. 1961 (amg1r5 code.)\n");
	}



	dtimestep=0.5*tauM;
	//dtimestep=6.0*tauM;
   // dtimestep=8000.0*tauM;
	int imaxnumbertimestep=2000; //600; // количество шагов по времени. (1500 для Win32 версии достаточно.)
	int inumberinternaliter=30; // количество итераций на временном слое.

	if (buse_amg1r5) {
		imaxnumbertimestep = 2000;
		inumberinternaliter = 1; // безитерационный
		alpha = 0.8;
		alphanu = 0.8;
	}


	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;
	int ialgnu=SEIDEL; // алгоритм для переноса энергии электронов.
	

	Real** u=NULL; // рассчитываемый потенциал.
    Real** u_old=NULL; // потенциал с предыдущей итерации.
    Real** r=NULL; // невязка
	Real** rthdsd_internal=NULL; // внутренность : правая часть
	Real** rthdsd=NULL; // правая часть.
	MATRNODE** A=NULL; // матрица СЛАУ
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n=NULL; // рассчитываемая концентрация электронов.
	Real** n_buf=NULL; // для метода Зейделя.
    Real** n_oldi=NULL; // концентрация с предыдущей итерации.
	Real** n_old=NULL; // концентрация с предыдущего временного слоя.
	Real** ux_alternative=NULL;
	Real** uy_alternative=NULL;
	Real** x_vel=NULL; // компоненты дрейфовой скорости электронов
	Real** y_vel=NULL; // по x и по y.
	Real** x_vel_face_we=NULL; // для иксовой скорости.
	Real** y_vel_face_we=NULL;
	Real** x_vel_face_sn=NULL; // для игриковой скорости. 
	Real** y_vel_face_sn=NULL;
	Real** vel_mag=NULL; // модуль скорости.
	Real** ex=NULL; // напряжённость электрического поля по x
	Real** ey=NULL; // напряжённость электрического поля по y
	Real** nx=NULL; // градиент концентрации по x.
	Real** ny=NULL; // градиент концентрации по y.
    Real** emag=NULL; // модуль напряжённости электрического поля.
	Real** curent_x=NULL; // ток по икс.
	Real** curent_y=NULL; // ток по y
	Real** curent_mag=NULL; // модуль тока.	
	Real** rn=NULL; // невязка
	Real** rthdsd_internaln=NULL; // внутренность : правая часть
	Real** rthdsdn=NULL; // правая часть.
	MATRNODE** An=NULL; // матрица СЛАУ
	Real** nu=NULL; // здесь nu есть функция от энергии электронного газа : nu=n*(u-energy_source)/taue;
	Real** nu_oldi=NULL; // nu с предыдущей итерации.
	Real** nu_old=NULL; // nu с предыдущего временного слоя.
	Real** rthdsdnu=NULL; // правая часть для nu.
	Real** rnu=NULL; 
	Real** rthdsd_internalnu=NULL;
	MATRNODE** Anu=NULL; // матрица СЛАУ для nu.
	Real** kvasiFieldMag=NULL; // квазиполе. 
	Real** energy_mobility=NULL; // подвижность зависящая от энергии и определяемая через квазиполе.
	Real** energy_K300Dn=NULL; // коэффициент диффузии завиящий от подвижности.

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v=NULL;
    Real** v_old=NULL;
    Real** r_coarse=NULL;
	Real** rthdsd_c=NULL; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al=NULL; // матрица СЛАУ

	// для алгебраического многосеточного метода:
	Real *dX0 = new Real[(M+2)*(N+2)];

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	TBONCONDOMAIN my_boundnu; // Граничные условия для энергии.
	printf("compleate tolerance source drain gate out \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_bound(my_boundnu,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N);
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	// Альтернативное вычисление полескоростной характеристики,
	// более экономичное по количеству арифметических операций.
	my_alloc_universal(ux_alternative, M, N);
	my_alloc_universal(uy_alternative, M, N);
	my_alloc_universal(energy_mobility, M, N); // подвижность зависящая от энергии и определяемая через квазиполе.
	my_alloc_universal(energy_K300Dn, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(kvasiFieldMag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);
	// Выделение памяти под энергию электронного газа.
	my_alloc(nu, nu_oldi, rnu, rthdsdnu, Anu, M, N);
	//my_alloc_universal(nu, M, N);
	my_alloc_universal(nu_old, M, N);
	//my_alloc_universal(nu_oldi, M, N);
	//my_alloc_universal(rthdsdnu, M, N);
	//my_alloc_universal(rnu, M, N);
	my_alloc_universal(rthdsd_internalnu, M, N);


	//my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, Nd, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);

	// инициализация функции, выраженной через энергию.
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, nu, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, nu_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, nu_oldi, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, rnu, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, rthdsdnu, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, rthdsd_internalnu, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	FILE *fp_statistic=NULL;
	errno_t err_stat;

	if ((err_stat=fopen_s(&fp_statistic,"statistic.txt","w"))!=0) {
		printf("Not Found and open file statistic.txt\n");
		getchar();
		exit(0);
	}
	else {
		if (fp_statistic != NULL) {


			fprintf_s(fp_statistic, "0 \n");
			fprintf_s(fp_statistic, "0 \n");
			fprintf_s(fp_statistic, "Statistic convergence for IDDM \n");
			fprintf_s(fp_statistic, "iter source drain gate out \n");

			TBONCONDOMAIN my_bound_coarse; // Граничные условия
			// Выделение памяти под граничные условия.
			my_alloc_bound(my_bound_coarse, MC, NC);
			my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

			bool bminus = false;

			int compleate = 0;
			printf("%d%%", compleate);

			const bool iddm_Garber = true;

			Real time = 0.0;

			for (int inumbertimestep = 0; inumbertimestep < imaxnumbertimestep; inumbertimestep++) {
				// самый внешний цикл шаги по времени.

				time += dtimestep;

				int iter = 0;
				while (iter < inumberinternaliter)
				{

					//**
					//*****
					// Решение уравнения для электрического потенциала в кремнии.
					//*****
					//**

					// Шаблоны для граничных условий.
					// load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);



				   // геометрия неизменна и свойства материалов постоянны
				   // поэтому матрица собирается только один раз перед началом счёта.
				   //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
					if (bflagconstrA) {
						constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
						for (int i = 1; i < M + 1; i++) {
							for (int j = 1; j < N + 1; j++) {
								// A[i][j].ap/=alpha_u;				                        

							}
						}
						bflagconstrA = false;
					}

					for (int i = 1; i < M + 1; i++) {
						for (int j = 1; j < N + 1; j++) {
							r[i][j] = 0.0;
							//rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
						  // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
							rthdsd_internal[i][j] = (K1Nd - K1*n[i][j])*0.25*(xf[i + 1] - xf[i - 1])*(yf[j + 1] - yf[j - 1]);
							// нижняя релаксация для потенциала
							//rthdsd_internal[i][j]+=A[i][j].ap*(1.0-alpha_u)*u[i][j];
						}
					}



					/*
					if (btimedepend) {
						// нестационарный солвер.
						for (int i=1; i<M+1; i++) {
							for (int j=1; j<N+1; j++) {
								A[i][j].ap+=1.0*h1*h2/dtimestep;
								rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
							}
						}
					}
					*/

					//  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
					constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);
					// bound_relax(, inumbertimestep);
				   // constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, bound_relax(ug, inumbertimestep), bound_relax(ud, inumbertimestep), xendsource, xstartgate, xendgate, xstartdrain);




					/*if (inumbertimestep>40) {
					exporttecplot(rthdsd,xf,yf,M,N);
					}*/

					if (1)
					{
						// Простейший алгоритм.

						if (buse_amg1r5) {
							//amg_loc_memory(u, rthdsd, A, M, N, 0, dX0);
							amg_global_memory(u, rthdsd, A, M, N, 0, dX0);
						}
						else {

							// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
							for (int i = 0; i < iend; i++) {
								// Метод Гаусса, Зейделя, Ричардсона, Либмана
							   // Seidel(u, rthdsd, A, M, N);
								// метод последовательной верхней релаксации с коэффициентом 1.855.
								Real URF = 1.855;
								SORDirichlet(u, rthdsd, A, URF, M, N);
							}
						}


					}
					else
					{
						// Алгоритм Р.П. Федоренко.
						load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
						constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
						load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

						// Для вспомогательной системы имеем однородные граничные условия.
						my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);

						// геометрия неизменна и свойства материалов постоянны
						// поэтому матрица собирается только один раз перед началом счёта.
						constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.

						for (int i = 0; i < MC + 2; i++) {
							for (int j = 0; j < NC + 2; j++) {
								r_coarse[i][j] = 0.0;
								rthdsd_c[i][j] = 0.0*0.25*(xc[i + 1] - xc[i - 1])*(yc[j + 1] - yc[j - 1]);
							}
						}
						Real *residual_history = new Real[iend + 1];
						for (int i = 0; i < iend; i++) {
							residual_history[i] = 1.0; // инициализация.
						}
						itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old, r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5, residual_history);
						// нормированная октаэдрическая норма (сумма модулей).
						for (int i = 1; i < iend; i++) {
							residual_history[i] = residual_history[i] / residual_history[0];
						}
						residual_history[0] = 1.0;

						for (int i = 0; i < iend; i++) {
							//printf("  %d   %1.4e  \n",i+1,residual_history[i]);
						}
						delete residual_history;


					}
					// exporttecplot(u,xf,yf,M,N);

					 //**
					 //*****
					 // Решение уравнения для концентрации электронов в кремнии.
					 //*****
					 //**


					 // Обязательно нужный кусок кода !!!
					 // Найдём компоненты скорости не ограниченные сверху они соноправлены градиенту потенциала :
					calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);

					for (int i = 0; i < M + 2; i++) {
						for (int j = 0; j < N + 2; j++) {
							// Напряжённости поля противоположны градиенту потенциала.
							ex[i][j] = -x_vel[i][j];
							ey[i][j] = -y_vel[i][j];
							emag[i][j] = sqrt(sqr(ex[i][j]) + sqr(ey[i][j]));
						}
					}



					// Применение реальной полескоростной характеристики Нитрида Галлия :
					if (0) {
						for (int i = 0; i < M + 2; i++) {
							for (int j = 0; j<N + 2; j++) {
								vel_mag[i][j] = sqrt(sqr(x_vel[i][j]) + sqr(y_vel[i][j]));
								Real velocity_magnitude = Field_velocity_mag(vel_mag[i][j], Tamb, Nd);
								if (vel_mag[i][j]>1.0e-30) {
									x_vel[i][j] = (x_vel[i][j] / vel_mag[i][j])*velocity_magnitude;
									y_vel[i][j] = (y_vel[i][j] / vel_mag[i][j])*velocity_magnitude;
									vel_mag[i][j] = sqrt(sqr(x_vel[i][j]) + sqr(y_vel[i][j]));
								}
								else {
									x_vel[i][j] = 0.0;
									y_vel[i][j] = 0.0;
									vel_mag[i][j] = 0.0;
								}
							}
						}
					}



					//exporttecplot(x_vel,xf,yf,M,N);
					//exporttecplot(y_vel,xf,yf,M,N);

					 /* Отладочная проверка.
					 for (int i=0; i<M+2; i++) {
						for (int j=0; j<N+2; j++) {
							u[i][j]=yf[j]; // xf[i];
						}
					 }
					 */


					 // В данном варианте поддерживаются скорости на двух сетках:
					 // На первой сетке скорость хранится на фейсах смещённых по x на пол ячейки.
					 // На второй сетке скорость хранится на фейсах смещенных по y на пол ячейки.

					// компоненты скорости на шахматной сетке
					// Компоненты скорости соноправлены с градиентом потенциала,
					// в то время как напряжённость электрического поля направлена строго противоположно.
					// Vx Vy
					universalgradx(u, x_vel_face_we, xf, M, N);
					universalgrady(u, y_vel_face_sn, yf, M, N);
					universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
					universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);



					/*
					// Рабочий вариант до использования hash table.
					// Полескоростная характеристика сверенная с ЗИ:
					// Vx
					for (int i=0; i<M+1; i++) {
						for (int j=0; j<N+2; j++) {
							Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
							Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
							if (velmag_loc>1.0e-30) {
								x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
							}
							else {
								x_vel_face_we[i][j]=0.0;
							}

						}
					}
					// Vy
					for (int i=0; i<M+2; i++) {
						for (int j=0; j<N+1; j++) {
							Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
							Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
							if (velmag_loc>1.0e-30) {
								x_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
							}
							else {
								y_vel_face_sn[i][j]=0.0;
							}

						}
					}
					*/


					// Вариант с использованием хэш таблицы.
					// Полескоростная характеристика сверенная с ЗИ:
					/*
					// Vx
					for (int i=0; i<M+1; i++) {
						for (int j=0; j<N+2; j++) {
							 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));

							 if (velmag_loc>1.0e-30) {
								 x_vel_face_we[i][j]=x_vel_face_we[i][j]*GaNDriftVel(velmag_loc, Nd, Tamb);
							 }
							 else {
								x_vel_face_we[i][j]=0.0;
							 }

						}
					}
					// Vy
					for (int i=0; i<M+2; i++) {
						for (int j=0; j<N+1; j++) {

							Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));

							 if (velmag_loc>1.0e-30) {
								 y_vel_face_sn[i][j]=y_vel_face_sn[i][j]*GaNDriftVel(velmag_loc, Nd, Tamb);
							 }
							 else {
								y_vel_face_sn[i][j]=0.0;
							 }

						}
					}
					*/

					// модель Г.З. Гарбера.
					// если iddm_Garber



					for (int i = 0; i < M + 2; i++) {
						for (int j = 0; j < N + 2; j++) {
							Real keyEmag = kvasiFieldMag[i][j];
							Real Emag_loc = sqrt(sqr(x_vel[i][j]) + sqr(y_vel[i][j]));

							if (!iddm_Garber) {
								if (Emag_loc < 1.0e2) {
									energy_mobility[i][j] = mu_GaN;
								}
								else {
									// эффект насыщения скорости дрейфа при больших полях.
									energy_mobility[i][j] = GaNDriftVel(Emag_loc, Nd, Tamb);
								}
							}

							if (iddm_Garber) {
								if (nu[i][j] <= 0.0) {
									// обычная подвижность, та которая используется в диффузионно дрейфовой модели.
									if (Emag_loc < 1.0e2) {
										energy_mobility[i][j] = mu_GaN;
									}
									else {
										// эффект насыщения скорости дрейфа при больших полях.
										energy_mobility[i][j] = GaNDriftVel(Emag_loc, Nd, Tamb);
									}
								}
								else {

									// Подвижность вычисляется на основе квазипеоля при любом Emag_loc.
									if (fabs(keyEmag) < 100.0) {
										// Слабое квазиполе обычная подвижность при слабых полях.
										energy_mobility[i][j] = mu_GaN;
									}
									else {
										// Сильные квазиполя подвижность вычисленная по модулю квазиполя с учётом насыщения.
										energy_mobility[i][j] = GaNDriftVel(keyEmag, Nd, Tamb);
									}

									/*
									// Этот вариант перемудрён, слишком надуман, см разговор с Гарбером.
									if (Emag_loc<100.0) {
										// малые поля : скорость дрейфа пропорциональна градиенту потенциала.
										  energy_mobility[i][j]=mu_GaN;
									}
									else {
										if (fabs(keyEmag)<100.0) {
											// малые значения квазиполя.
											// переходим к ДДМ модели.
											//Real keychangeE2F=fabs(keyEmag)/Emag_loc;
											//energy_mobility[i][j]=mu_GaN*keychangeE2F;
											energy_mobility[i][j]=GaNDriftVel(Emag_loc, Nd, Tamb);
										}
										else {
											// Нельзя подставлят напряженность поля вместо квазполя, скорости дрейфа будут превышать vsaturation.
											// С другой стороны скорости могут быть боьше чем скорости дрейфа в равновесном состояни (при коротких затворах)
											// Явление overshoot но это только при высоких температурах электронного газа.
											//Real keychangeE2F=fabs(keyEmag)/Emag_loc;
											//energy_mobility[i][j]=(GaNDriftVel(keyEmag, Nd, Tamb)*keychangeE2F));
											// С другой стороны в выражении для тока фигурирует именно напряженность электрического поля
											// А от скалярной величины (квазиполе) зависит лишь скалярная величина подвижность и
											energy_mobility[i][j]=GaNDriftVel(keyEmag, Nd, Tamb);
										}
									}
									*/
								}
							}

							energy_K300Dn[i][j] = k_bolcman*Tamb*energy_mobility[i][j] / elementary_q;
						}
					}


					// Дрейфовая скорость может быть и больше скорости насыщения, 
					// это так называемый overshoot в квазигидродинамической модели Г.З. Гарбера.

					// Vx
					for (int i = 0; i < M + 1; i++) {
						for (int j = 0; j < N + 2; j++) {

							Real mobil;
							if (fabs((energy_mobility[i][j] + energy_mobility[i + 1][j])) < 1.0e-3) {
								mobil = 0.5*(energy_mobility[i][j] + energy_mobility[i + 1][j]);
							}
							else {
								mobil = 2.0*(energy_mobility[i][j] * energy_mobility[i + 1][j]) / (energy_mobility[i][j] + energy_mobility[i + 1][j]);
							}
							// универсальная форма записи, подходит как для малых так и для больших полей, все хранится в подвижности.
							// одинаково подхлодит как для модели Гарбера так и для обычной ДДМ.
							x_vel_face_we[i][j] *= mobil;
							y_vel_face_we[i][j] *= mobil;

						}
					}
					// Vy			 
					for (int i = 0; i < M + 2; i++) {
						for (int j = 0; j < N + 1; j++) {

							Real mobil;
							if (fabs((energy_mobility[i][j] + energy_mobility[i][j + 1])) < 1.0e-3) {
								mobil = 0.5*(energy_mobility[i][j] + energy_mobility[i][j + 1]);
							}
							else {
								mobil = 2.0*(energy_mobility[i][j] * energy_mobility[i][j + 1]) / (energy_mobility[i][j] + energy_mobility[i][j + 1]);
							}


							// универсальная форма записи, подходит как для малых так и для больших полей, все хранится в подвижности.
							// одинаково подхлодит как для модели Гарбера так и для обычной ДДМ.
							y_vel_face_sn[i][j] *= mobil;
							x_vel_face_sn[i][j] *= mobil;

						}
					}





					//exporttecplotx(x_vel_face_we,xf,yf,M,N);
					//exporttecploty(y_vel_face_sn,xf,yf,M,N);

					if (0)
					{
						// найдём токи
						calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
						for (int i = 0; i < M + 2; i++) {
							for (int j = 0; j < N + 2; j++) {
								curent_x[i][j] = K300Dn*nx[i][j] - n[i][j] * x_vel[i][j];
								curent_y[i][j] = K300Dn*ny[i][j] - n[i][j] * y_vel[i][j];
								curent_mag[i][j] = sqrt(curent_x[i][j] * curent_x[i][j] + curent_y[i][j] * curent_y[i][j]);
							}
						}
					}

					// Непосредственное решение уравнения.

					// Загружаем граничные условия:
					//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
				   //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
				   //load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn,rthdsdn, M, N); 
				   //load_my_bound_n3(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn,rthdsdn, M, N);
					// без противопоточного ограничителя на диагональное преобладание в ap.
				   //load_my_bound_n5(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn,rthdsdn, M, N);
				   // содержит дополнительную нижнюю релаксацию для условия ток равен нулю.
				   //load_my_bound_n6(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn,rthdsdn,alpha,n, M, N);
					load_my_bound_n7(my_boundn, xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, energy_K300Dn, rthdsdn, M, N);

					//constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
				   // constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
				   //constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);	
					constrAPatankarMESFET3(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, energy_K300Dn, xf, yf, M, N);

					for (int i = 0; i < M + 2; i++) {
						for (int j = 0; j < N + 2; j++) {
							// инициализация рассчитываемых величин.
							n_oldi[i][j] = n[i][j];
						}
					}

					for (int i = 1; i < M + 1; i++) {
						for (int j = 1; j < N + 1; j++) {
							// правая часть :
							rn[i][j] = 0.0;
							rthdsd_internaln[i][j] = 0.0;
						}
					}

					if (btimedepend) {
						// нестационарный солвер.
						for (int i = 1; i < M + 1; i++) {
							for (int j = 1; j < N + 1; j++) {
								An[i][j].ap += 1.0*0.25*(xf[i + 1] - xf[i - 1])*(yf[j + 1] - yf[j - 1]) / dtimestep;
								rthdsd_internaln[i][j] += 1.0*0.25*(xf[i + 1] - xf[i - 1])*(yf[j + 1] - yf[j - 1])*n_old[i][j] / dtimestep;
							}
						}
					}

					// нижняя релаксация для концентрации.

					for (int i = 1; i < M + 1; i++) {
						for (int j = 1; j < N + 1; j++) {
							An[i][j].ap /= alpha;
							rthdsd_internaln[i][j] += An[i][j].ap*(1.0 - alpha)*n_oldi[i][j];
						}
					}



					// constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
					constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.



					// невязка :
				   // residual(rn, n, rthdsdn,  An, M, N);
				   //printf("%e\n",normar(r, M, N));
				   //getchar();

				   // exporttecplot(rthdsdn, xf,  yf, M, N);
					//getchar();

					// Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
					for (int i = 1; i < M + 1; i++) {
						An[i][0].ap /= alpha;
						rthdsdn[i][0] += An[i][0].ap*(1.0 - alpha)*n_oldi[i][0];
					}
					for (int j = 1; j < N + 1; j++) {
						An[0][j].ap /= alpha;
						rthdsdn[0][j] += An[0][j].ap*(1.0 - alpha)*n_oldi[0][j];
						An[M + 1][j].ap /= alpha;
						rthdsdn[M + 1][j] += An[M + 1][j].ap*(1.0 - alpha)*n_oldi[M + 1][j];
					}

					for (int i = 1; i < M + 1; i++) {
						if ((xf[i] >= xendsource) && (xf[i] <= xstartdrain)) {
							An[i][N + 1].ap /= alpha;
							rthdsdn[i][N + 1] += An[i][N + 1].ap*(1.0 - alpha)*n_oldi[i][N + 1];
						}
					}


					// решение СЛАУ:

					// запоминаем поле с предыдущей итерации.
					// данный итерационный процесс требует в два раза больше памяти.
					//for (int i=0; i<iendn; i++) {
					   /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
					//	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
					//}
					if (buse_amg1r5) {
						//amg_loc_memory(n, rthdsdn, An, M, N, 1, dX0);
						amg_global_memory(n, rthdsdn, An, M, N, 1, dX0);
					}
					else {

						//itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
						for (int i = 0; i < iendn; i++) {
							Seidel(n, rthdsdn, An, M, N);
						}
					}

					// exporttecplot(n,xf,yf,M,N);


					// Решение  уравнения переноса энергии электронного газа.


					//load_my_bound_nu2(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, K300Dn, rthdsdnu, M, N); 
					//load_my_bound_nu3(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, M, N); 
					// без противопоточного ограничителя на диагональное преобладание в ap.
					//load_my_bound_nu5(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, M, N); 
					// содержит дополнительную нижнюю релаксацию для условия ток равен нулю.
					//load_my_bound_nu6(my_boundnu,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, alphanu, nu, M, N); 
					load_my_bound_nu7(my_boundnu, xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, elementary_q, taue, emag, x_vel_face_sn, y_vel_face_we, energy_source, xf, yf, energy_K300Dn, rthdsdnu, M, N);




					// constrAPatankarMESFET2(Anu, my_boundnu, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				
					constrAPatankarMESFET3(Anu, my_boundnu, x_vel_face_we, y_vel_face_sn, 1.0, energy_K300Dn, xf, yf, M, N);



					for (int i = 0; i < M + 2; i++) {
						for (int j = 0; j < N + 2; j++) {
							// инициализация рассчитываемых величин.
							nu_oldi[i][j] = nu[i][j];
						}
					}

					calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
					for (int i = 1; i < M + 1; i++) {
						for (int j = 1; j < N + 1; j++) {
							// невязка.
							rnu[i][j] = 0.0;
							// правая часть.
							// плотности токов.
						   // Real jx=K300Dn*nx[i][j]-n[i][j]*0.5*(x_vel_face_we[i-1][j]+x_vel_face_we[i][j]);
						   // Real jy=K300Dn*ny[i][j]-n[i][j]*0.5*(y_vel_face_sn[i][j-1]+y_vel_face_sn[i][j]);
							Real jx = energy_K300Dn[i][j] * nx[i][j] - n[i][j] * 0.5*(x_vel_face_we[i - 1][j] + x_vel_face_we[i][j]);
							Real jy = energy_K300Dn[i][j] * ny[i][j] - n[i][j] * 0.5*(y_vel_face_sn[i][j - 1] + y_vel_face_sn[i][j]);
							// мощность тепловыделения и диссипация.
							rthdsd_internalnu[i][j] = (elementary_q*(ex[i][j] * jx + ey[i][j] * jy) - nu[i][j] / taue)*0.25*(xf[i + 1] - xf[i - 1])*(yf[j + 1] - yf[j - 1]);
						}
					}

					if (btimedepend) {
						// нестационарный солвер.
						for (int i = 1; i < M + 1; i++) {
							for (int j = 1; j < N + 1; j++) {
								Anu[i][j].ap += 1.0*0.25*(xf[i + 1] - xf[i - 1])*(yf[j + 1] - yf[j - 1]) / dtimestep;
								rthdsd_internalnu[i][j] += 1.0*0.25*(xf[i + 1] - xf[i - 1])*(yf[j + 1] - yf[j - 1])*nu_old[i][j] / dtimestep;
							}
						}
					}

					// нижняя релаксация для концентрации.

					for (int i = 1; i < M + 1; i++) {
						for (int j = 1; j < N + 1; j++) {
							Anu[i][j].ap /= alphanu;
							rthdsd_internalnu[i][j] += Anu[i][j].ap*(1.0 - alphanu)*nu_oldi[i][j];
						}
					}

					constrrthdsd0MESFETnu(rthdsdnu, rthdsd_internalnu, my_boundnu, xf, yf, M, N); // правая часть.


					// Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
					for (int i = 1; i < M + 1; i++) {
						Anu[i][0].ap /= alphanu;
						rthdsdnu[i][0] += Anu[i][0].ap*(1.0 - alphanu)*nu_oldi[i][0];
					}
					for (int j = 1; j < N + 1; j++) {
						Anu[0][j].ap /= alphanu;
						rthdsdnu[0][j] += Anu[0][j].ap*(1.0 - alphanu)*nu_oldi[0][j];
						Anu[M + 1][j].ap /= alphanu;
						rthdsdnu[M + 1][j] += Anu[M + 1][j].ap*(1.0 - alphanu)*nu_oldi[M + 1][j];
					}

					for (int i = 1; i < M + 1; i++) {
						if ((xf[i] >= xendsource) && (xf[i] <= xstartdrain)) {
							Anu[i][N + 1].ap /= alphanu;
							rthdsdnu[i][N + 1] += Anu[i][N + 1].ap*(1.0 - alphanu)*nu_oldi[i][N + 1];
						}
					}


					if (buse_amg1r5) {
						// Мы используем алгебраический многосеточный метод.
						//amg_loc_memory(nu, rthdsdnu, Anu, M, N, 2, dX0);
						amg_global_memory(nu, rthdsdnu, Anu, M, N, 2, dX0);
					}
					else {

						for (int i = 0; i < iendnu; i++) {
							Seidel(nu, rthdsdnu, Anu, M, N);
						}
					}

					// минимальное значение nu во внутренности.
					Real nu_min_internal = 1.0e30;
					for (int i = 1; i < M + 1; i++) {
						for (int j = 1; j < N + 1; j++) {
							if (nu[i][j] < nu_min_internal) {
								nu_min_internal = nu[i][j];
							}
						}
					}

					// Находим квазиполе:
					for (int i = 0; i < M + 2; i++) {
						for (int j = 0; j < N + 2; j++) {
							// Мы решим нелинейное уравнение методом половинного деления.
							/*
							if ((j==N+1)&&(xf[i]<=xendsource)) {
								// Нулевое nu
								dichtomiq_kvasiField_GaN(mu_GaN, n[i][j], elementary_q, taue, nu_min_internal, Nd, Tamb, kvasiFieldMag[i][j]);
							}
							else {
								dichtomiq_kvasiField_GaN(mu_GaN, n[i][j], elementary_q, taue, nu[i][j], Nd, Tamb, kvasiFieldMag[i][j]);
							}*/
							dichtomiq_kvasiField_GaN(mu_GaN, n[i][j], elementary_q, taue, nu[i][j], Nd, Tamb, kvasiFieldMag[i][j]);
						}
					}


					// Переход к следующей итерации.
					iter++;



				}

				//exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				//	 getchar();


			   // Запоминание концентрации с предыдущего временного слоя.
				for (int i = 0; i < M + 2; i++) {
					for (int j = 0; j < N + 2; j++) {
						n_old[i][j] = n[i][j];
						nu_old[i][j] = nu[i][j];
					}
				}

				// экспорт результата в программу tecplot.
			  /*if (inumbertimestep%20==0) {
						exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

					   getchar();
			  }*/


				Real idrain_loc = 0.0;   // ток стока.
				Real isource_loc = 0.0; // ток истока.
				Real igate_loc = 0.0;  // ток затвора.
				Real iout_loc = 0.0;  // ток через внешний контур.
				for (int i = 1; i < M + 1; i++) {
					if (xf[i] < xendsource) {
						isource_loc += ((2.0*energy_K300Dn[i][N] * energy_K300Dn[i][N + 1] / (energy_K300Dn[i][N] + energy_K300Dn[i][N + 1]))*(n[i][N + 1] - n[i][N]) / (yf[N + 1] - yf[N]) - 0.5*(n[i][N + 1] + n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i + 1] - xf[i - 1]);
						// isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
					}
					if (xf[i] > xstartdrain) {
						idrain_loc += ((2.0*energy_K300Dn[i][N] * energy_K300Dn[i][N + 1] / (energy_K300Dn[i][N] + energy_K300Dn[i][N + 1]))*(n[i][N + 1] - n[i][N]) / (yf[N + 1] - yf[N]) - 0.5*(n[i][N + 1] + n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i + 1] - xf[i - 1]);
						//idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
					}
					if ((xf[i] > xstartgate) && (xf[i] < xendgate)) {
						//igate_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
						igate_loc += fabs(((2.0*energy_K300Dn[i][N] * energy_K300Dn[i][N + 1] / (energy_K300Dn[i][N] + energy_K300Dn[i][N + 1]))*(n[i][N + 1] - n[i][N]) / (yf[N + 1] - yf[N]) - 0.5*(n[i][N + 1] + n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i + 1] - xf[i - 1]));
					}
					if (((xf[i] >= xendsource) && (xf[i] <= xstartgate)) || ((xf[i] >= xendgate) && (xf[i] <= xstartdrain))) {
						iout_loc += fabs(((2.0*energy_K300Dn[i][N] * energy_K300Dn[i][N + 1] / (energy_K300Dn[i][N] + energy_K300Dn[i][N + 1]))*(n[i][N + 1] - n[i][N]) / (yf[N + 1] - yf[N]) - 0.5*(n[i][N + 1] + n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i + 1] - xf[i - 1]));
					}
					iout_loc += fabs(((2.0*energy_K300Dn[i][0] * energy_K300Dn[i][1] / (energy_K300Dn[i][0] + energy_K300Dn[i][1]))*(n[i][1] - n[i][0]) / (yf[1] - yf[0]) - 0.5*(n[i][1] + n[i][0])*y_vel_face_sn[i][0])*0.5*(xf[i + 1] - xf[i - 1]));
				}
				for (int j = 1; j<N + 1; j++) {
					iout_loc += fabs(((2.0*energy_K300Dn[0][j] * energy_K300Dn[1][j] / (energy_K300Dn[0][j] + energy_K300Dn[1][j]))*(n[1][j] - n[0][j]) / (xf[1] - xf[0]) - 0.5*(n[1][j] + n[0][j])*x_vel_face_we[0][j])*0.5*(yf[j + 1] - yf[j - 1]));
					iout_loc += fabs(((2.0*energy_K300Dn[M + 1][j] * energy_K300Dn[M][j] / (energy_K300Dn[M + 1][j] + energy_K300Dn[M][j]))*(n[M + 1][j] - n[M][j]) / (xf[M + 1] - xf[M]) - 0.5*(n[M + 1][j] + n[M][j])*x_vel_face_we[M][j])*0.5*(yf[j + 1] - yf[j - 1]));
				}
				if (0.5*(fabs(isource_loc) + fabs(idrain_loc))>1.0e-14) {
					Real diviation = 10.0;
					if ((fabs(isource_loc) > 1.0e-20) && (fabs(idrain_loc) > 1.0e-20)) {
						if (fabs(isource_loc) > fabs(idrain_loc)) {
							diviation = fabs(idrain_loc) / fabs(isource_loc);
						}
						else {
							diviation = fabs(isource_loc) / fabs(idrain_loc);
						}
					}
					if ((fabs(isource_loc + idrain_loc) / (0.5*(fabs(isource_loc) + fabs(idrain_loc))) < 0.005) && ((diviation<1.1) && (diviation>0.9))) {
						// досрочное прекращение вычислений
						 //inumbertimestep=imaxnumbertimestep+1;
						 //  break;
						printf("diviation=%e", diviation);
						//getchar();
					}
				}
				else {
					// возможно нулевой ток.
					//if (inumbertimestep>70) break;
					printf("zero current");
					getchar();
				}



				// показывает процент выполнения расчёта.
				if (compleate < 10) {
					printf("\b\b");
					printf("\b\b\b\b\b\b\b\b\b");
					printf("\b\b\b\b\b\b\b\b\b");
					printf("\b\b\b\b\b\b\b\b\b\b");
					printf("\b\b\b\b\b\b\b\b\b\b");
					printf("\b\b\b\b\b\b\b\b\b\b");
				}
				else
					if (compleate < 100) {
						printf("\b\b\b");
						printf("\b\b\b\b\b\b\b\b\b");
						printf("\b\b\b\b\b\b\b\b\b");
						printf("\b\b\b\b\b\b\b\b\b\b");
						printf("\b\b\b\b\b\b\b\b\b\b");
						printf("\b\b\b\b\b\b\b\b\b\b");
					}
					else
						if (compleate < 1000) {
							printf("\b\b\b\b");
							printf("\b\b\b\b\b\b\b\b\b");
							printf("\b\b\b\b\b\b\b\b\b");
							printf("\b\b\b\b\b\b\b\b\b\b");
							printf("\b\b\b\b\b\b\b\b\b\b");
							printf("\b\b\b\b\b\b\b\b\b\b");
						}
						else
							if (compleate < 10000) {
								printf("\b\b\b");
								printf("\b\b\b\b\b\b\b\b\b");
								printf("\b\b\b\b\b\b\b\b\b");
								printf("\b\b\b\b\b\b\b\b\b\b");
								printf("\b\b\b\b\b\b\b\b\b\b");
								printf("\b\b\b\b\b\b\b\b\b\b");
							}
							else
							{
								printf("\b\b\b\b");
								printf("\b\b\b\b\b\b\b\b\b");
								printf("\b\b\b\b\b\b\b\b\b");
								printf("\b\b\b\b\b\b\b\b\b\b");
								printf("\b\b\b\b\b\b\b\b\b\b");
								printf("\b\b\b\b\b\b\b\b\b\b");
							}
				// запас.
				printf("\b\b\b\b\b\b\b\b\b\b");
				printf("\b\b\b\b\b\b\b\b\b\b");
				printf("\b\b\b\b\b\b\b\b\b\b");
				printf("\b\b\b\b\b\b\b\b\b\b");
				printf("\b\b\b\b\b\b\b\b\b\b");
				printf("\b\b\b\b\b\b\b\b\b\b");
				printf("\b\b\b\b\b\b\b\b\b\b");

				if (bminus) printf("\b");
				compleate = (int)(100 * inumbertimestep / imaxnumbertimestep); // процент выполнения.
				printf("%d%% %f %1.4f %1.4f %1.4f %1.4f", compleate, fabs(isource_loc + idrain_loc) / (0.5*(fabs(isource_loc) + fabs(idrain_loc))), 0.1*elementary_q*isource_loc, 0.1*elementary_q*idrain_loc, 0.1*elementary_q*igate_loc, 0.1*elementary_q*iout_loc); // ток на 1мм ширины затвора.
				if (isource_loc < 0.0) {
					bminus = true;
				}
				else {
					bminus = false;
				}

				if (compleate > 85) {
					break;
				}

				fprintf_s(fp_statistic, "%d %e %e %e %e\n", inumbertimestep, 0.1*elementary_q*isource_loc, 0.1*elementary_q*idrain_loc, 0.1*elementary_q*igate_loc, 0.1*elementary_q*iout_loc);
			} // конец шагов по времени.



			fclose(fp_statistic);

			calculation_end_time = clock();
			calculation_seach_time = calculation_end_time - calculation_start_time;
			int im = 0, is = 0, ims = 0;
			im = (int)(calculation_seach_time / 60000); // минуты
			is = (int)((calculation_seach_time - 60000 * im) / 1000); // секунды
			ims = (int)((calculation_seach_time - 60000 * im - 1000 * is)); // /10 миллисекунды делённые на 10
			printf(" %1d:%2d:%3d \n", im, is, ims);

			/*
				Real idrain_loc=0.0; // ток стока
					Real isource_loc=0.0; // ток истока
					for (int i=1; i<M+1; i++) {
						if (xf[i]<xendsource) {
						   isource_loc+=curent_y[i][N+1]*h1;
						}
						if (xf[i]>xstartdrain) {
							idrain_loc+=curent_y[i][N+1]*h1;
						}
					 }
					 */



					 // модель Г.З. Гарбера.
					 // если iddm_Garber


					// Сверено с ЗИ.

			for (int i = 0; i < M + 2; i++) {
				for (int j = 0; j < N + 2; j++) {
					Real keyEmag = kvasiFieldMag[i][j];
					Real Emag_loc = sqrt(sqr(x_vel[i][j]) + sqr(y_vel[i][j]));

					if (!iddm_Garber) {
						if (Emag_loc < 1.0e2) {
							energy_mobility[i][j] = mu_GaN;
						}
						else {
							// эффект насыщения скорости дрейфа при больших полях.
							energy_mobility[i][j] = GaNDriftVel(Emag_loc, Nd, Tamb);
						}
					}

					if (iddm_Garber) {
						if (nu[i][j] <= 0.0) {
							// обычная подвижность, та которая используется в диффузионно дрейфовой модели.
							if (Emag_loc < 1.0e2) {
								energy_mobility[i][j] = mu_GaN;
							}
							else {
								// эффект насыщения скорости дрейфа при больших полях.
								energy_mobility[i][j] = GaNDriftVel(Emag_loc, Nd, Tamb);
							}
						}
						else {

							// Подвижность зависит лишь от квазиполя.
							if (fabs(keyEmag) < 100.0) {
								energy_mobility[i][j] = mu_GaN;
							}
							else {
								energy_mobility[i][j] = GaNDriftVel(keyEmag, Nd, Tamb);
							}

							// После разговора с Гарбером этот вариант считается перемудрённым
							// и поэтому он закоментирован.
							/*if (Emag_loc<100.0) {
								// малые поля : скорость дрейфа пропорциональна градиенту потенциала.
								energy_mobility[i][j]=mu_GaN;
							}
							else {
								if (fabs(keyEmag)<100.0) {
								// малые значения квазиполя.
								// переходим к ДДМ модели.
								//Real keychangeE2F=fabs(keyEmag)/Emag_loc;
								//energy_mobility[i][j]=mu_GaN*keychangeE2F;
								energy_mobility[i][j]=GaNDriftVel(Emag_loc,Nd,Tamb);
							}
							else {
								// Нельзя подставлят напряженность поля вместо квазполя, скорости дрейфа будут превышать vsaturation.
								// С другой стороны скорости могут быть боьше чем скорости дрейфа в равновесном состояни (при коротких затворах)
								// Явление overshoot но это только при высоких температурах электронного газа.
								//Real keychangeE2F=fabs(keyEmag)/Emag_loc;
								//energy_mobility[i][j]=(GaNDriftVel(keyEmag,Nd,Tamb)*keychangeE2F);
								// С другой стороны в выражении для тока фигурирует именно напряженность электрического поля
								// А от скалярной величины (квазиполе) зависит лишь скалярная величина подвижность и
								energy_mobility[i][j]=GaNDriftVel(keyEmag,Nd,Tamb);
								}
						  }*/
						}
					}

					energy_K300Dn[i][j] = k_bolcman*Tamb*energy_mobility[i][j] / elementary_q;
				}
			}




			Real** y_diffn_face_sn;
			my_alloc_universal(y_diffn_face_sn, M, N - 1);
			universalgrady(n, y_diffn_face_sn, yf, M, N);
			Real idrain_loc = 0.0; // ток стока
			Real isource_loc = 0.0; // ток истока
			for (int i = 1; i<M + 1; i++) {
				if (xf[i] < xendsource) {
					isource_loc += elementary_q*0.1*((2.0*energy_K300Dn[i][N] * energy_K300Dn[i][N + 1] / (energy_K300Dn[i][N] + energy_K300Dn[i][N + 1]))*y_diffn_face_sn[i][N] - 0.5*(n[i][N + 1] + n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i + 1] - xf[i - 1]);
				}
				if (xf[i] > xstartdrain) {
					idrain_loc += elementary_q*0.1*((2.0*energy_K300Dn[i][N] * energy_K300Dn[i][N + 1] / (energy_K300Dn[i][N] + energy_K300Dn[i][N + 1]))*y_diffn_face_sn[i][N] - 0.5*(n[i][N + 1] + n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i + 1] - xf[i - 1]);
				}
			}
			// на мм ширины затвора А/мм

			if (0.5*(fabs(isource_loc) + fabs(idrain_loc))>1.0e-14) {
				printf("tolerance=%f\n", fabs(isource_loc + idrain_loc) / (0.5*(fabs(isource_loc) + fabs(idrain_loc))));
			}
			else {
				printf("zero current");
			}
			//getchar();


			// экспорт результата в программу tecplot.
			// Применение реальной полескоростной характеристики кремния :


			calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			for (int i = 0; i < M + 2; i++) {
				for (int j = 0; j < N + 2; j++) {
					// Универсальное значение подвижности было вычислено раньше 
					 // в ходе вычислительного процесса.

					if (fabs(energy_mobility[i][j]) < 1.0e-34) {
						printf("error : energy_mobility is zero. %d",i+(M+2)*j);
						system("pause");
                        // exit(1);
					}

					x_vel[i][j] *= energy_mobility[i][j];
					y_vel[i][j] *= energy_mobility[i][j];
					/*
					if (j<N+1) {
						y_vel[i][j]*=energy_mobility[i][j];
					}
					else {
						y_vel[i][j]*=0.5*(energy_mobility[i][j]+energy_mobility[i][j-1]);
					}*/
					vel_mag[i][j] = sqrt(sqr(x_vel[i][j]) + sqr(y_vel[i][j]));

				}
			}



			if (1) {
				// найдём токи
		  // Сверено с Федотовым стр. 648. 
				calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
				for (int i = 0; i < M + 2; i++) {
					for (int j = 0; j < N + 2; j++) {
						// Универсальное значение коэффициента диффузии было вычислено раньше 
						// в ходе вычислительного процесса.

						curent_x[i][j] = elementary_q*(energy_K300Dn[i][j] * nx[i][j] - n[i][j] * x_vel[i][j]);
						curent_y[i][j] = elementary_q*(energy_K300Dn[i][j] * ny[i][j] - n[i][j] * y_vel[i][j]);
						/*
   if (j<N+1) {
						curent_y[i][j]=elementary_q*(energy_K300Dn[i][j]*ny[i][j]-n[i][j]*y_vel[i][j]);
   }
   else {
		curent_y[i][j]=elementary_q*(0.5*(energy_K300Dn[i][j]+energy_K300Dn[i][j-1])*ny[i][j]-n[i][j]*y_vel[i][j]);
   }
   */
						curent_mag[i][j] = sqrt(sqr(curent_x[i][j]) + sqr(curent_y[i][j]));
					}
				}
			}

			//exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
			if (din == 1) {

				if (1) {
					// Найдём компоненты скорости :
					// именно скорости так как она направлена по градиенту потенциала, в то время как напряжённость поля 
					// направлена в противоположную сторону против градиента потенциала.

					calcvelocityMESFET(u, ex, ey, xf, yf, M, N);

					for (int i = 0; i < M + 2; i++) {
						for (int j = 0; j < N + 2; j++) {
							//напряжённость же электрического поля направлена противоположно вектору скорости против градиента потенциала.
							ex[i][j] *= -1.0;
							ey[i][j] *= -1.0;
							emag[i][j] = sqrt(sqr(ex[i][j]) + sqr(ey[i][j]));
						}
					}
				}

				// Делаем визуализацию более физичной.	
				forZub(Nd, u, nu, energy_source, kvasiFieldMag, taue, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);

				exporttecplotMESFET4(u, nu, energy_source, kvasiFieldMag, taue, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);

				/*
				// Проверка вычисления напряженностей электрического поля.
				// ugradx ugrady
				universalgradx(u, x_vel_face_we, xf, M, N);
				// печать градиента.
				exporttecplot(x_vel_face_we,xf,yf,M-1,N);
				universalgrady(u, y_vel_face_sn, yf, M, N);
				exporttecplot(y_vel_face_sn, xf, yf, M, N-1);
				universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
				exporttecplot(y_vel_face_we, xf, yf, M-1, N);
				universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
				exporttecplot(x_vel_face_sn, xf, yf, M, N-1);
				*/
			}

			Real idrain = 0.0; // ток стока
			Real isource = 0.0; // ток истока
			for (int i = 1; i < M + 1; i++) {
				if (xf[i] < xendsource) {
					isource += curent_y[i][N + 1] * 0.5*(xf[i + 1] - xf[i - 1]);
				}
				if (xf[i] > xstartdrain) {
					idrain += curent_y[i][N + 1] * 0.5*(xf[i + 1] - xf[i - 1]);
				}
			}
			// на элементарный заряд уже было умножено!
			isource *= 0.1; // на мм ширины затвора А/мм
			idrain *= 0.1; // на мм ширины затвора А/мм


			if ((err1 = fopen_s(&fp, "taskreturn.txt", "wt")) != 0) {
				printf("Not Found and open file task.txt\n");
				// данные записаны не будут
			}
			else {
				fprintf(fp, "%f\n", isource);
				fprintf(fp, "%f\n", idrain);
				fclose(fp);
			}

			// Освобождение оперативной памяти.
			my_free_universal(ux_alternative, M, N);
			my_free_universal(uy_alternative, M, N);
			my_free_universal(kvasiFieldMag, M, N);
			my_free_universal(energy_mobility, M, N); // подвижность зависящая от энергии и определяемая через квазиполе.
			my_free_universal(energy_K300Dn, M, N);

			// Внутренние переменные алгебраического многосеточного метода.
			delete[] dX0;
			dX0 = NULL;



			printf("source=%f\n", isource_loc);
			printf("drain=%f\n", idrain_loc);

			printf("calculation complete...\n");
			printf("please, press any key to continue...\n");
			getchar();

		}
	}

	if (amgGM.a != NULL) {
		delete[] amgGM.a;
	}
	if (amgGM.f != NULL) {
		delete[] amgGM.f;
	}
	if (amgGM.ia != NULL) {
		delete[] amgGM.ia;
	}
	if (amgGM.ig != NULL) {
		delete[] amgGM.ig;
	}
	if (amgGM.ja != NULL) {
		delete[] amgGM.ja;
	}
	if (amgGM.u != NULL) {
		delete[] amgGM.u;
	}

	bfirst_use_amgGM = true;

} // startMESFETGaNPARIS2



// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Нитрид Галлия.
void startMESFETGaN_Gauss() {

   inithashtable(); // инициализация хэш таблицы.


#if MY_FLOAT
	// V
	Real ug=-1.0f; // напряжение на затворе. -1V
	Real ud=10.0f;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17f; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0f; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4f; // позиция конца истока.
	Real xstartgate=3.0e-4f; // позиция начала затвора
	Real xendgate=5.0e-4f; // позиция конца затвора
	Real xstartdrain=7.0e-4f; // позиция начала стока.
	lengthx=9.0e-4f; // протяжённость всей моделируемой области.
	lengthy=0.3e-4f; // высота канала.
#else
	// V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.
#endif
	
	
	FILE *fp;
	errno_t err1;
	
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}
	
	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	// Если метод Гаусса то можно и без релаксации.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 
	// Общеупотребительные константы:
#if MY_FLOAT
	const Real epsilonGaN=9.5f;
	const Real epsilon0=8.8542e-14f;
	const Real elementary_q=1.6022e-19f;
	const Real k_bolcman=1.38e-23f;
	//const Real mu_GaAs=4967.0f; // подвижность электронов в кремнии. 
#else
	const Real epsilonGaN=9.5;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	//const Real mu_GaAs=4966.999; // подвижность электронов в кремнии. 
#endif
	
	
	// подвижность в нитриде Галлия
	const Real mu_GaN=electron_mobility_GaN(Tamb, Nd);
	Real K1=elementary_q/epsilon0/epsilonGaN;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_GaN*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaN*epsilon0/(elementary_q*Nd*mu_GaN); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации. Это характерно для квазигидродинамической модели.
	// Для диффузионно дрейфовой модели шаг по времени можно увеличить на 4 порядка.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//не менее 18400 шагов по времени с tau=2.0*tauM; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;
	// Замена SOR на однократное обращение верхнего треугольника.
	Real** Gauss_M=NULL;
	Real** dCik=NULL;
	Real* Gauss_b=NULL;
	Real* Gauss_x=NULL;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ для потенциала
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N); // выделение памяти под матрицу потенциала.
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				// Для метода Гаусса, осторожно ресурсоёмко по памяти.
				constr_matr(Gauss_M, dCik, Gauss_b, Gauss_x, A, M, N);
                eqsolve_lenta_gauss_only_matrix(Gauss_M, (M+2)*(N+2), M+2, dCik);
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 /*
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				      SORDirichlet(u, rthdsd, A, URF, M, N);
					 
                 }*/
				 //Ilyin1985quick(u, rthdsd, A, M, N, iend);
				 
				 // 3. многократные запуски следующего обратного хода :
                copy_vector(rthdsd, Gauss_b, M, N); // прямое копирование.
                eqsolve_lenta_gauss_obratnji_hod(Gauss_M, dCik, M, N, Gauss_b, Gauss_x);
                copy_vector_inverse(u, Gauss_x, M, N);
				//if (inumbertimestep==20) exporttecplot(u,xf,yf,M,N);
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			 if (0) {
	             // Найдём компоненты скорости не ограниченной сверху они соноправлены градиету потенциала :
	             calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			     for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
					     // Напряжённости же поля противоположны градиенту потенциала.
					     ex[i][j]=-x_vel[i][j];
					     ey[i][j]=-y_vel[i][j];
					     emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				     }
			     }
			 }
			

	         // Применение реальной полескоростной характеристики Нитрида Галлия :
			
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
					   if (vel_mag[i][j]>1.0e-30) {
	                       x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   }
					   else {
						   x_vel[i][j]=0.0;
						   y_vel[i][j]=0.0;
						   vel_mag[i][j]=0.0;
					   }
		          }
	           }
			 }

			

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			 // аппроксимация Крёмера.
			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 // Vy
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			
			 // Рабочий вариан работающий без использования хэш таблицы.
			 /*
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					    x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						  y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }
			 */


			 //Вариант работающий с использованием хэш таблицы.
			  //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 
					 if (velmag_loc>1.0e-30) {
						 x_vel_face_we[i][j]=x_vel_face_we[i][j]*GaNDriftVel(velmag_loc, Nd, Tamb);
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=y_vel_face_sn[i][j]*GaNDriftVel(velmag_loc, Nd, Tamb);
					 }
					 else {
						  y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }


			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn, rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

#if MY_FLOAT
			 for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0f;
			     	 rthdsd_internaln[i][j]=0.0f;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0f*0.25f*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0f*0.25f*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0f-alpha)*n_oldi[i][j];
		         }
		     }
#else
			 for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
#endif

		     
			 
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();

#if MY_FLOAT
			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0f-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0f-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0f-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0f-alpha)*n_oldi[i][N+1];
			     }
		     }
#else
			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
#endif

			 
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/

		

	
 #if MY_FLOAT
		Real idrain_loc=0.0f; // ток стока
    	Real isource_loc=0.0f; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5f*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5f*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5f*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5f*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5f*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5f*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5f*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14f) {
		if (fabs(isource_loc+idrain_loc)/(0.5f*(fabs(isource_loc)+fabs(idrain_loc))) <0.005f) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}
#else
		Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}
#endif
		

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		printf("%d%% %f %1.4f",compleate, fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))), 0.1*elementary_q*isource_loc);

	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

	 
	calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	
	for (int i=0; i<M+2; i++) {
	     for (int j=0; j<N+2; j++) {
		      vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		      Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
			   if (vel_mag[i][j]>1.0e-30) {
				    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
               }
			   else {
				   x_vel[i][j]=0.0;
				   y_vel[i][j]=0.0;
				   vel_mag[i][j]=0.0;
				}
	         
		 }
	}	 


	  

	if (1) {
			  // найдём токи Сверено с Федотовым стр. 648.
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	
	if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		printf("Not Found and open file task.txt\n");
		// данные записаны не будут
	}
	else {
		fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		fclose(fp);
	}
	

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

   // Освобождение оперативной памяти из под метода Гаусса.
   free_matr(Gauss_M, dCik, Gauss_b, Gauss_x,  M, N);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();

} // startMESFETGaN_Gauss


// Оригинальный алгоритм Р.П. Федоренко 1961 года.
// применённый для моделирования MESFET в динамике.
// материал Нитрид Галлия.
void startMESFETGaN_Gauss_VAX() {

    inithashtable(); // инициализация хэш таблицы.


#if MY_FLOAT
	// V
	Real ug=-1.0f; // напряжение на затворе. -1V
	Real ud=10.0f;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17f; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0f; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4f; // позиция конца истока.
	Real xstartgate=3.0e-4f; // позиция начала затвора
	Real xendgate=5.0e-4f; // позиция конца затвора
	Real xstartdrain=7.0e-4f; // позиция начала стока.
	lengthx=9.0e-4f; // протяжённость всей моделируемой области.
	lengthy=0.3e-4f; // высота канала.

#else
	// V
	Real ug=-1.0; // напряжение на затворе. -1V
	Real ud=10.0;//50.0;//20.0;//10.0; // напряжение на стоке. +10V
	// cm!-3
	Real Nd=1.0e17; // конценрация доноров и концентрация электронов на истоке и стоке.
	int din=1;
	Real Tamb=400.0; // температура полупроводника.

	// cm
	Real xendsource=2.0e-4; // позиция конца истока.
	Real xstartgate=3.0e-4; // позиция начала затвора
	Real xendgate=5.0e-4; // позиция конца затвора
	Real xstartdrain=7.0e-4; // позиция начала стока.
	lengthx=9.0e-4; // протяжённость всей моделируемой области.
	lengthy=0.3e-4; // высота канала.

#endif

	
	
	
	FILE *fp;
	errno_t err1;
	
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		fscanf_s(fp, "%d", &din);
		float fin;
		
		fscanf_s(fp, "%f", &fin);
		ud=fin;
		fscanf_s(fp, "%f", &fin);
		ug=fin;
		// 1 записывать файл с данными, 0 не записывать.
		fscanf_s(fp, "%d", &din);
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
		//printf("ud=%f ug=%f",ud, ug);
		//getchar();
        fscanf_s(fp, "%f", &fin);
		Tamb=fin;
		// H
		fscanf_s(fp, "%f", &fin);
		lengthy=fin;
		// Ls
		fscanf_s(fp, "%f", &fin);
		xendsource=fin;
		// Lgs 
		fscanf_s(fp, "%f", &fin);
		xstartgate=xendsource+fin;
		// Lg
		fscanf_s(fp, "%f", &fin);
		xendgate=xstartgate+fin;
		// Lgd
		fscanf_s(fp, "%f", &fin);
		xstartdrain=xendgate+fin;
		// Ld
		fscanf_s(fp, "%f", &fin);
		lengthx=xstartdrain+fin;
		fscanf_s(fp, "%f", &fin);
		Nd=fin;
		fclose(fp);
	}
	
	/*
    if (ud<=436.05) {
		M=(q*15-1); // количество линий сетки по горизонтали
        N=(q*4-1); // количество линий сетки по вертикали
	}
	else if (ud<750.0) {
		M=(q*20-1); // количество линий сетки по горизонтали
        N=(q*5-1); // количество линий сетки по вертикали
	}
	else if (ud<=1191.87) {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}
	else {
		M=(q*30-1); // количество линий сетки по горизонтали
        N=(q*10-1); // количество линий сетки по вертикали
	}*/
	// Сложно предугадать какие пользователь введёт значения
	// потенциалов, поэтому введём самую надёжную (подробную) сетку!!!
	M=(q*30-1); // количество линий сетки по горизонтали
    N=(q*10-1);// количество линий сетки по вертикали

	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	


	bool btimedepend=true;// нестацтонарное моделирование.
	// Если метод Гаусса то можно и без релаксации.
	Real alpha=0.1; // нижняя релаксация вводимая в матрицу для концентрации.

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	
	
	// Постоянный коэффициент теплопроводности при 300К
	Real K300=1.0; // безразмерный коэффициент диффузии в уравнении для потенциала.

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	//Real h1=(Real)(lengthx/(M+1));
	Real h1=(Real)(lengthx/(M+1-6));
	//Real h2=(Real)(lengthy/(N+1));
	Real h2=(Real)(lengthy/(N+1-2));

	Real* xf=new Real[M+2];
	/*for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}*/
	for (int i=0; i<M-4; i++) {
		xf[i]=(Real)((i)*h1);
	}
	for (int i=M-4; i>1; i--) {
		xf[i]=xf[i-1];
	}
	xf[1]=0.5*h1;
	xf[M-3]=xf[M-4];
    xf[M-4]=xf[M-5]+0.5*h1;
	int ifound=0;
	Real eps2=1e30;
	for (int i=1; i<M-3; i++) {
		if (fabs(xendsource-xf[i])<eps2) {
			eps2=fabs(xendsource-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendsource;
	for (int i=M-2; i>ifound; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M-1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+3]-xf[ifound+1]);
	eps2=1e30;
	for (int i=ifound+2; i<M-1; i++) {
		if (fabs(xstartgate-xf[i])<eps2) {
			eps2=fabs(xstartgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xendgate-xf[i])<eps2) {
			eps2=fabs(xendgate-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xendgate;
	eps2=1e30;
	for (int i=ifound+1; i<M-1; i++) {
		if (fabs(xstartdrain-xf[i])<eps2) {
			eps2=fabs(xstartdrain-xf[i]);
			ifound=i;
		}
	}
	xf[ifound]=xstartdrain;
	for (int i=M; i>ifound;i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound]=xf[ifound-1]+0.5*(xf[ifound]-xf[ifound-1]);
	for (int i=M+1; i>ifound+2; i--) {
		xf[i]=xf[i-1];
	}
	xf[ifound+2]=xf[ifound+1]+0.5*(xf[ifound+2]-xf[ifound+1]);


	Real* yf=new Real[N+2];
	/*
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}*/
	for (int i=0; i<N-1; i++) {
		yf[i]=(Real)(i*h2);
	}
	yf[N+1]=(Real)((N-1)*h2);
	yf[N-1]=yf[N-2]+0.5*h2;
	yf[N]=yf[N-1]+0.25*h2;
	 


#if MY_FLOAT
	// Общеупотребительные константы:
	const Real epsilonGaN=9.5f;
	const Real epsilon0=8.85418e-14f;
	const Real elementary_q=1.60218e-19f;
	const Real k_bolcman=1.38e-23f;
	//const Real mu_GaAs=4967.0f; // подвижность электронов в кремнии. 
#else
	// Общеупотребительные константы:
	const Real epsilonGaN=9.5;
	const Real epsilon0=8.85418e-14;
	const Real elementary_q=1.60218e-19;
	const Real k_bolcman=1.38e-23;
	//const Real mu_GaAs=4966.999; // подвижность электронов в кремнии. 
#endif

	
	
	// подвижность в нитриде Галлия
	const Real mu_GaN=electron_mobility_GaN(Tamb, Nd);
	Real K1=elementary_q/epsilon0/epsilonGaN;
	// теперь концентрация неподвижных доноров определена выше и считывается пользователем.
	//Real Nd=68.965e5; // конценрация доноров и концентрация электронов на истоке и стоке.
	Real K1Nd=K1*Nd;//266102.14e5; // произведение K1 на концентрацию доноров.
	//Real K300Dn=1.0; // безразмерный коэффициент диффузии в уравнении переноса электронов.
	Real K300Dn=mu_GaN*k_bolcman*Tamb/elementary_q;
	Real tauM=epsilonGaN*epsilon0/(elementary_q*Nd*mu_GaN); // рекомендовано Гарбером.
	//Real dtimestep=1.0e-12; // 1.0e-5// размер шага по времени.
	Real dtimestep=2.0*tauM; // два времени максвеловской релаксации. Это характерно для квазигидродинамической модели.
	// Для диффузионно дрейфовой модели шаг по времени можно увеличить на 4 порядка.
	dtimestep=8000.0*tauM;
	int imaxnumbertimestep=40000;//не менее 18400 шагов по времени с tau=2.0*tauM; // количество шагов по времени.
	int inumberinternaliter=30; // количество итераций на временном слое.

	int ibasealg=SEIDEL; // STANDART SEIDEL  LR SORDIRICHLET ZVER
	int ialgn=SEIDEL; // алгоритм для переноса концентрации электронов.
	int iendn=6;//21; //21 // одна итерация полинейного метода.
	int ialg=SEIDEL;
	int iend=21;//21;//21;
	// Замена SOR на однократное обращение верхнего треугольника.
	Real** Gauss_M=NULL;
	Real** dCik=NULL;
	Real* Gauss_b=NULL;
	Real* Gauss_x=NULL;

	Real** u; // рассчитываемый потенциал.
    Real** u_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd_internal; // внутренность : правая часть
	Real** rthdsd; // правая часть.
	MATRNODE** A; // матрица СЛАУ для потенциала
	// в целях экономии машинных ресурсов матрица для потенциала собирается лишь единожды,
	// т.к. она не меняется в ходе вычислительного процесса.
	bool bflagconstrA=true;

	Real** n; // рассчитываемая концентрация электронов.
	Real** n_buf; // для метода Зейделя.
    Real** n_oldi; // концентрация с предыдущей итерации.
	Real** n_old; // концентрация с предыдущего временного слоя.
	Real** x_vel; // компоненты дрейфовой скорости электронов
	Real** y_vel; // по x и по y.
	Real** x_vel_face_we; // для иксовой скорости.
	Real** y_vel_face_we;
	Real** x_vel_face_sn; // для игриковой скорости. 
	Real** y_vel_face_sn;
	Real** vel_mag; // модуль скорости.
	Real** ex; // напряжённость электрического поля по x
	Real** ey; // напряжённость электрического поля по y
	Real** nx; // градиент концентрации по x.
	Real** ny; // градиент концентрации по y.
    Real** emag; // модуль напряжённости электрического поля.
	Real** curent_x; // ток по икс.
	Real** curent_y; // ток по y
	Real** curent_mag; // модуль тока.	
	Real** rn; // невязка
	Real** rthdsd_internaln; // внутренность : правая часть
	Real** rthdsdn; // правая часть.
	MATRNODE** An; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v;
    Real** v_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	MATRNODE** Al; // матрица СЛАУ

	TBONCONDOMAIN my_bound; // Граничные условия для потенциала
	TBONCONDOMAIN my_boundn; // Граничные условия для концентрации.
	printf("Multigrd Fedorenko 1961 algorithm \n");
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound,M,N);
	my_alloc_bound(my_boundn,M,N);
	my_alloc_universal(rthdsd_internal, M, N);
	my_alloc(u, u_old, r, rthdsd, A, M, N); // выделение памяти под матрицу потенциала.
	
	my_init_zero_potencial(xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, 0.0, u, M, N);

	my_alloc_universal(rthdsd_internaln, M, N);
	my_alloc(n, n_oldi, rn, rthdsdn, An, M, N);
	my_alloc_universal(n_old, M, N);
	my_alloc_universal(n_buf, M, N);
	my_alloc_universal(x_vel, M, N);
	my_alloc_universal(y_vel, M, N);
	my_alloc_universal(x_vel_face_we,M-1,N); // для иксовой скорости.
    my_alloc_universal(y_vel_face_we,M-1,N);
	my_alloc_universal(x_vel_face_sn,M,N-1); // для игриковой скорости.
    my_alloc_universal(y_vel_face_sn,M,N-1);
	my_alloc_universal(vel_mag, M, N);
	my_alloc_universal(ex, M, N);
	my_alloc_universal(ey, M, N);
	my_alloc_universal(nx, M, N);
	my_alloc_universal(ny, M, N);
	my_alloc_universal(emag, M, N);
	my_alloc_universal(curent_x, M, N);
	my_alloc_universal(curent_y, M, N);
	my_alloc_universal(curent_mag, M, N);



	my_init_zero_n(xendsource, xstartgate, xendgate, xstartdrain, Nd, xf, 0.0, n, n_oldi, n_old, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, x_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, y_vel, M, N);
	my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, vel_mag, M, N);



    int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	TBONCONDOMAIN my_bound_coarse; // Граничные условия
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse,MC,NC);
	my_alloc(v, v_old, r_coarse, rthdsd_c, Al, MC, NC);

	
	
	int compleate=0;
	printf("%d%%",compleate);

	Real time=0.0;


    FILE *fpvax;
	errno_t err2;

	if ((err2=fopen_s(&fpvax,"vetka.txt","r"))!=0) {
		printf("Not Found and open file vekta.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {

		if ((err1=fopen_s(&fp,"taskreturn.txt","wt"))!=0) {
		     printf("Not Found and open file task.txt\n");
		     // данные записаны не будут
	     }
	     else {

			 int dincount=0;
			 fscanf_s(fpvax, "%d", &dincount);
		
			 for (int ivd=0; ivd<dincount; ivd++) {

				 float fin;
				 fscanf_s(fpvax, "%f", &fin);
				 ud=fin;

	for (int inumbertimestep=0; inumbertimestep<imaxnumbertimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=dtimestep;

		int iter=0;
		while (iter<inumberinternaliter)
		{

	         //**
	         //*****
	         // Решение уравнения для электрического потенциала в кремнии.
	         //*****
	         //**

	         // Шаблоны для граничных условий.
	        // load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);

	
	        
		    // геометрия неизменна и свойства материалов постоянны
		    // поэтому матрица собирается только один раз перед началом счёта.
	        //constrA0(A, my_bound ,K300, xf, yf, M, N); // сборка матрицы.
			if (bflagconstrA) {
			    constrA0MCVMESFET(A, K300, xf, yf, M, N, xendsource, xstartgate, xendgate, xstartdrain); // сборка матрицы.
				// Для метода Гаусса, осторожно ресурсоёмко по памяти.
				constr_matr(Gauss_M, dCik, Gauss_b, Gauss_x, A, M, N);
                eqsolve_lenta_gauss_only_matrix(Gauss_M, (M+2)*(N+2), M+2, dCik);
				bflagconstrA=false;
			}
	        
	         for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		 	         r[i][j]=0.0;
			         //rthdsd_internal[i][j]=0.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
			       // rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*h1*h2;
					 rthdsd_internal[i][j]=(K1Nd-K1*n[i][j])*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1]);
		         }
	         }

			 /*
			 if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             A[i][j].ap+=1.0*h1*h2/dtimestep;				                        
			             rthdsd_internal[i][j]+=1.0*h1*h2*u_old[i][j]/dtimestep;
			         }
		         }
		     }
			 */

	       //  constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
			  constrrthdsd0potencialMESFET(rthdsd, rthdsd_internal, xf, yf, M, N, ug, ud, xendsource, xstartgate, xendgate, xstartdrain);

	
             

			 /*if (inumbertimestep>40) {
			 exporttecplot(rthdsd,xf,yf,M,N);
			 }*/

			 if (1) 
			 {
			     // Простейший алгоритм.

				// itsolve_naiv(u, u_old, r, rthdsd, M, N, ialg, A, iend);
				 /*
				 for (int i=0; i<iend; i++) {
					  // Метод Гаусса, Зейделя, Ричардсона, Либмана
	                 // Seidel(u, rthdsd, A, M, N);
					  // метод последовательной верхней релаксации с коэффициентом 1.855.
				      Real URF=1.855;
				      SORDirichlet(u, rthdsd, A, URF, M, N);
					 
                 }*/
				 //Ilyin1985quick(u, rthdsd, A, M, N, iend);
				 
				 // 3. многократные запуски следующего обратного хода :
                copy_vector(rthdsd, Gauss_b, M, N); // прямое копирование.
                eqsolve_lenta_gauss_obratnji_hod(Gauss_M, dCik, M, N, Gauss_b, Gauss_x);
                copy_vector_inverse(u, Gauss_x, M, N);
				//if (inumbertimestep==20) exporttecplot(u,xf,yf,M,N);
		
			 }
			 else
			 {
				 // Алгоритм Р.П. Федоренко.
                 load_my_bound_potencial_MESFET(my_bound, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xf, yf, M, N);
				 constrrthdsd0(rthdsd, rthdsd_internal, my_bound, xf, yf, M, N); // правая часть.
                 load_my_bound_potencial_MESFET(my_bound_coarse, xendsource, xstartgate, xendgate, xstartdrain, ug, ud, xc, yc, MC, NC);

	            // Для вспомогательной системы имеем однородные граничные условия.
	            my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v, MC, NC);
	        
		        // геометрия неизменна и свойства материалов постоянны
		        // поэтому матрица собирается только один раз перед началом счёта.
	            constrA0(Al, my_bound_coarse, K300, xc, yc, MC, NC); // сборка матрицы.
	       
	            for (int i=0; i<MC+2; i++) {
		           for (int j=0; j<NC+2; j++) {
		        	   r_coarse[i][j]=0.0;
			           rthdsd_c[i][j]=0.0*0.25*(xc[i+1]-xc[i-1])*(yc[j+1]-yc[j-1]);
		           }
	            }
				Real *residual_history=new Real[iend+1];
	            for (int i=0; i<iend; i++) {
	                 residual_history[i]=1.0; // инициализация.
	            }
	            itsolve_Fedor(u, u_old, r, rthdsd, M, N, v, v_old,  r_coarse, rthdsd_c, MC, NC, ibasealg, A, Al, 1.0e-5,residual_history);
	            // нормированная октаэдрическая норма (сумма модулей).
	            for (int i=1; i<iend; i++) {
	                residual_history[i]=residual_history[i]/residual_history[0];
	            }
	            residual_history[0]=1.0;

	            for (int i=0; i<iend; i++) {
	                 //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	            }
	            delete residual_history;
	            

			 }
             //exporttecplot(u,xf,yf,M,N);
	
	         //**
	         //*****
	         // Решение уравнения для концентрации электронов в кремнии.
	         //*****
	         //**


			  if (0) {
	             // Найдём компоненты скорости не ограниченной сверху они соноправлены градиету потенциала :
	             calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
			 
			     for (int i=0; i<M+2; i++) {
	    	         for (int j=0; j<N+2; j++) {
					     // Напряжённости же поля противоположны градиенту потенциала.
					     ex[i][j]=-x_vel[i][j];
					     ey[i][j]=-y_vel[i][j];
					     emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				     }
			     }
			 }
			

	         // Применение реальной полескоростной характеристики Нитрида Галлия :
			
			 if (0) {
    	       for (int i=0; i<M+2; i++) {
	              for (int j=0; j<N+2; j++) {
			           vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
					   if (vel_mag[i][j]>1.0e-30) {
	                       x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			               vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
					   }
					   else {
						   x_vel[i][j]=0.0;
						   y_vel[i][j]=0.0;
						   vel_mag[i][j]=0.0;
					   }
		          }
	           }
			 }

			

			 //exporttecplot(x_vel,xf,yf,M,N);
			 //exporttecplot(y_vel,xf,yf,M,N);

			 // компоненты скорости на шахматной сетке
			 // аппроксимация Крёмера.
			 // Vx
			 universalgradx(u, x_vel_face_we, xf, M, N);
			 universalgrady(u, y_vel_face_sn, yf, M, N);
			 // Vy
			 universalgrady_mapx(u, y_vel_face_sn, y_vel_face_we, M, N);
			 universalgradx_mapy(u, x_vel_face_we, x_vel_face_sn, M, N);
			
			 /*

			 // Базовый вариант работающий без использования хэш таблицы.
			 //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					    x_vel_face_we[i][j]=(x_vel_face_we[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 Real velocity_magnitude=Field_velocity_mag(velmag_loc,Tamb, Nd);
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=(y_vel_face_sn[i][j]/velmag_loc)*velocity_magnitude;
					 }
					 else {
						  y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }
			 */

			 //Вариант работающий с использованием хэш таблицы.
			  //Vx
			 for (int i=0; i<M+1; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_we[i][j])+sqr(y_vel_face_we[i][j]));
					 
					 if (velmag_loc>1.0e-30) {
						 x_vel_face_we[i][j]=x_vel_face_we[i][j]*GaNDriftVel(velmag_loc, Nd, Tamb);
					 }
					 else {
						 x_vel_face_we[i][j]=0.0;
					 }
		         }
	         }
             // Vy			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+1; j++) {
					 Real velmag_loc=sqrt(sqr(x_vel_face_sn[i][j])+sqr(y_vel_face_sn[i][j]));
					 
					 if (velmag_loc>1.0e-30) {
					     y_vel_face_sn[i][j]=y_vel_face_sn[i][j]*GaNDriftVel(velmag_loc, Nd, Tamb);
					 }
					 else {
						  y_vel_face_sn[i][j]=0.0;
					 }
		         }
	         }

			 //exporttecplotx(x_vel_face_we,xf,yf,M,N);
			 //exporttecploty(y_vel_face_sn,xf,yf,M,N);

			 if (0) {
			  // найдём токи
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=K300Dn*nx[i][j]-n[i][j]*x_vel[i][j];
					 curent_y[i][j]=K300Dn*ny[i][j]-n[i][j]*y_vel[i][j];
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
			 }

	         // Непосредственное решение уравнения.

		     // Загружаем граничные условия:
		     //load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn, M, N);
			//load_my_bound_n(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel, y_vel, Nd, xf, yf, K300Dn,rthdsdn, M, N);
			load_my_bound_n2(my_boundn,  xendsource, xstartgate, xendgate, xstartdrain, x_vel_face_we, y_vel_face_sn, Nd, xf, yf, K300Dn, rthdsdn, M, N); 

		     //constrAPatankar(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			// constrAPatankarMESFET(An, my_boundn, x_vel, y_vel, 1.0, K300Dn, xf, yf, M, N);
			constrAPatankarMESFET2(An, my_boundn, x_vel_face_we, y_vel_face_sn, 1.0, K300Dn, xf, yf, M, N);				

	         for (int i=0; i<M+2; i++) {
		         for (int j=0; j<N+2; j++) {
		             // инициализация рассчитываемых величин.
		             n_oldi[i][j]=n[i][j];
		         }
	         }

#if MY_FLOAT
			  for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0f;
			     	 rthdsd_internaln[i][j]=0.0f;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0f*0.25f*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0f*0.25f*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0f-alpha)*n_oldi[i][j];
		         }
		     }
			 
#else
			 for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             // правая часть :
					 rn[i][j]=0.0;
			     	 rthdsd_internaln[i][j]=0.0;
			     }
		     }
		
		     if (btimedepend) {
		         // нестационарный солвер.
			     for (int i=1; i<M+1; i++) {
		             for (int j=1; j<N+1; j++) {
			             An[i][j].ap+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])/dtimestep;				                        
			             rthdsd_internaln[i][j]+=1.0*0.25*(xf[i+1]-xf[i-1])*(yf[j+1]-yf[j-1])*n_old[i][j]/dtimestep;
			         }
		         }
		     }
		
		     // нижняя релаксация для концентрации.
			 
		     for (int i=1; i<M+1; i++) {
		         for (int j=1; j<N+1; j++) {
		             An[i][j].ap/=alpha;				                        
		             rthdsd_internaln[i][j]+=An[i][j].ap*(1.0-alpha)*n_oldi[i][j];
		         }
		     }
			 
#endif

		    
			

			  

		    // constrrthdsd0(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.
			 constrrthdsd0MESFETn(rthdsdn, rthdsd_internaln, my_boundn, xf, yf, M, N); // правая часть.

			 

		     // невязка :
		    // residual(rn, n, rthdsdn,  An, M, N);
		    //printf("%e\n",normar(r, M, N));
		    //getchar();

			// exporttecplot(rthdsdn, xf,  yf, M, N);
			 //getchar();


#if MY_FLOAT
			  // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0f-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0f-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0f-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0f-alpha)*n_oldi[i][N+1];
			     }
		     }
#else
			 // Обязательно нужна нижняя релаксация для условия нормальный ток равен нулю.
			 for (int i=1; i<M+1; i++) {
				 An[i][0].ap/=alpha;				                        
		         rthdsdn[i][0]+=An[i][0].ap*(1.0-alpha)*n_oldi[i][0];
			 }
			 for (int j=1; j<N+1; j++) {
				 An[0][j].ap/=alpha;				                        
		         rthdsdn[0][j]+=An[0][j].ap*(1.0-alpha)*n_oldi[0][j];
				 An[M+1][j].ap/=alpha;				                        
		         rthdsdn[M+1][j]+=An[M+1][j].ap*(1.0-alpha)*n_oldi[M+1][j];
			 }

			 for (int i=1; i<M+1; i++) {
			     if ((xf[i]>=xendsource)&&(xf[i]<=xstartdrain)) {
					  An[i][N+1].ap/=alpha;				                        
		              rthdsdn[i][N+1]+=An[i][N+1].ap*(1.0-alpha)*n_oldi[i][N+1];
			     }
		     }
#endif
			 
			 
			 
		     // решение СЛАУ:
			 
			 // запоминаем поле с предыдущей итерации.
	         // данный итерационный процесс требует в два раза больше памяти.
			 //for (int i=0; i<iendn; i++) {
	            /// Seidel1(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //	 Seidel2(n, rthdsdn, An, M, N, alpha, xf, xendsource, xstartdrain, Nd);	
			 //}
			 

		     //itsolve_naiv(n, n_buf, rn, rthdsdn, M, N, ialgn, An, iendn);
			 for (int i=0; i<iendn; i++) {
	                  Seidel(n, rthdsdn, An, M, N);
                 }

		    // Переход к следующей итерации.
		    iter++;

			

		}

		 //exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

			//	 getchar();


		// Запоминание концентрации с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		   for (int j=0; j<N+2; j++) {
		 	    n_old[i][j]=n[i][j];
		   }
		}

		  // экспорт результата в программу tecplot.
		/*if (inumbertimestep%20==0) {
                  exporttecplotMESFET(u, n, x_vel, y_vel, xf, yf, M, N);

				 getchar();
		}*/

		

#if MY_FLOAT
		Real idrain_loc=0.0f; // ток стока
    	Real isource_loc=0.0f; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5f*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5f*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5f*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5f*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5f*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14f) {
		if (fabs(isource_loc+idrain_loc)/(0.5f*(fabs(isource_loc)+fabs(idrain_loc))) <0.005f) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}
#else
        Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				 isource_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    // isource_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
				idrain_loc+=(K300Dn*(n[i][N+1]-n[i][N])/(yf[N+1]-yf[N])-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
			    //idrain_loc+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
		if (fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))) <0.005) {
			// досрочное прекращение вычислений
			 inumbertimestep=imaxnumbertimestep+1;
			   break;
		}}
		else {
			// возможно нулевой ток.
			if (inumbertimestep>70) break;
		}
#endif

		

		// показывает процент выполнения расчёта.
		if (compleate <10) {
			printf("\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		if (compleate <100) {
			printf("\b\b\b");
			printf("\b\b\b\b\b\b\b\b\b");
		}
		else
		{
		   printf("\b\b\b\b");
		   printf("\b\b\b\b\b\b\b\b\b");
		}
		compleate=(int)(100*inumbertimestep/imaxnumbertimestep); // процент выполнения.
		printf("%d%% %f",compleate,fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));

	} // конец шагов по времени.

	
	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

/*
	Real idrain_loc=0.0; // ток стока
    	Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
			   isource_loc+=curent_y[i][N+1]*h1;
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=curent_y[i][N+1]*h1;
		    }
	     }
		 */

	Real** y_diffn_face_sn;
	my_alloc_universal(y_diffn_face_sn,M,N-1); 
    universalgrady(n, y_diffn_face_sn, yf, M, N);
    Real idrain_loc=0.0; // ток стока
    Real isource_loc=0.0; // ток истока
	    for (int i=1; i<M+1; i++) {
		    if (xf[i]<xendsource) {
				isource_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
		    if (xf[i]>xstartdrain) {
			    idrain_loc+=elementary_q*0.1*(K300Dn*y_diffn_face_sn[i][N]-0.5*(n[i][N+1]+n[i][N])*y_vel_face_sn[i][N])*0.5*(xf[i+1]-xf[i-1]);
		    }
	     }
	      // на мм ширины затвора А/мм
	
		if (0.5*(fabs(isource_loc)+fabs(idrain_loc))>1.0e-14) {
	        printf("tolerance=%f\n",fabs(isource_loc+idrain_loc)/(0.5*(fabs(isource_loc)+fabs(idrain_loc))));
		}
		else {
			printf("zero current");
		}
	//getchar();

	
    // экспорт результата в программу tecplot.
	// Применение реальной полескоростной характеристики кремния :

	 
	calcvelocityMESFET(u, x_vel, y_vel, xf, yf, M, N);
	
	for (int i=0; i<M+2; i++) {
	     for (int j=0; j<N+2; j++) {
		      vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
		      Real velocity_magnitude=Field_velocity_mag(vel_mag[i][j],Tamb, Nd);
			   if (vel_mag[i][j]>1.0e-30) {
				    x_vel[i][j]=(x_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        y_vel[i][j]=(y_vel[i][j]/vel_mag[i][j])*velocity_magnitude;
			        vel_mag[i][j]=sqrt(sqr(x_vel[i][j])+sqr(y_vel[i][j]));
               }
			   else {
				   x_vel[i][j]=0.0;
				   y_vel[i][j]=0.0;
				   vel_mag[i][j]=0.0;
				}
	         
		 }
	}	 


	  

	if (1) {
			  // найдём токи Сверено с Федотовым стр. 648.
			 calcvelocityMESFET(n, nx, ny, xf, yf, M, N);
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 curent_x[i][j]=elementary_q*(K300Dn*nx[i][j]-n[i][j]*x_vel[i][j]);
					 curent_y[i][j]=elementary_q*(K300Dn*ny[i][j]-n[i][j]*y_vel[i][j]);
					 curent_mag[i][j]=sqrt(sqr(curent_x[i][j])+sqr(curent_y[i][j]));
				 }
			 }
		}

    //exporttecplotMESFET(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	if (din==1) {

	if (1) {
	         // Найдём компоненты скорости :
	         calcvelocityMESFET(u, ex, ey, xf, yf, M, N);
			 
			 for (int i=0; i<M+2; i++) {
	    	     for (int j=0; j<N+2; j++) {
					 ex[i][j]*=-1.0;
					 ey[i][j]*=-1.0;
					 emag[i][j]=sqrt(sqr(ex[i][j])+sqr(ey[i][j]));
				 }
			 }
	   }

		

    	exporttecplotMESFET2(u, ex, ey, emag, n, x_vel, y_vel, vel_mag, curent_x, curent_y, curent_mag, xf, yf, M, N);
	}

	Real idrain=0.0; // ток стока
	Real isource=0.0; // ток истока
	for (int i=1; i<M+1; i++) {
		if (xf[i]<xendsource) {
			isource+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
		if (xf[i]>xstartdrain) {
			idrain+=curent_y[i][N+1]*0.5*(xf[i+1]-xf[i-1]);
		}
	}
	// на элементарный заряд уже было умножено!
	isource*=0.1; // на мм ширины затвора А/мм
	idrain*=0.1; // на мм ширины затвора А/мм

	fprintf(fp, "%f\n", isource);
		fprintf(fp, "%f\n", idrain);
		
	
	

   printf("source=%f\n", isource);
   printf("drain=%f\n", idrain);

   }

}

   }

   // закрытие файлов :
   fclose(fpvax);
   fclose(fp);


   // Освобождение оперативной памяти из под метода Гаусса.
   free_matr(Gauss_M, dCik, Gauss_b, Gauss_x,  M, N);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");
	//getchar();

} // startMESFETGaN_Gauss_VAX



// Алгоритм решения уравнений Навье-Стокса в приближении Обербека-Буссинеска 
// в прямоугольнике в переменных вихрь-функция тока.
void Roache_Fedushkin_Fedorenko() {
	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	// Всюду нулевые граничные условия.
	Real bleft=0.0;
	Real bright=0.0;
	Real btop=0.0;
	Real bbottom=0.0;

	int icadr=0; // номер анимационного кадра.
	// Будем наблюдать в контрольной точке за поведением средних величин.
	// Контрольная точка (xpoint, ypoint);
	Real xpoint=0.5* lengthx;
	Real ypoint=0.5* lengthy;
	int ixpoint=0;
	int iypoint=0;
	Real avgpointmag=0.0;
	Real avgpointxvel=0.0;
	Real avgpointyvel=0.0;
	Real avgpointcurl=0.0;
	Real avgpointstreamfunc=0.0;
	Real avgpointtemperature=0.0;
	// Осреднённые по последнему периоду полевые величины.
	Real** avgmag;
	Real** avgxvel;
	Real** avgyvel;
	Real** avgcurl;
	Real** avgsf;
	Real** avgtemp;
	// выделение памяти.
	my_alloc_universal(avgmag, M,N);
	my_alloc_universal(avgxvel, M,N);
	my_alloc_universal(avgyvel, M,N);
	my_alloc_universal(avgcurl, M,N);
	my_alloc_universal(avgsf, M,N);
	my_alloc_universal(avgtemp, M,N);
	// инициализация нулём.
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgmag, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgxvel, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgyvel, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgcurl, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgsf, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgtemp, M, N);

    calculation_start_time=clock(); // момент начала счёта.

	

	// функции для решения Навье-Стокса.
	Real** curl; // вихрь;
	Real** curl_oldi; // вихрь с предыдущей внутренней итерации.
	Real** curl_old; // вихрь с предыдущего временного слоя.
	Real** curl_old2; // вихрь с предыдущего временного слоя.
	Real** temp_old; // температура с предыдущего временного слоя.
	Real** temp_old2; // температура с предыдущего временного слоя.
	Real** stream_function; // функция тока;
	Real** temperature; // температура;
	Real** u; // горизонтальная скорость;
	Real** v; // вертикальная скорость;
	Real** gradxtemperature; // градиент температуры по оси х.


	// функции для решения СЛАУ.
	Real** potent; // рассчитываемый потенциал.
    Real** potent_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd; // правая часть
	Real** rthdsd_internal; // внутренность : правая часть
	MATRNODE** A; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v1;
    Real** v1_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	Real** ul;
	Real** vl;
	MATRNODE** Al; // матрица СЛАУ

	// Шаблоны для граничных условий.
	int itask= CHOHRAVLSKY; // STUDENT DAVIS CHOHRAVLSKY BLASIUS RALEYBENAR  RALEYBENAR_SYMMETRY

	int MC, NC; // C - coarse
	MC = (int)((M + 1) / q) - 1;
	NC = (int)((N + 1) / q) - 1;

	// Граничные условия
	TBONCONDOMAIN my_bound_temp; 
	TBONCONDOMAIN my_bound_temp0;
	TBONCONDOMAIN my_bound_curl;
	TBONCONDOMAIN my_bound_psi;
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_temp, M,N);
	my_alloc_bound(my_bound_temp0, MC, NC);
	my_alloc_bound(my_bound_curl, M,N);
	my_alloc_bound(my_bound_psi, M,N);
	my_alloc_universal(rthdsd_internal, M, N);

    // постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(M+1));
	Real h2=(Real)(lengthy/(N+1));

	
	my_alloc(v1, v1_old, r_coarse, rthdsd_c, Al, MC, NC);
	// Выделение памяти под компоненты скорости на грубой сетке.
    my_alloc_vel_loc(ul, vl, MC, NC);

	// Граничные условия на грубой сетке.
	TBONCONDOMAIN my_bound_coarse_temp; 
	TBONCONDOMAIN my_bound_coarse_curl; 
	TBONCONDOMAIN my_bound_coarse_psi; 
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse_temp, MC,NC);
	my_alloc_bound(my_bound_coarse_curl, MC,NC);
	my_alloc_bound(my_bound_coarse_psi, MC,NC);


	Real* xf=new Real[M+2];
	for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}
	Real* yf=new Real[N+2];
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}

	// Определение контрольной точки.
	Real dist=FLT_MAX;
	for (int i=0; i<M+2; i++) {
		if (fabs(xf[i]-xpoint)<dist) {
			dist=fabs(xf[i]-xpoint);
			ixpoint=i;
		}
	}
	dist=FLT_MAX;
	for (int j=0; j<N+2; j++) {
		if (fabs(yf[j]-ypoint)<dist) {
			dist=fabs(yf[j]-ypoint);
			iypoint=j;
		}
	}
	// печать заголовка.
	exportmonitorpoint(0.0, 0.0, 0.0, 0.0, 0.0, xpoint , ypoint, true);

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	const int EULER = 0; // Первый порядок точности.
	const int PEIRE = 1;
	int itimescheme = PEIRE;// PEIRE 2 порядка.

	int idim = DIMENSIONLESS;// DIMENSIONLESS; // безразмерные DIMENSIONLESS или размерные DIMENSIONAL
#if MY_FLOAT
	// Коэффициенты для воздуха.
	Real Cp=1006.0f;
	Real mu=17.2e-6f;
	Real rho=1.2041f;
	Real lambda=0.026f;
	Real betaT=3.665e-3f;
	Real gy=-9.81e-6f; // 0.000556746; <-> 10^4
	// безразмерные числа подобия.
	// Re=lengthx*U*rho/mu;
	Real Re=1.0f; // Рейнольдс
	// Pr=(mu/rho)/(lambda/(rho*Cp)); 0.6655;
	Real Pr=0.6655e2f; // Прандтль
	Real Gr = 142.857f; //3.0e5f;// 14200.857f; // Грасгоф

	//Pr = 0.71;
	//Gr = 3.0e5 / Pr;

	Real tau=1.0e-6f; // шаг по времени.
#else
	// Коэффициенты для воздуха.
	Real Cp=1006.0;
	Real mu=17.2e-6;
	Real rho=1.2041;
	Real lambda=0.026;
	Real betaT=3.665e-3;
	Real gy=0.0; // 0.000556746; <-> 10^4
	// безразмерные числа подобия.
	Real Re=0.001; // Ренольдс
	Real Pr=100; // Прандтль
    Real Gr=0.0; // Грасгоф
	Real tau=0.01; // шаг по времени.
#endif
	
    printf(" Roache_Fedushkin algorithm \n");
	// Выделение памяти.
	my_alloc_Roach_Fedushkin(curl, stream_function, temperature, u, v, gradxtemperature, M, N);
	my_alloc(potent, potent_old, r, rthdsd, A, M, N);
	my_alloc_curl_old(curl_old, curl_oldi, M, N);
	my_alloc_temp_old(temp_old, M, N);

	my_alloc_temp_old(temp_old2, M, N);
	my_alloc_temp_old(curl_old2, M, N);
	// Инициализация:
	if (itask==BLASIUS) {
		// линейное распределение функции тока.
		my_init_linear(stream_function, 'y', 0.0, lengthy, xf, yf, M, N); // линейное распределение температур.
	}
	else {
		my_init_zero(bleft, bright, bbottom, btop, 0.0, stream_function, M, N);
	}
	my_init_zero(bleft, bright, bbottom, btop, 0.0, curl, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, curl_old, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, curl_oldi, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, u, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, v, M, N);
	if (itask==BLASIUS)
	{
		my_init_zero(bleft, bright, bbottom, btop, 0.0, temperature, M, N);
	    my_init_zero(bleft, bright, bbottom, btop, 0.0, temp_old, M, N);
		my_init_zero(bleft, bright, bbottom, btop, 0.0, temp_old2, M, N);
	}
	if ((itask == RALEYBENAR)||(itask == RALEYBENAR_SYMMETRY))
	{
		my_init_linear(temperature, 'y', 400.0, 300.0, xf, yf, M, N); // линейное распределение температур.
		my_init_linear(temp_old, 'y', 400.0, 300.0, xf, yf, M, N); // линейное распределение температур.
		my_init_linear(temp_old2, 'y', 400.0, 300.0, xf, yf, M, N); // линейное распределение температур.

		for (int i = 0; i < M + 2; i++) {
			for (int j = 1; j < N + 1; j++) {
				temperature[i][j] = temp_old[i][j] = temp_old2[i][j] = 300.0;
			}
		}

		//my_init_zero(300.0, 300.0, 400.0, 300.0, 300.0, temperature, M, N);
		//my_init_zero(300.0, 300.0, 400.0, 300.0, 300.0, temp_old, M, N);
	}
	else
	{
		my_init_linear(temperature, 'x', 1.0, 0.0, xf, yf, M, N); // линейное распределение температур.
		my_init_linear(temp_old, 'x', 1.0, 0.0, xf, yf, M, N); // линейное распределение температур.
		my_init_linear(temp_old2, 'x', 1.0, 0.0, xf, yf, M, N); // линейное распределение температур.
	}

	/* Алгоритм Роуча.
	* 1. Задание безразмерных критериев подобия.
	* 2. Инициализация : функции тока, вихря, граничных условий для вихря, компонент скорости.
	* 3. Инициализация температуры.
	* 4. Вычисление градиента температуры.
	* 5. Решение уравнения для завихрённости : сборка матрицы, правой части и решение СЛАУ.
	* 6. Решение уравнения для функции тока : сборка матрицы, вычисление правой части и решение СЛАУ.
	* 7. Вычисление компонент скорости.
	* 8. Рассчитываются новые граничные условия для вихря на твердой стенке по текущим значениям функции тока и вихря.
	* 9. Решение уравнения для температуры : сборка матрицы, нулевая правая часть, решение СЛАУ.
	* 10. Если сходимость недостигнута то возвращение к пункту 4.
	*/

	/* Экспериментальным путём выяснено, что при полностью неявной схеме дискретизации на сетке 50x50
	* в процессе установления граничного условия для вихря полностью достаточно одной итерации алгоритма В.Г. Зверева,
	* А Зейделя достаточно не менее 7 итераций, это приводит на 3% большему количеству итераций в цикле установления граничных условий для вихря. 
	* При этом для функции тока использовался алгоритм Федоренко на базе LR делая 18 проходов в каждом проходе 4 сглаживающие итерации LR.
	* Замечание. наверно для задачи конвекции - диффузии лучше использовать LR так как у LR более сильное диагональное преобладание.
	*/
	/* Для температуры при Gr=10^5 сходится только LR и то если сделать одну итерацию. ZVER расходится и возможно это связано с тем что у него ослаблено
	* диагональное преобладание. У LR более сильное диагональное преобладание и поэтому он работает.
	*/


	Real dzeta1=1.0, dzeta2=1.0; // (1.0; 0.0 - направленные разности) 1.0; 1.0; - монотонная аппроксимация А.А.Самарского.
	int ialgcurl=STANDART; // STANDART SEIDEL LR SORDIRICHLET ZVER
	int ialgstreamfunc=LR; // STANDART SEIDEL LR SORDIRICHLET ZVER
	int ialgtemp=STANDART; // STANDART SEIDEL LR SORDIRICHLET ZVER
	int iendcurl=1;
	int iendstreamfunc=50;
	int iendtemp=1;
	int itimeapprox= BURAGO; // BURAGO EXPLICIT
	switch (itimeapprox) {
		   case EXPLICIT : ialgcurl=STANDART; ialgstreamfunc=SEIDEL; ialgtemp=STANDART;
			               iendcurl=1; iendstreamfunc=100; iendtemp=0;
			             break;
		   case BURAGO : //ialgcurl=SEIDEL; 
			             //iendcurl=8; 
			             ialgcurl = LR;// SEIDEL;// LR;
			             iendcurl=1;
						 //  4      1
						 // 37.6  28.6
						 ialgstreamfunc = LR; // SEIDEL; // LR 
						 iendstreamfunc=1; 
						 ialgtemp = LR;// SEIDEL; // LR;
						 // 200   100   300  400 LR
						 // 17.3  28.6  10.9 12.1
						 //
						 // 1e-5
						 // 10    20    40
						 // 77    77    77 
						 // 53.8 46.2   45.9
						 iendtemp=1;
			             break;
	}
	int ischemeapprox= TOMA; // условия ТОМА для вихря // TOMA WOODS JENSEN
	Real epsilon_bon_curl = 1.0e-12;// 1e-4; // точность опредеделения граничных условий для вихря.
	Real epsilon_temperature = 1.0e-12;// 0.0005; // точность определения поля температуры на данной стационарной итерации. Рассогласование в каждой точке не более 5 сотых градуса.
	//if (itask == RALEYBENAR) {
		//epsilon_temperature = 1.0e-11;
	//}
	Real stream_function_drop_tolerance = 1.0e-12;// 1e-6; // точность с которой решается уравнение для функции тока.
	Real bweshouldbecontinue=true;
	Real vorticity_boundary_conditions; // точность выполнения граничных условий для завихрённости.
	int iconstrA= PATANKAR; // алгоритм сборки матрицы PATANKAR SAMARSKII (монотонная аппроксимация Самарского работает только для равномерной сетки).
	
	bool bweshouldbecontinuetemp=true;
	

	Real time=0.0;
	Real dtime=tau;

	bool btimedepend = false;// true; // false == стационарный солвер.
	Real alpha = 0.2; // параметр нижней релаксации для вихря.
	if (btimedepend) {
		alpha = 0.8; // параметр нижней релаксации для вихря.
	}
	int iendtimestep=2200; // 200 периодов.
	int ienditer=2200; // количество стационарных итераций.
	if (!btimedepend) {
		iendtimestep=1; // стационарный солвер.
	}
	int ic1=0;

	for (int inumbertimestep=0; inumbertimestep<iendtimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=tau;

		//switch (itimeapprox) {
		  // case EXPLICIT : tau=minf(time_limiter_all_explicit(rho/mu, u, v, xf, yf, M, N), dtime);  break;
		   //case BURAGO : //tau=minf(time_limiter_Burago(rho/mu, u, v, M, N), dtime); 
	    // break;
		//}
		//if (fabs(tau) < 1.0e-20) {
			//std::cout << tau << " tau is zero error\n";
			//getchar();
		//}

		bweshouldbecontinue = true;
		bweshouldbecontinuetemp=true;
		int iter=0;
		while (bweshouldbecontinuetemp&&(iter<ienditer)) {
			
             // итерации стационарного солвера.
		

		     // 4. Вычисление градиента температуры.
		     calc_gradx(gradxtemperature, temperature, xf, yf, M, N);

		     // цикл в котором вычисляются текущие граничные условия для вихря.
			 //bweshouldbecontinue=true;

		     int iteri=0;

		     //while (bweshouldbecontinue) 
			 {

				 //getchar();

		          // 5. Решение уравнения для завихрённости : сборка матрицы, правой части и решение СЛАУ.

				 load_my_bound_curl(my_bound_curl, itask, curl, stream_function, u, v, ischemeapprox, alpha, time, xf, yf, M, N);

				 

			      switch(iconstrA) {
			           case SAMARSKII :   
						   
						             if (idim==DIMENSIONLESS) {
										 // безразмерные
										 constrASamarskii(A, my_bound_curl, u, v, 1.0/Re, dzeta1, dzeta2, xf, yf, M, N); // сборка матрицы.
									 }
									 else if (idim==DIMENSIONAL) {
										 // размерные
						                 constrASamarskii(A, my_bound_curl, u, v, mu/rho, dzeta1, dzeta2, xf, yf, M, N); // сборка матрицы.
									 }
			
		                              for (int i=0; i<M+2; i++) {
		                                   for (int j=0; j<N+2; j++) {
				                               // инициализация рассчитываемых величин.
				                               potent[i][j]=curl[i][j];
				                               potent_old[i][j]=curl[i][j];
		                                   }
	                                  }
							          for (int i=1; i<M+1; i++) {
		                                  for (int j=1; j<N+1; j++) {
				                              // правая часть :
											  if (idim==DIMENSIONLESS) {
										          // безразмерные
												  rthdsd_internal[i][j]=-(Gr/(Re*Re))*gradxtemperature[i][j];
											  }
											  else if (idim==DIMENSIONAL) {
										         // размерные
			                                     rthdsd_internal[i][j]=rho*gy*betaT*gradxtemperature[i][j];
											  }
									      }
								      }
									  if (btimedepend) {
										  // нестационарный солвер.
		                                 for (int i=1; i<M+1; i++) {
		                                     for (int j=1; j<N+1; j++) {
				                                 A[i][j].ap=1.0+tau*A[i][j].ap;
				                                 A[i][j].ae*=tau;
				                                 A[i][j].an*=tau;
				                                 A[i][j].as*=tau;
				                                 A[i][j].aw*=tau;
				                                 rthdsd_internal[i][j]+=curl_old[i][j];
			                                 }
		                                 }
									  }

								      // нижняя релаксация для вихря.
						              for (int i=1; i<M+1; i++) {
		                                  for (int j=1; j<N+1; j++) {
				                              A[i][j].ap/=alpha;				                        
				                              rthdsd_internal[i][j]+=A[i][j].ap*(1.0-alpha)*curl_oldi[i][j];
			                              }
		                              }

								   break;
			           case PATANKAR :	
						   
						            if (idim==DIMENSIONLESS) {
										 // безразмерные
										// constrAPatankar(A, my_bound_curl, u, v, 1.0, 1.0/Re, xf, yf, M, N);
										 constrAPatankar(A, my_bound_curl, curl, rthdsd_internal, u, v, 1.0, 1.0 / Re, xf, yf, M, N);
									}
									else if (idim==DIMENSIONAL) {
										 // размерные
						                 //constrAPatankar(A, my_bound_curl, u, v, rho, mu, xf, yf, M, N);
										 constrAPatankar(A, my_bound_curl, curl, rthdsd_internal,  u, v, rho, mu, xf, yf, M, N);
									}

#pragma omp parallel for
				                   for (int i=0; i<M+2; i++) {
		                                for (int j=0; j<N+2; j++) {
				                             // инициализация рассчитываемых величин.
				                             potent[i][j]=curl[i][j];
				                             potent_old[i][j]=curl[i][j];
		                                }
	                                }

								   
#pragma omp parallel for
						            for (int i=1; i<M+1; i++) {
		                                for (int j=1; j<N+1; j++) {
				                            // правая часть :
											 if (idim==DIMENSIONLESS) {
										         // безразмерные
												 rthdsd_internal[i][j]+=-(Gr/(Re*Re))*gradxtemperature[i][j]*h1*h2;
											 }
											 else if (idim==DIMENSIONAL) {
										         // размерные
			                                     rthdsd_internal[i][j]+=rho*gy*betaT*gradxtemperature[i][j]*h1*h2;
											 }
											 
									    }
						            }
									
									if (btimedepend) {
										  // нестационарный солвер.
						  				  
												  if (itimescheme == PEIRE) {
													  if (idim == DIMENSIONLESS) {
														  // безразмерные
#pragma omp parallel for
														  for (int i = 1; i < M + 1; i++) {
															  for (int j = 1; j < N + 1; j++) {
																  A[i][j].ap += 3.0 * h1 * h2 / (2.0 * tau);
																  rthdsd_internal[i][j] += h1 * h2 * (4.0 * curl_old[i][j] - curl_old2[i][j]) / (2.0 * tau);
															  }
														  }
													  }
													  else if (idim == DIMENSIONAL) {
														  // размерные
#pragma omp parallel for
														  for (int i = 1; i < M + 1; i++) {
															  for (int j = 1; j < N + 1; j++) {
																  A[i][j].ap += 3.0 * rho * h1 * h2 / (2.0 * tau);
																  rthdsd_internal[i][j] += rho * h1 * h2 * (4.0 * curl_old[i][j] - curl_old2[i][j]) / (2.0 * tau);
															  }
														  }
													  }
												  }
												  else {
													  if (idim == DIMENSIONLESS) {
														  // безразмерные
#pragma omp parallel for
														  for (int i = 1; i < M + 1; i++) {
															  for (int j = 1; j < N + 1; j++) {
																  A[i][j].ap += h1 * h2 / tau;
																  rthdsd_internal[i][j] += h1 * h2 * curl_old[i][j] / tau;
															  }
														  }
													  }
													  else if (idim == DIMENSIONAL) {
														  // размерные
#pragma omp parallel for
														  for (int i = 1; i < M + 1; i++) {
															  for (int j = 1; j < N + 1; j++) {
																  A[i][j].ap += rho * h1 * h2 / tau;
																  rthdsd_internal[i][j] += rho * h1 * h2 * curl_old[i][j] / tau;
															  }
														  }
													  }
												  }
			                             
									}

						            // нижняя релаксация для вихря.
#pragma omp parallel for
						            for (int i=1; i<M+1; i++) {
		                                for (int j=1; j<N+1; j++) {
											
				                            A[i][j].ap/=alpha;				                        
				                            rthdsd_internal[i][j]+=A[i][j].ap*(1.0-alpha)*curl_oldi[i][j];
			                            }
		                            }
				                   break;
			      }

				  constrrthdsd0(rthdsd, rthdsd_internal, my_bound_curl, xf, yf, M, N); // правая часть.

		          // невязка :
		          residual(r, potent_old, rthdsd,  A, M, N);
				 // printf("%e\n",normar(r, M, N));
				  //getchar();

		          // решение СЛАУ:
		          itsolve_naiv(potent, potent_old, r, rthdsd, M, N, ialgcurl, A, iendcurl); // полностью явная схема при iendcurl==1 и ialgcurl==STANDART.
				  // Явная схема обладает очень жёстким ограничением на шаг по времени. В тоже время одна итерация полинейного метода вполне достаточна для 
				  // сходимости и не имеет ограничений на шаг по времени. Но на самом деле любой segregate имеет ограничение на шаг по времени.
				  // В общем было выяснено что увеличение количества итераций полинейного метода в данном месте не оказывает влияния на скорость выполнения
				  // точного граничного условия для вихря. Т.е. алгоритм Федоренко здесь по видимому не нужен. Многое зависит от возможности расчёта на неравномерной сетке.
				 
				  // для алгебраического многосеточного метода amg1r5:
	              //Real* dX0 = new Real[(M + 2) * (N + 2)];
				  //amg_loc_memory(potent, rthdsd, A, M, N, 0, dX0);
	              //amg_global_memory(potent, rthdsd, A, M, N, 0, dX0);
	              //delete[] dX0;

		          /*
		          // Для вспомогательной системы имеем однородные граничные условия.
	              my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
	              //constrA0(Al, 1.0, MC, NC); // сборка матрицы.
		          // передача компонент скорости на грубую сетку.
		          my_restriction1(u, ul, M, N);
		          my_restriction1(v, vl, M, N);
		          constrASamarskii(Al, ul, vl, 1.0/Re, dzeta1, dzeta2, MC, NC); // сборка матрицы.
	              for (int i=0; i<MC+2; i++) {
		              for (int j=0; j<NC+2; j++) {
			              r_coarse[i][j]=0.0;
			              rthdsd_c[i][j]=0.0;
		              }
	              }
	              itsolve_Fedor(potent, potent_old, r, rthdsd, M, N, v1, v1_old,  r_coarse, rthdsd_c, MC, NC,ialgstreamfunc, A, Al);
		          //*/

		          // 6. Решение уравнения для функции тока : сборка матрицы, вычисление правой части и решение СЛАУ.

				  // Граничные условия для функции тока.
                  load_my_bound_stream_function(my_bound_psi, itask, time, xf, yf, M , N);

		          constrA0(A, my_bound_psi, 1.0, xf, yf, M, N); // сборка матрицы.
#pragma omp parallel for
		          for (int i=0; i<M+2; i++) {
		              for (int j=0; j<N+2; j++) {
				          // правая часть :
				          //curl[i][j]=potent[i][j]; // запоминаем рассчитанный вихрь.
						  if (btimedepend) {
							  curl[i][j] = curl_oldi[i][j] + 0.75 * (potent[i][j] - curl_oldi[i][j]); // запоминаем рассчитанный вихрь.
						  }
						  else {
							  curl[i][j] = curl_oldi[i][j] + 0.25 * (potent[i][j] - curl_oldi[i][j]); // запоминаем рассчитанный вихрь.
						  }
						  // инициализация рассчитываемых величин.
				          potent[i][j]=stream_function[i][j];
				          potent_old[i][j]=stream_function[i][j];
		              }
	              }
#pragma omp parallel for
			      for (int i=1; i<M+1; i++) {
		              for (int j=1; j<N+1; j++) {
				          // правая часть :
					      rthdsd_internal[i][j]=-curl[i][j]; // правая часть в уравнении для функции тока.
						 // rthdsd_internal[i][j]=-curl[i][j]; // для метода конечных разностей.
						  // так как теперь уравнение чистой дифузии собирается по способу контрольного объёма, то правую часть
						  // источниковый член теперь надо умножать на объём контрольного объёма.
						  // на объём контрольного объёма умножать ненужно если сборка осуществляется по способу конечных разностей.
				      }
			      }

				  constrrthdsd0(rthdsd, rthdsd_internal, my_bound_psi, xf, yf, M, N); // правая часть.

		          // невязка :
		          residual(r, potent_old, rthdsd,  A, M, N);
		          
				 
				  
				  // Граничные условия для функции тока
				  // на грубой сетке.
                  load_my_bound_stream_function(my_bound_coarse_psi, itask, time, xc, yc, MC , NC);

				  if (1) {

					  //R_Bellmanq(M, N, potent, rthdsd);
					  DFTq(M, N, potent, rthdsd);
				  }
				  else {

					  // Для вспомогательной системы имеем однородные граничные условия.
					  my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
					  constrA0(Al, my_bound_coarse_psi, 1.0, xc, yc, MC, NC); // сборка матрицы.
					  for (int i = 0; i < MC + 2; i++) {
						  for (int j = 0; j < NC + 2; j++) {
							  // инициализация.
							  // Здесь просто инициализация нулём не надо ничего заполнять 
							  // всё будет заполнено внутри алгоритма Федоренко.
							  r_coarse[i][j] = 0.0;
							  rthdsd_c[i][j] = 0.0;
						  }
					  }
					  // По видимому эллиптическое уравнение для функции тока требуется решать достаточно точно и здесь необойтись без быстросходящегося алгоритма.
					  int iend = 2300;
					  Real* residual_history = new Real[iend + 1];
					  for (int i = 0; i < iend; i++) {
						  residual_history[i] = 1.0; // инициализация.
					  }
					  int iendit = 1;
					  // itsolve_krjlov(potent, potent_old, r, rthdsd, M, N, ICCGalg, A, (int)(1.3*sqrt((float)(M+2)*(N+2))) );
					  iendit = itsolve_Fedor(potent, potent_old, r, rthdsd, M, N, v1, v1_old, r_coarse, rthdsd_c, MC, NC, ialgstreamfunc, A, Al, stream_function_drop_tolerance, residual_history);
					  // нормированная октаэдрическая норма (сумма модулей).
					  for (int i = 1; i < iendit; i++) {
						  residual_history[i] = residual_history[i] / residual_history[0];
					  }
					  residual_history[0] = 1.0;

					  //for (int i=0; i<iendit; i++) {
						 // printf("  %d   %1.4e  \n",i+1,residual_history[i]);
					  //}
					  delete[] residual_history;
					  //getchar();

									// решение СЛАУ:
									// Как альтернатив более медленно сходящийся солвер, он прост в использовании и на нём можно потренироваться.
								   //-----> itsolve_naiv(potent, potent_old, r, rthdsd, M, N, ialgstreamfunc, A,iendstreamfunc);

				  }
				 // 7. Вычисление компонент скорости.

#pragma omp parallel for
		          for (int i=0; i<M+2; i++) {
		              for (int j=0; j<N+2; j++) {
				          stream_function[i][j]=potent[i][j];
			          }
		          }

				  if (itask == BLASIUS) {
					  // Данные параметры настроены на задачу Блазиуса.
					  stream_function[0][0]=0.0;
					  stream_function[M+1][0]=amplitude0*(lengthx/9.0)*sin(Omega*time);
					  stream_function[0][N+1]=lengthy; // 1.0 безразмерная область
					  stream_function[M+1][N+1]=lengthy; // 1.0 безразмерная область
				  }
				  else {
					  stream_function[0][0] = 0.0;
					  stream_function[M + 1][0] = 0.0;
					  stream_function[0][N + 1] = 0.0; // 1.0 безразмерная область
					  stream_function[M + 1][N + 1] = 0.0; // 1.0 безразмерная область
				  }

		          // Экономично находит компоненты скорости по рассчитанной функции тока.
                  //calcvelocity1(stream_function, u, v,  M, N);
				  calcvelocity1(stream_function, u, v, xf, yf, M, N);
		          // 8. Рассчитываются новые граничные условия для вихря на твердой стенке по текущим значениям функции тока и вихря.
				  // Здесь введена нижняя релаксация см. Полежаев Пасконов Чудов.
		          //----->//curlbound(curl, stream_function, ischemeapprox, M, N, alpha);
				  // Здесь также нужно сделать обновление всех гидродинамических 
				  // граничных условий для всех величин смотри например задачу Блазиуса. 

			      bweshouldbecontinue=bfinish(curl, curl_oldi, epsilon_bon_curl, vorticity_boundary_conditions, M, N);

#pragma omp parallel for
			      for (int i=0; i<M+2; i++) {
		              for (int j=0; j<N+2; j++) {
					      curl_oldi[i][j]=curl[i][j];
				      }
		          }

			      if (ic1%10==0) {
				     // printf("vorticity_boundary_conditions\n");
			      }
				  ic1++;
			      //printf("%d %1.4e\n",ic1, vorticity_boundary_conditions);

				  if (vorticity_boundary_conditions < 3.0e-2) {
					 // break;
				  }

				 //// if (iteri > 200) break;
			      iteri++;
				  //getchar();
		     } // конец определения граничных условий для вихря.

			 //getchar();

		     // 9. Решение уравнения для температуры : сборка матрицы, нулевая правая часть, решение СЛАУ.
			 load_my_bound_temp(my_bound_temp, itask, xf, yf, M,N);

		     switch(iconstrA) {
			      case SAMARSKII : 
					                if (idim==DIMENSIONLESS) {
										 // безразмерные
										 constrASamarskii(A, my_bound_temp, u, v, 1.0/(Re*Pr), dzeta1, dzeta2, xf, yf, M, N);  // сборка матрицы.
									 }
									 else if (idim==DIMENSIONAL) {
										 // размерные
						                 constrASamarskii(A, my_bound_temp, u, v, lambda/(rho*Cp), dzeta1, dzeta2, xf, yf, M, N); // сборка матрицы.
									 }

		                      
		                     for (int i=0; i<M+2; i++) {
		                         for (int j=0; j<N+2; j++) {
				                    // инициализация рассчитываемых величин.
				                    potent[i][j]=temperature[i][j];
				                    potent_old[i][j]=temperature[i][j];
		                         }
	                         }

							 for (int i=1; i<M+1; i++) {
		                         for (int j=1; j<N+1; j++) {
				                    // правая часть :
			                        rthdsd_internal[i][j]=0.0;
								 }
							 }

							 if (btimedepend) {
									// нестационарный солвер.
		                            for (int i=1; i<M+1; i++) {
		                                for (int j=1; j<N+1; j++) {
			                    	        A[i][j].ap=1.0+tau*A[i][j].ap;
				                            A[i][j].ae*=tau;
				                            A[i][j].an*=tau;
				                            A[i][j].as*=tau;
				                            A[i][j].aw*=tau;
				                            rthdsd_internal[i][j]+=temp_old[i][j];
			                            }
		                            }
							 }
		                     break;
			      case PATANKAR :	if (idim==DIMENSIONLESS) {
										 // безразмерные
					                     //constrAPatankar(A, my_bound_temp, u, v, 1.0, 1.0/(Re*Pr), xf, yf, M, N);
					                     constrAPatankar(A, my_bound_temp, temperature, rthdsd_internal, u, v, 1.0, 1.0 / (Re * Pr), xf, yf, M, N);
					                 }
									 else if (idim==DIMENSIONAL) {
										 // размерные
					                     //constrAPatankar(A, my_bound_temp, u, v, rho*Cp, lambda, xf, yf, M, N);
										 constrAPatankar(A, my_bound_temp, temperature, rthdsd_internal, u, v, rho* Cp, lambda, xf, yf, M, N);
									 }

#pragma omp parallel for
				                    for (int i=0; i<M+2; i++) {
		                                 for (int j=0; j<N+2; j++) {
				                             // инициализация рассчитываемых величин.
				                             potent[i][j]=temperature[i][j];
				                             potent_old[i][j]=temperature[i][j];
		                                 }
	                                }

#pragma omp parallel for
						            for (int i=1; i<M+1; i++) {
		                                 for (int j=1; j<N+1; j++) {
				                             // правая часть :
			                                 //rthdsd_internal[i][j]=0.0*h1*h2;
									     }
						            }
						  
						            if (btimedepend) {
									    // нестационарный солвер.
										if (itimescheme == PEIRE) {
											if (idim == DIMENSIONLESS) {
												// безразмерные
#pragma omp parallel for
												for (int i = 1; i < M + 1; i++) {
													for (int j = 1; j < N + 1; j++) {
														A[i][j].ap += 3.0 * h1 * h2 / (2.0 * tau);
														rthdsd_internal[i][j] += h1 * h2 * (4.0 * temp_old[i][j] - temp_old2[i][j]) / (2.0 * tau);
													}
												}
											}
											else if (idim == DIMENSIONAL) {
												// размерные
#pragma omp parallel for
												for (int i = 1; i < M + 1; i++) {
													for (int j = 1; j < N + 1; j++) {
														A[i][j].ap += 3.0 * rho * Cp * h1 * h2 / (2.0 * tau);
														rthdsd_internal[i][j] += rho * Cp * h1 * h2 * (4.0 * temp_old[i][j] - temp_old2[i][j]) / (2.0 * tau);
													}
												}
											}
										}
										else {
											if (idim == DIMENSIONLESS) {
												// безразмерные
#pragma omp parallel for
												for (int i = 1; i < M + 1; i++) {
													for (int j = 1; j < N + 1; j++) {
														A[i][j].ap += h1 * h2 / tau;
														rthdsd_internal[i][j] += h1 * h2 * temp_old[i][j] / tau;
													}
												}
											}
											else  if (idim == DIMENSIONAL) {
#pragma omp parallel for
												for (int i = 1; i < M + 1; i++) {
													for (int j = 1; j < N + 1; j++) {
														A[i][j].ap += rho * Cp * h1 * h2 / tau;
														rthdsd_internal[i][j] += rho * Cp * h1 * h2 * temp_old[i][j] / tau;
													}
												}
											}
										}
									}
								
				             break;
			       }

			       constrrthdsd0(rthdsd, rthdsd_internal, my_bound_temp, xf, yf, M, N); // правая часть.

		           // невязка :
		           residual(r, potent_old, rthdsd,  A, M, N);
				   //exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, temp_old, gradxtemperature, xf, yf, M, N);
				   //printf("%e %e %e %e %e\n",A[5][5].ae,A[5][5].an,A[5][5].as,A[5][5].aw,A[5][5].ap);
				   //printf("start");
				   //getchar();

				   //bflag=true;
		           // решение СЛАУ:
		           itsolve_naiv(potent, potent_old, r, rthdsd, M, N, ialgtemp, A, iendtemp); // полностью явная схема при iendtemp==1 && ialgtemp==STANDART
				   // Дело в том что явная схема очень ограничительна в плане шага по времени поэтому здесь нужно использовать неявную схему которая не имеет ограничения
				   // на шаг по времени. Для этих целей вполне достаточно одной итерации полинейного метода.
				   // Вычисление на данном итерационном цикле нужно продолжать до тех пор пока поле температур не перестанет изменяться от итерации к итерации.
		
				   if (0) {
					   // Подавляет начало конвекции в задаче Бенара подогрева снизу.

					   // для алгебраического многосеточного метода amg1r5:
					   Real* dX0 = new Real[(M + 2) * (N + 2)];
					   //amg_loc_memory(potent, rthdsd, A, M, N, 0, dX0);
					   amg_global_memory(potent, rthdsd, A, M, N, 0, dX0);
					   delete[] dX0;
				   }
				   else if (0) {
					
				   
					   ///-----------------------

					   // Для вспомогательной системы имеем однородные граничные условия.
					   my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
					   // передача компонент скорости на грубую сетку.
					   my_restriction1(u, ul, M, N);
					   my_restriction1(v, vl, M, N);
					   load_my_bound_temp0(my_bound_temp0, itask, xc, yc, MC, NC);
					   switch (iconstrA) {
					   case SAMARSKII:
						   constrASamarskii(Al, my_bound_temp0, ul, vl, 1.0 / Pr, dzeta1, dzeta2, xc, yc, MC, NC); // сборка матрицы.
						   break;
					   case PATANKAR:
						   // безразмерные
						   constrAPatankar(Al, my_bound_temp0, ul, vl, 1.0, 1.0 / (Re * Pr), xc, yc, MC, NC);
						   break;
					   }

#pragma omp parallel for
					   for (int i = 0; i < MC + 2; i++) {
						   for (int j = 0; j < NC + 2; j++) {
							   r_coarse[i][j] = 0.0;
							   rthdsd_c[i][j] = 0.0;
						   }
					   }
					   // По видимому эллиптическое уравнение для функции тока требуется решать достаточно точно и здесь необойтись без быстросходящегося алгоритма.
					   int iendt = 3300;
					   Real* residual_historyt = new Real[iendt + 1];
					   for (int i = 0; i < iendt; i++) {
						   residual_historyt[i] = 1.0; // инициализация.
					   }
					   int iendit1 = 1;


					   // 0.1   0.01 0.001
					   // 55    38
					   // 32.7  14.5 14.1
					   iendit1 = itsolve_Fedor(potent, potent_old, r, rthdsd, M, N, v1, v1_old, r_coarse, rthdsd_c, MC, NC, ialgstreamfunc, A, Al, 0.00001 * epsilon_temperature, residual_historyt);

					   // нормированная октаэдрическая норма (сумма модулей).
					   for (int i = 1; i < iendit1; i++) {
						   residual_historyt[i] = residual_historyt[i] / residual_historyt[0];
					   }
					   residual_historyt[0] = 1.0;

					   //for (int i=0; i<iendit1; i++) {
						  // printf("  %d   %1.4e  \n",i+1,residual_historyt[i]);
					   //}
					   delete[] residual_historyt;
					   //getchar();
				   }

				   Real temperature_mismatch;
				   bweshouldbecontinuetemp=bfinish_temp(potent, temperature, 1.0e-11, temperature_mismatch, M, N);
				   printf("%d temperature mismatch is equal=%1.4e\n", iter, temperature_mismatch);
				   //getchar();

#pragma omp parallel for
		           for (int i=0; i<M+2; i++) {
		               for (int j=0; j<N+2; j++) {
				           temperature[i][j]=potent[i][j];
			           }
		           }
		           // 10. Если сходимость недостигнута то возвращение к пункту 4.
		           //getchar();

				   //exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, u, v, xf, yf, M, N);
				   //getchar();
		
				   iter++;
	    } // стационарные итерации алгоритма.

		// Запоминаем вихрь с текущего временного слоя.
#pragma omp parallel for
		for (int i=0; i<M+2; i++) {
		    for (int j=0; j<N+2; j++) {
				curl_old2[i][j] = curl_old[i][j];
				curl_old[i][j]=curl[i][j];
			}
		}

		// запоминаем температуру с предыдущего временного слоя.
#pragma omp parallel for
		for (int i=0; i<M+2; i++) {
		    for (int j=0; j<N+2; j++) {
				temp_old2[i][j] = temp_old[i][j];
				temp_old[i][j]=temperature[i][j];
			}
		}

		avgpointxvel+=u[ixpoint][iypoint];
		avgpointyvel+=v[ixpoint][iypoint];
	    avgpointcurl+=curl[ixpoint][iypoint];
		avgpointstreamfunc+=stream_function[ixpoint][iypoint];
		avgpointtemperature+=temperature[ixpoint][iypoint];
#pragma omp parallel for
		for (int i=0; i<M+2; i++) {
			for (int j=0; j<N+2; j++) {
				avgmag[i][j]+=sqrt(u[i][j]*u[i][j]+v[i][j]*v[i][j]);
				avgxvel[i][j]+=u[i][j];
				avgyvel[i][j]+=v[i][j];
				avgcurl[i][j]+=curl[i][j];
				avgsf[i][j]+=stream_function[i][j];
				avgtemp[i][j]+=temperature[i][j];
			}
		}


		if (inumbertimestep%100==0) {
			avgpointxvel/=100.0;
			avgpointyvel/=100.0;
			avgpointcurl/=100.0;
			avgpointstreamfunc/=100.0;
			avgpointtemperature/=100.0;
			// печать осреднённых за период значений в контрольной точке.
			exportmonitorpoint(avgpointxvel, avgpointyvel, avgpointcurl, avgpointstreamfunc, avgpointtemperature, xpoint , ypoint, false);
			// сброс.
			avgpointxvel=0.0;
			avgpointyvel=0.0;
			avgpointcurl=0.0;
			avgpointstreamfunc=0.0;
			avgpointtemperature=0.0;

			for (int i=0; i<M+2; i++) {
			   for (int j=0; j<N+2; j++) {
			      avgmag[i][j]/=100.0;
			      avgxvel[i][j]/=100.0;
			      avgyvel[i][j]/=100.0;
			      avgcurl[i][j]/=100.0;
			      avgsf[i][j]/=100.0;
			      avgtemp[i][j]/=100.0;
				}
		    }
			exporttecplotNSRoacheFedushkin(avgcurl, avgsf, avgtemp, avgxvel, avgyvel, xf, yf, M, N);
			// инициализация нулём.
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgmag, M, N);
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgxvel, M, N);
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgyvel, M, N);
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgcurl, M, N);
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgsf, M, N);
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgtemp, M, N);
		}

	    //exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, u, v, xf, yf, M, N);
		//exporttecplotNSRoacheFedushkinanimate(curl, stream_function, temperature, u, v, xf, yf, icadr++, M, N);
		if (btimedepend)  {
			printf("time\n");
		    printf("%e\n",time);
		}

		

	} // шаги по времени.

	if (btimedepend)  {
	    printf("time=%e\n",time);
	}

	// печать в файл рассчитанной температуры перпендикуляно пластине
    // в точке проходящей через её центр.
    exportgradtemp(avgtemp, yf, ixpoint, M, N);

	// уничтожение памяти.
	my_free_universal(avgmag, M,N);
	my_free_universal(avgxvel, M,N);
	my_free_universal(avgyvel, M,N);
	my_free_universal(avgcurl, M,N);
	my_free_universal(avgsf, M,N);
	my_free_universal(avgtemp, M,N);

    calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");

	// экспорт результата вычисления в программу tecplot.
    exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, u, v, xf, yf, M, N);
	//getchar();

} // Roache_Fedushkin_Fedorenko

// Решение уравнений термовибрационной конвекции в прямоугольной области.
// Уравнения Зеньковской-Симоненко. В неакустическом приближении (несжимаемость выполнена).
void Simonenko_Zinkovskaya() {
	// Внимание. Особенность реализации программы такова, что требуется домножать реальную rthdsd
	// полученную строго аналитически на минус 1. !!!

    // По умолчанию данная реализация такова что положительные gy соответствуют направленным вверх, 
	// и направление вибраций также вверх. Система уравнений полностью соответствует записанной в документации на программу,
	// при реализации надо только не забывать умножать на минус единицу все правые части.


	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.

	calculation_start_time=clock(); // момент начала счёта.

	Real pointxvel;
	Real pointyvel;
	Real pointcurl;
	Real pointstreamfunc;
	Real pointtemperature;
	Real xpoint;
	Real ypoint;

	xpoint=0.5;
	ypoint=0.5;
	int ixpoint=0;
	int iypoint=0;

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(M+1));
	Real h2=(Real)(lengthy/(N+1));

	Real* xf=new Real[M+2];
	for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}
	Real* yf=new Real[N+2];
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}

	// Определение контрольной точки.
	Real dist=FLT_MAX;
	for (int i=0; i<M+2; i++) {
		if (fabs(xf[i]-xpoint)<dist) {
			dist=fabs(xf[i]-xpoint);
			ixpoint=i;
		}
	}
	dist=FLT_MAX;
	for (int j=0; j<N+2; j++) {
		if (fabs(yf[j]-ypoint)<dist) {
			dist=fabs(yf[j]-ypoint);
			iypoint=j;
		}
	}
	// печать заголовка Симоненко Зиньковская.
	exportmonitorpointSZ(0.0, 0.0, 0.0, 0.0, 0.0, xpoint , ypoint, true);

	// граничные условия Дирихле в прямоугольнике:
	// Температура в Кельвинах.
	Real bleft=0.0;
	Real bright=0.0;
	Real btop=0.0;
	Real bbottom=0.0;
	// Постоянный коэффициент теплопроводности при 300К
	//Real K300=120.0;

	// функции для решения уравнений Симоненко Зиньковской.
	Real** curl; // вихрь;
	Real** curl_oldi; // вихрь с предыдущей внутренней итерации.
	Real** curl_old; // вихрь с предыдущего временного слоя.
	Real** temp_old; // температура с предыдущего временного слоя.
	Real** stream_function; // функция тока;
	Real** temperature; // температура;
	Real** u; // горизонтальная скорость;
	Real** v; // вертикальная скорость;
	Real** gradxtemperature; // градиент температуры по оси х.
	Real** gradytemperature; // гроадиент температуры по оси y.
	Real** Gpot;
	Real** gradxGpot; // градиент по оси х.
	Real** gradyGpot; // гроадиент по оси y.
	Real** gradxyGpot;
	Real** gradxxGpot;
	Real** gradxyyGpot;
	Real** gradxxyGpot;
	Real** Fpot;
	Real** gradxFpot; // градиент по оси х.
	Real** gradyFpot; // гроадиент по оси y.
	Real** Kpot;
	Real** gradxKpot; // градиент по оси х.
	//Real** JGF; // Якобианы
	//Real** JGT;



	// функции для решения СЛАУ.
	Real** potent; // рассчитываемый потенциал.
    Real** potent_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd; // правая часть
	Real** rthdsd_internal; // внутренность : правая часть
	MATRNODE** A; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v1;
    Real** v1_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	//Real** ul;
	//Real** vl;
	MATRNODE** Al; // матрица СЛАУ

	// Шаблоны для граничных условий.
	int itask= CHOHRAVLSKY; // DAVIS пока только Vahl Davis CHOHRAVLSKY RALEYBENAR

	// Граничные условия
	TBONCONDOMAIN my_bound_temp; 
	TBONCONDOMAIN my_bound_curl;
	TBONCONDOMAIN my_bound_psi;
	TBONCONDOMAIN my_bound_Gpot;
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_temp, M,N);
	my_alloc_bound(my_bound_curl, M,N);
	my_alloc_bound(my_bound_psi, M,N);
	my_alloc_bound(my_bound_Gpot, M,N);

	my_alloc_universal(rthdsd_internal, M, N);

	int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;
	my_alloc(v1, v1_old, r_coarse, rthdsd_c, Al, MC, NC);
	// Выделение памяти под компоненты скорости на грубой сетке.
    // my_alloc_vel_loc(ul, vl, MC, NC);

	// Граничные условия на грубой сетке.
	//TBONCONDOMAIN my_bound_coarse_temp; 
	//TBONCONDOMAIN my_bound_coarse_curl; 
	TBONCONDOMAIN my_bound_coarse_psi; 
	TBONCONDOMAIN my_bound_coarse_Gpot;
	// Выделение памяти под граничные условия.
    //my_alloc_bound(my_bound_coarse_temp, MC,NC);
	//my_alloc_bound(my_bound_coarse_curl, MC,NC);
	my_alloc_bound(my_bound_coarse_psi, MC,NC);
	my_alloc_bound(my_bound_coarse_Gpot, MC,NC);

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	int idim=DIMENSIONAL; // безразмерные DIMENSIONLESS или размерные DIMENSIONAL
 #if MY_FLOAT
	// Расплав теллурида кадмия // Коэффициенты для воздуха.
	Real Cp = 205;// 1006.0f;// 390;// 1006.0f;
	Real mu = 0.00235395;// 17.2e-6f;//17.2e-6; воздух
	Real rho = 5860.0;// 1.2041f;// 8930;// 1.2041f;
	Real lambda = 5.85;// 0.026;// 390;// 2.6e-4f;//0.026; воздух
	Real betaT = 0.3622e-3;// 3.665e-3f;
	Real gy= 0.0f;//-0.0000005567; // 0.000556746; <-> 10^4 Если gy>0 то сила тяжести направлена вверх.
	Real epsilon_vibr = 1.97e-3;// 5.0e-4;// e2f;// 1.53301e-8 <-> 100 = Ra_vibr
	// безразмерные числа подобия.
	Real Re=1.0f; // Ренольдс
	Real Pr=0.0824f;//0.7 // Прандтль
    Real Gr=0.0f; // Грасгоф
	Real tau=3.0e-3f; // шаг по времени.
#else
	// Коэффициенты для воздуха.
	Real Cp=1006.0;
	Real mu=17.2e-4;//17.2e-6; воздух
	Real rho=1.2041;
	Real lambda=2.6e-4;//0.026; воздух
	Real betaT=3.665e-3;
	Real gy=0.0;//-0.0000005567; // 0.000556746; <-> 10^4 Если gy>0 то сила тяжести направлена вверх.
	Real epsilon_vibr=1.53301e-2;// 1.53301e-8 <-> 100 = Ra_vibr
	// безразмерные числа подобия.
	Real Re=0.001; // Ренольдс
	Real Pr=100; // Прандтль
    Real Gr=0.0; // Грасгоф
	Real tau=1; // шаг по времени.
#endif
	
    printf(" Simonenko Zinkovskaya algorithm \n");
	// Выделение памяти.
	my_alloc_Roach_Fedushkin(curl, stream_function, temperature, u, v, gradxtemperature, M, N);
	my_alloc(potent, potent_old, r, rthdsd, A, M, N);
	my_alloc_curl_old(curl_old, curl_oldi, M, N);
	my_alloc_temp_old(temp_old, M, N);
	my_alloc_universal(gradytemperature,M,N); // гроадиент температуры по оси y.
	my_alloc_universal(Gpot,M,N);
	my_alloc_universal(gradxGpot,M,N); // градиент по оси х.
	my_alloc_universal(gradyGpot,M,N); // гроадиент по оси y.
	my_alloc_universal(gradxyyGpot, M, N);
	my_alloc_universal(gradxxyGpot, M, N);
	my_alloc_universal(gradxyGpot, M, N);
	my_alloc_universal(gradxxGpot, M, N);
	my_alloc_universal(Fpot,M,N);
	my_alloc_universal(gradxFpot,M,N); // градиент по оси х.
	my_alloc_universal(gradyFpot,M,N); 
	my_alloc_universal(Kpot, M, N);
	my_alloc_universal(gradxKpot, M, N); // градиент по оси х.
	//my_alloc_universal(JGF,M,N); // Якобианы.
	//my_alloc_universal(JGT,M,N); 
	// Инициализация:
	if (itask==BLASIUS) {
		// линейное распределение функции тока.
		my_init_linear(stream_function, 'y', 0.0, lengthy, xf, yf, M, N); // линейное распределение температур.
	}
	else {
		my_init_zero(bleft, bright, bbottom, btop, 0.0, stream_function, M, N);
	}
	my_init_zero(bleft, bright, bbottom, btop, 0.0, curl, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, curl_old, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, curl_oldi, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, u, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, v, M, N);
	if (itask==BLASIUS)
	{
		my_init_zero(bleft, bright, bbottom, btop, 0.0, temperature, M, N);
	    my_init_zero(bleft, bright, bbottom, btop, 0.0, temp_old, M, N);
	}
	else
	{
		my_init_linear(temperature, 'x', 400.0, 300.0, xf, yf, M, N); // линейное распределение температур.
	    my_init_linear(temp_old, 'x', 400.0, 300.0, xf, yf, M, N); // линейное распределение температур.
	}
	my_init_zero(bleft, bright, bbottom, btop, 0.0, Gpot, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, gradxGpot, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, gradyGpot, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, Fpot, M, N);
	//my_init_zero(bleft, bright, bbottom, btop, 0.0, JGF, M, N); // Якобианы.
	//my_init_zero(bleft, bright, bbottom, btop, 0.0, JGT, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, gradxxGpot, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, gradxyGpot, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, gradxxyGpot, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, gradxyyGpot, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, Kpot, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, gradxKpot, M, N);
	calc_gradx(Fpot, temperature, xf, yf, M, N);
	for (int i=0; i<M+2; i++) for (int j=0; j<N+2; j++) {
		Fpot[i][j]*=-betaT;
	}
	calc_gradx(gradxFpot , Fpot, xf, yf, M, N);
	calc_grady(gradyFpot , Fpot, xf, yf, M, N);

	/* Алгоритм Зеньковской-Симоненко.
	* 1. Задание постоянных коэффициентов в уравнении.
	* 2. Инициализация рассчитываемых полевых величин Fpot, Gpot , вихря, функции тока и температуры.
	*    А также градиентов этих величин, например полей скоростей.
	* 3. Перейти к следующему шагу по времени. 
	* 4. Вычислить Якобианы и производные от температуры.
	* 5. Решение уравнения для завихрённости : сборка СЛАУ включая граничные условия, сборка правой части и решение СЛАУ.
	*    Достаточно одной итерации метода Писмена Рекфорда.
	* 6. Решение уравнения для функции тока : сборка матрицы, вычисление правой части и решение СЛАУ. Несколько итераций алгоритма Федоренко.
	* 7. На основе новых значений функции тока вычислить компоненты скоростей.
	* 8. Решить уравнение теплопроводности выполнив одну итерацию метода Писмена Рекфорда.
	* 9. Вычислить градиент температуры и величину Fpot. Найти Gpot решив эллиптическое уравнение с SPD матрицей выполнив несколько итераций алгоритма Федоренко.
	* 10. Если конечное время достигнуто то прервать вычисление и конец. Иначе вернуться на шаг 3. и продолжить вычисления начиная с шага 3.
	*/
#if MY_FLOAT
	Real dzeta1=1.0f, dzeta2=1.0f; // (1.0; 0.0 - направленные разности) 1.0; 1.0; - монотонная аппроксимация А.А.Самарского.
#else
	Real dzeta1=1.0, dzeta2=1.0; // (1.0; 0.0 - направленные разности) 1.0; 1.0; - монотонная аппроксимация А.А.Самарского.
#endif
	
	int ialgcurl=STANDART; // STANDART SEIDEL LR SORDIRICHLET ZVER
	int ialgstreamfunc=LR; // STANDART SEIDEL LR SORDIRICHLET ZVER
	int ialgtemp=STANDART; // STANDART SEIDEL LR SORDIRICHLET ZVER
    int ialgGpot=LR; // STANDART SEIDEL LR SORDIRICHLET ZVER
	int iendcurl=1;
	int iendstreamfunc=50;
	int iendtemp=1;
	int iendGpot=50;
	int itimeapprox=IMPLICIT; // IMPLICIT BURAGO EXPLICIT
	switch (itimeapprox) {
	case EXPLICIT : ialgcurl=STANDART; ialgstreamfunc=SEIDEL; ialgtemp=STANDART; ialgGpot=SEIDEL;
			        iendcurl=1; iendstreamfunc=100; iendtemp=1; iendGpot=100;
			        break;
	case IMPLICIT : // полностью неявный.
			        //ialgcurl=SEIDEL; 
			        //iendcurl=8; 
		            ialgcurl = LR;// SEIDEL; // LR
			        iendcurl=1; 
					ialgstreamfunc = LR;// SEIDEL; // LR 
					iendstreamfunc=18; 
					ialgtemp = LR;// SEIDEL; // LR
					iendtemp=10;
					ialgGpot = LR;// SEIDEL; //LR
					iendGpot=18;
			        break;
	}

#if MY_FLOAT
	int ischemeapprox=TOMA; // условия ТОМА для вихря // TOMA WOODS JENSEN
	Real epsilon_bon_curl=1e-4f; // точность опредеделения граничных условий для вихря.
	Real epsilon_temperature=5.0e-4f; // точность определения поля температуры на данной стационарной итерации. Рассогласование в каждой точке не более 5 сотых градуса.
	Real stream_function_drop_tolerance=1e-6f; // точность с которой решается уравнение для функции тока.
	Real Gpot_drop_tolerance=1e-6f; // точность с которой решается уравнение для функции Gpot.
	Real bweshouldbecontinue=true;
	Real vorticity_boundary_conditions; // точность выполнения граничных условий для завихрённости.
	int iconstrA=PATANKAR; // алгоритм сборки матрицы PATANKAR SAMARSKII (монотонная аппроксимация Самарского работает только для равномерной сетки).
	Real alpha=0.2f; // параметр нижней релаксации для вихря.
	bool bweshouldbecontinuetemp=true;
	

	Real time=0.0f;
	Real dtime=tau;
#else
	int ischemeapprox=JENSEN; // условия ТОМА для вихря // TOMA WOODS JENSEN
	Real epsilon_bon_curl=1e-4; // точность опредеделения граничных условий для вихря.
	Real epsilon_temperature=0.0005; // точность определения поля температуры на данной стационарной итерации. Рассогласование в каждой точке не более 5 сотых градуса.
	Real stream_function_drop_tolerance=1e-6; // точность с которой решается уравнение для функции тока.
	Real Gpot_drop_tolerance=1e-6; // точность с которой решается уравнение для функции Gpot.
	Real bweshouldbecontinue=true;
	Real vorticity_boundary_conditions; // точность выполнения граничных условий для завихрённости.
	int iconstrA=PATANKAR; // алгоритм сборки матрицы PATANKAR SAMARSKII (монотонная аппроксимация Самарского работает только для равномерной сетки).
	Real alpha=0.2; // параметр нижней релаксации для вихря.
	bool bweshouldbecontinuetemp=true;
	

	Real time=0.0;
	Real dtime=tau;
#endif

	

	bool btimedepend=false; // false == стационарный солвер.
	int iendtimestep = 1;// 20000; // 200 периодов.
	int ienditer=28000; // количество стационарных итераций.
	if (!btimedepend) {
		iendtimestep=1; // стационарный солвер.
	}
	int ic1=0;

	for (int inumbertimestep=0; inumbertimestep<iendtimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=tau;

		switch (itimeapprox) {
		   case EXPLICIT : tau=minf(time_limiter_all_explicit(rho/mu, u, v, xf, yf, M, N), dtime);  break;
		   case IMPLICIT : // нет никаких ограничений. 
			             break;
		}


		bweshouldbecontinuetemp=true;
		int iter=0;
		while (bweshouldbecontinuetemp&&(iter<ienditer)) {
             // итерации стационарного солвера.
		

		     // 4. Вычисление градиента температуры.
		     calc_gradx(gradxtemperature, temperature, xf, yf, M, N);
			 calc_grady(gradytemperature, temperature, xf, yf, M, N);
			 // и Якобианов.
			 for (int i=0; i<M+2; i++) {
				 for (int j=0; j<N+2; j++) {
					 // Эти слагаемые войдут в источниковый член, т.е. будут учтены явно, поэтому для них достаточно
					 // центрально разностной аппроксимации.
					 //JGF[i][j]=gradyGpot[i][j]*gradxFpot[i][j]-gradxGpot[i][j]*gradyFpot[i][j];
					 //JGT[i][j]=gradyGpot[i][j]*gradxtemperature[i][j]-gradxGpot[i][j]*gradytemperature[i][j];

				 }
			 }


		     // цикл в котором вычисляются текущие граничные условия для вихря.
			 bweshouldbecontinue=true;

		     int iteri=0;

		     while (bweshouldbecontinue) {

		          // 5. Решение уравнения для завихрённости : сборка матрицы, правой части и решение СЛАУ.

				 load_my_bound_curl(my_bound_curl, itask, curl, stream_function, u, v, ischemeapprox, alpha, time, xf, yf, M, N);

			      switch(iconstrA) {
			           case SAMARSKII :   
						   
						             if (idim==DIMENSIONLESS) {
										 // безразмерные
										 constrASamarskii(A, my_bound_curl, u, v, 1.0/Re, dzeta1, dzeta2, xf, yf, M, N); // сборка матрицы.
									 }
									 else if (idim==DIMENSIONAL) {
										 // размерные
						                 constrASamarskii(A, my_bound_curl, u, v, mu/rho, dzeta1, dzeta2, xf, yf, M, N); // сборка матрицы.
									 }
			
		                              for (int i=0; i<M+2; i++) {
		                                   for (int j=0; j<N+2; j++) {
				                               // инициализация рассчитываемых величин.
				                               potent[i][j]=curl[i][j];
				                               potent_old[i][j]=curl[i][j];
		                                   }
	                                  }
							          for (int i=1; i<M+1; i++) {
		                                  for (int j=1; j<N+1; j++) {
				                              // правая часть :
											  if (idim==DIMENSIONLESS) {
										          // безразмерные
												 // rthdsd_internal[i][j]=-(-(Gr/(Re*Re))*gradxtemperature[i][j]);

												  // 08.05.2021
												  rthdsd_internal[i][j] = -(-(Gr / (Re * Re)) * gradxtemperature[i][j] -
													   epsilon_vibr * (-(1.0 + gradyGpot[i][j]) * gradxyyGpot[i][j] +
														  gradxxGpot[i][j] * (gradxyGpot[i][j] + Kpot[i][j]) +
														  gradxGpot[i][j] * (gradxxyGpot[i][j] + gradxKpot[i][j])));

											  }
											  else if (idim==DIMENSIONAL) {
										         // размерные
			                                     //rthdsd_internal[i][j]=-(-rho*gy*betaT*gradxtemperature[i][j]-
													// rho*epsilon_vibr*JGF[i][j]-epsilon_vibr*betaT*JGT[i][j]);
											  
											   // 08.05.2021
												  rthdsd_internal[i][j] = -(-rho * gy * betaT * gradxtemperature[i][j]  -
													  rho * epsilon_vibr * (-(1.0 + gradyGpot[i][j]) * gradxyyGpot[i][j] +
														  gradxxGpot[i][j] * (gradxyGpot[i][j] + Kpot[i][j]) +
														  gradxGpot[i][j] * (gradxxyGpot[i][j] + gradxKpot[i][j])) );
											  }
									      }
								      }
									  if (btimedepend) {
										  // нестационарный солвер.
		                                 for (int i=1; i<M+1; i++) {
		                                     for (int j=1; j<N+1; j++) {
				                                 A[i][j].ap=1.0+tau*A[i][j].ap;
				                                 A[i][j].ae*=tau;
				                                 A[i][j].an*=tau;
				                                 A[i][j].as*=tau;
				                                 A[i][j].aw*=tau;
				                                 rthdsd_internal[i][j]+=curl_old[i][j];
			                                 }
		                                 }
									  }

								      // нижняя релаксация для вихря.
						              for (int i=1; i<M+1; i++) {
		                                  for (int j=1; j<N+1; j++) {
				                              A[i][j].ap/=alpha;				                        
				                              rthdsd_internal[i][j]+=A[i][j].ap*(1.0-alpha)*curl_oldi[i][j];
			                              }
		                              }

								   break;
			           case PATANKAR :	
						   
						            if (idim==DIMENSIONLESS) {
										 // безразмерные
										 constrAPatankar(A, my_bound_curl, u, v, 1.0, 1.0/Re, xf, yf, M, N);
									}
									else if (idim==DIMENSIONAL) {
										 // размерные
						                 constrAPatankar(A, my_bound_curl, u, v, rho, mu, xf, yf, M, N);
									}

				                   for (int i=0; i<M+2; i++) {
		                                for (int j=0; j<N+2; j++) {
				                             // инициализация рассчитываемых величин.
				                             potent[i][j]=curl[i][j];
				                             potent_old[i][j]= curl[i][j];
		                                }
	                                }

						            for (int i=1; i<M+1; i++) {
		                                for (int j=1; j<N+1; j++) {
				                            // правая часть :
											 if (idim==DIMENSIONLESS) {
										         // безразмерные
												 //rthdsd_internal[i][j]=-(-(Gr/(Re*Re))*gradxtemperature[i][j]*h1*h2);

												  // 08.05.2021
												 rthdsd_internal[i][j] = -(-(Gr / (Re * Re)) * gradxtemperature[i][j] * h1 * h2 -
													  epsilon_vibr * (-(1.0 + gradyGpot[i][j]) * gradxyyGpot[i][j] +
														 gradxxGpot[i][j] * (gradxyGpot[i][j] + Kpot[i][j]) +
														 gradxGpot[i][j] * (gradxxyGpot[i][j] + gradxKpot[i][j])) * h1 * h2);
											 }
											 else if (idim==DIMENSIONAL) {
										         // размерные
			                                     //rthdsd_internal[i][j]=-(-rho*gy*betaT*gradxtemperature[i][j]*h1*h2-
													// rho*epsilon_vibr*JGF[i][j]*h1*h2-
													 //rho*epsilon_vibr*betaT*JGT[i][j]*h1*h2);

												 // 08.05.2021
												 rthdsd_internal[i][j] = -(-rho * gy * betaT * gradxtemperature[i][j] * h1 * h2 -
													 rho * epsilon_vibr * (-(1.0+ gradyGpot[i][j])* gradxyyGpot[i][j]+
														 gradxxGpot[i][j]*(gradxyGpot[i][j]+Kpot[i][j])+
														 gradxGpot[i][j]*(gradxxyGpot[i][j]+gradxKpot[i][j])) * h1 * h2);
											 }
									    }
						            }
									if (btimedepend) {
										  // нестационарный солвер.
						  				  for (int i=1; i<M+1; i++) {
		                                      for (int j=1; j<N+1; j++) {
				                                   A[i][j].ap+=rho*h1*h2/tau;				                        
				                                   rthdsd_internal[i][j]+=rho*h1*h2*curl_old[i][j]/tau;
			                                  }
		                                  }
									}

						            // нижняя релаксация для вихря.
						            for (int i=1; i<M+1; i++) {
		                                for (int j=1; j<N+1; j++) {
				                            A[i][j].ap/=alpha;				                        
				                            rthdsd_internal[i][j]+=A[i][j].ap*(1.0-alpha)*curl_oldi[i][j];
			                            }
		                            }
				                   break;
			      }

				  constrrthdsd0(rthdsd, rthdsd_internal, my_bound_curl, xf, yf, M, N); // правая часть.

		          // невязка :
		          residual(r, potent_old, rthdsd,  A, M, N);
				  //printf("%e\n",normar(r, M, N));
				  //getchar();

		          // решение СЛАУ:

		          itsolve_naiv(potent, potent_old, r, rthdsd, M, N, ialgcurl, A, iendcurl); // полностью явная схема при iendcurl==1 и ialgcurl==STANDART.
				  // Явная схема обладает очень жёстким ограничением на шаг по времени. В тоже время одна итерация полинейного метода вполне достаточна для 
				  // сходимости и не имеет ограничений на шаг по времени. Но на самом деле любой segregate имеет ограничение на шаг по времени.
				  // В общем было выяснено что увеличение количества итераций полинейного метода в данном месте не оказывает влияния на скорость выполнения
				  // точного граничного условия для вихря. Т.е. алгоритм Федоренко здесь по видимому не нужен. Многое зависит от возможности расчёта на неравномерной сетке.


		          /*
		          // Для вспомогательной системы имеем однородные граничные условия.
	              my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
	              //constrA0(Al, 1.0, MC, NC); // сборка матрицы.
		          // передача компонент скорости на грубую сетку.
		          my_restriction1(u, ul, M, N);
		          my_restriction1(v, vl, M, N);
		          constrASamarskii(Al, ul, vl, 1.0/Re, dzeta1, dzeta2, MC, NC); // сборка матрицы.
	              for (int i=0; i<MC+2; i++) {
		              for (int j=0; j<NC+2; j++) {
			              r_coarse[i][j]=0.0;
			              rthdsd_c[i][j]=0.0;
		              }
	              }
	              itsolve_Fedor(potent, potent_old, r, rthdsd, M, N, v1, v1_old,  r_coarse, rthdsd_c, MC, NC,ialgstreamfunc, A, Al);
		          //*/

		          // 6. Решение уравнения для функции тока : сборка матрицы, вычисление правой части и решение СЛАУ.

				  // Граничные условия для функции тока.
                  load_my_bound_stream_function(my_bound_psi, itask, time, xf, yf, M , N);

		          constrA0(A, my_bound_psi, 1.0, xf, yf, M, N); // сборка матрицы.
		          for (int i=0; i<M+2; i++) {
		              for (int j=0; j<N+2; j++) {
				          // правая часть :
				          //curl[i][j]=potent[i][j]; // запоминаем рассчитанный вихрь.
						  curl[i][j] = curl_oldi[i][j] + 0.25 * (potent[i][j]- curl_oldi[i][j]);
				          // инициализация рассчитываемых величин.
				          potent[i][j]=stream_function[i][j];
				          potent_old[i][j]=stream_function[i][j];
		              }
	              }
			      for (int i=1; i<M+1; i++) {
		              for (int j=1; j<N+1; j++) {
				          // правая часть :
					      rthdsd_internal[i][j]=-curl[i][j]/**h1*h2*/; // правая часть в уравнении для функции тока.
						  //rthdsd_internal[i][j]=-(curl[i][j]); // для метода конечных разностей.
						  // так как теперь уравнение чистой дифузии собирается по способу контрольного объёма, то правую часть
						  // источниковый член теперь надо умножать на объём контрольного объёма.
						  // на объём контрольного объёма умножать ненужно если сборка осуществляется по способу конечных разностей.
				      }
			      }

				  constrrthdsd0(rthdsd, rthdsd_internal, my_bound_psi, xf, yf, M, N); // правая часть.

		          // невязка :
		          residual(r, potent_old, rthdsd,  A, M, N);
		          

				  

				  // Граничные условия для функции тока
				  // на грубой сетке.
                  load_my_bound_stream_function(my_bound_coarse_psi, itask, time, xc, yc, MC , NC);
				  /*
		          // Для вспомогательной системы имеем однородные граничные условия.
	              my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
				  my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1_old, MC, NC);
	              constrA0(Al, my_bound_coarse_psi, 1.0, xc, yc, MC, NC); // сборка матрицы.
	              for (int i=0; i<MC+2; i++) {
		               for (int j=0; j<NC+2; j++) {
						   // инициализация.
						   // Здесь просто инициализация нулём не надо ничего заполнять 
						   // всё будет заполнено внутри алгоритма Федоренко.
			               r_coarse[i][j]=0.0;
			               rthdsd_c[i][j]=0.0;
		               }
	              }
				  // По видимому эллиптическое уравнение для функции тока требуется решать достаточно точно и здесь необойтись без быстросходящегося алгоритма.
				  int iend=23000;
				  Real *residual_history=new Real[iend+1];
	for (int i=0; i<iend; i++) {
	   residual_history[i]=1.0; // инициализация.
	}
	int iend_it1 = 1;
	iend_it1 = itsolve_Fedor(potent, potent_old, r, rthdsd, M, N, v1, v1_old,  r_coarse, rthdsd_c, MC, NC,ialgstreamfunc, A, Al,stream_function_drop_tolerance,residual_history);
	// нормированная октаэдрическая норма (сумма модулей).
	for (int i=1; i<iend_it1; i++) {
	    residual_history[i]=residual_history[i]/residual_history[0];
	}
	residual_history[0]=1.0;

	for (int i=0; i<iend_it1; i++) {
	    //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	}
	delete[] residual_history;
	              */
		          // решение СЛАУ:
				  // Как альтернатив более медленно сходящийся солвер, он прост в использовании и на нём можно потренироваться.
		         //--> itsolve_naiv(potent, potent_old, r, rthdsd, M, N, ialgstreamfunc, A,iendstreamfunc);

				  //R_Bellmanq(M, N, potent, rthdsd);
                  DFTq(M, N, potent, rthdsd);

		          // 7. Вычисление компонент скорости.

		          for (int i=0; i<M+2; i++) {
		              for (int j=0; j<N+2; j++) {
				          stream_function[i][j]=potent[i][j];
			          }
		          }

				  /*
				  // Данные параметры настроены на задачу Блазиуса.
				  stream_function[0][0]=0.0;
	              stream_function[M+1][0]=amplitude0*(lengthx/9.0)*sin(Omega*time);
	              stream_function[0][N+1]=lengthy; // 1.0 безразмерная область
	              stream_function[M+1][N+1]=lengthy; // 1.0 безразмерная область
				  */

		          // Экономично находит компоненты скорости по рассчитанной функции тока.
                  //calcvelocity1(stream_function, u, v,  M, N);
				  calcvelocity1(stream_function, u, v, xf, yf, M, N);
		          // 8. Рассчитываются новые граничные условия для вихря на твердой стенке по текущим значениям функции тока и вихря.
				  // Здесь введена нижняя релаксация см. Полежаев Пасконов Чудов.
		          //----->//curlbound(curl, stream_function, ischemeapprox, M, N, alpha);
				  // Здесь также нужно сделать обновление всех гидродинамических 
				  // граничных условий для всех величин смотри например задачу Блазиуса. 

			      bweshouldbecontinue=bfinish(curl, curl_oldi, epsilon_bon_curl, vorticity_boundary_conditions, M, N);
			      for (int i=0; i<M+2; i++) {
		              for (int j=0; j<N+2; j++) {
					      curl_oldi[i][j]=curl[i][j];
				      }
		          }

			      if (ic1%10==0) {
				      printf("vorticity_boundary_conditions\n");
			      }
				  
			      printf("%d %1.4e\n",ic1, vorticity_boundary_conditions);

			      iteri++;
				  if (iteri > 100) break;
				  //getchar();
		     } // конец определения граничных условий для вихря.

			 ic1++;
		

		     // 9. Решение уравнения для температуры : сборка матрицы, нулевая правая часть, решение СЛАУ.
			 load_my_bound_temp(my_bound_temp, itask, xf, yf, M,N);

		     switch(iconstrA) {
			      case SAMARSKII : 
					                if (idim==DIMENSIONLESS) {
										 // безразмерные
										 constrASamarskii(A, my_bound_temp, u, v, 1.0/(Re*Pr), dzeta1, dzeta2, xf, yf, M, N);  // сборка матрицы.
									 }
									 else if (idim==DIMENSIONAL) {
										 // размерные
						                 constrASamarskii(A, my_bound_temp, u, v, lambda/(rho*Cp), dzeta1, dzeta2, xf, yf, M, N); // сборка матрицы.
									 }

		                      
		                     for (int i=0; i<M+2; i++) {
		                         for (int j=0; j<N+2; j++) {
				                    // инициализация рассчитываемых величин.
				                    potent[i][j]=temperature[i][j];
				                    potent_old[i][j]=temperature[i][j];
		                         }
	                         }

							 for (int i=1; i<M+1; i++) {
		                         for (int j=1; j<N+1; j++) {
				                    // правая часть :
			                        rthdsd_internal[i][j]=-(0.0);
								 }
							 }

							 if (btimedepend) {
									// нестационарный солвер.
		                            for (int i=1; i<M+1; i++) {
		                                for (int j=1; j<N+1; j++) {
			                    	        A[i][j].ap=1.0+tau*A[i][j].ap;
				                            A[i][j].ae*=tau;
				                            A[i][j].an*=tau;
				                            A[i][j].as*=tau;
				                            A[i][j].aw*=tau;
				                            rthdsd_internal[i][j]+=temp_old[i][j];
			                            }
		                            }
							 }
		                     break;
			      case PATANKAR :	if (idim==DIMENSIONLESS) {
										 // безразмерные
					                     constrAPatankar(A, my_bound_temp, u, v, 1.0, 1.0/(Re*Pr), xf, yf, M, N);
					                 }
									 else if (idim==DIMENSIONAL) {
										 // размерные
					                     constrAPatankar(A, my_bound_temp, u, v, rho*Cp, lambda, xf, yf, M, N);
									 }

				                    for (int i=0; i<M+2; i++) {
		                                 for (int j=0; j<N+2; j++) {
				                             // инициализация рассчитываемых величин.
				                             potent[i][j]=temperature[i][j];
				                             potent_old[i][j]=temperature[i][j];
		                                 }
	                                }

						            for (int i=1; i<M+1; i++) {
		                                 for (int j=1; j<N+1; j++) {
				                             // правая часть :
			                                 rthdsd_internal[i][j]=-(0.0*h1*h2);
									     }
						            }
						  
						            if (btimedepend) {
									    // нестационарный солвер.
						                for (int i=1; i<M+1; i++) {
		                                    for (int j=1; j<N+1; j++) {
				                                A[i][j].ap+=rho*Cp*h1*h2/tau;				                        
				                                rthdsd_internal[i][j]=rho*Cp*h1*h2*temp_old[i][j]/tau;
			                                }
		                                }
									}
								
				             break;
			       }

			       constrrthdsd0(rthdsd, rthdsd_internal, my_bound_temp, xf, yf, M, N); // правая часть.

		           // невязка :
		           residual(r, potent_old, rthdsd,  A, M, N);
				   //exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, temp_old, gradxtemperature, xf, yf, M, N);
				   //printf("%e %e %e %e %e\n",A[5][5].ae,A[5][5].an,A[5][5].as,A[5][5].aw,A[5][5].ap);
				   //printf("start");
				   //getchar();

				   //bflag=true;
		           // решение СЛАУ:
		           //---->itsolve_naiv(potent, potent_old, r, rthdsd, M, N, ialgtemp, A, iendtemp); // полностью явная схема при iendtemp==1 && ialgtemp==STANDART
				   
				   if (1) {
					   // для алгебраического многосеточного метода amg1r5:
					   Real* dX0 = new Real[(M + 2) * (N + 2)];
					   //amg_loc_memory(potent, rthdsd, A, M, N, 0, dX0);
					   amg_global_memory(potent, rthdsd, A, M, N, 0, dX0);
					   delete[] dX0;
				   }
				   // Дело в том что явная схема очень ограничительна в плане шага по времени поэтому здесь нужно использовать неявную схему которая не имеет ограничения
				   // на шаг по времени. Для этих целей вполне достаточно одной итерации полинейного метода.
				   // Вычисление на данном итерационном цикле нужно продолжать до тех пор пока поле температур не перестанет изменяться от итерации к итерации.
		
				   /*
		           // Для вспомогательной системы имеем однородные граничные условия.
	               my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
		           // передача компонент скорости на грубую сетку.
		           my_restriction1(u, ul, M, N);
		           my_restriction1(v, vl, M, N);
		           constrASamarskii(Al, ul, vl, 1.0/Pr, dzeta1, dzeta2, MC, NC); // сборка матрицы.
	               for (int i=0; i<MC+2; i++) {
		               for (int j=0; j<NC+2; j++) {
			               r_coarse[i][j]=0.0;
			               rthdsd_c[i][j]=0.0;
		               }
	               }
	               itsolve_Fedor(potent, potent_old, r, rthdsd, M, N, v1, v1_old,  r_coarse, rthdsd_c, MC, NC,ialgstreamfunc, A, Al);
		           */
				   Real temperature_mismatch;
				   /*bweshouldbecontinuetemp=*/bfinish_temp(potent, temperature, epsilon_temperature, temperature_mismatch, M, N);
				   printf("temperature mismatch is equal=%1.4e\n",temperature_mismatch);
				   //getchar();

		           for (int i=0; i<M+2; i++) {
		               for (int j=0; j<N+2; j++) {
				           temperature[i][j]=potent[i][j];
			           }
		           }

				   // 10. Составление и решение уравнения для Gpot.
				   calc_gradx(Fpot, temperature, xf, yf, M, N);
				   calc_grady(Kpot, temperature, xf, yf, M, N);
	               for (int i=0; i<M+2; i++) for (int j=0; j<N+2; j++) {
		               Fpot[i][j]*=-betaT;
					   Kpot[i][j] *= -betaT;
	               }

				   // Граничные условия для функции тока.
                  load_my_bound_Gpot(my_bound_Gpot, itask, time, xf, yf, M , N);

		          constrA0(A, my_bound_Gpot, 1.0, xf, yf, M, N); // сборка матрицы.
		          for (int i=0; i<M+2; i++) {
		              for (int j=0; j<N+2; j++) {
				          // инициализация рассчитываемых величин.
				          potent[i][j]=Gpot[i][j];
				          potent_old[i][j]=Gpot[i][j];
		              }
	              }
			      for (int i=1; i<M+1; i++) {
		              for (int j=1; j<N+1; j++) {
				          // правая часть :
					      rthdsd_internal[i][j]=-Fpot[i][j]/*h1*h2*/; // правая часть в уравнении для функции тока.
						  //rthdsd_internal[i][j]=-(Fpot[i][j]); // для метода конечных разностей.
						  // так как теперь уравнение чистой дифузии собирается по способу контрольного объёма, то правую часть
						  // источниковый член теперь надо умножать на объём контрольного объёма.
						  // на объём контрольного объёма умножать ненужно если сборка осуществляется по способу конечных разностей.
				      }
			      }

				  constrrthdsd0(rthdsd, rthdsd_internal, my_bound_Gpot, xf, yf, M, N); // правая часть.

		          // невязка :
		          residual(r, potent_old, rthdsd,  A, M, N);
		          
				  // Граничные условия для функции тока
				  // на грубой сетке.
                  load_my_bound_Gpot(my_bound_coarse_Gpot, itask, time, xc, yc, MC, NC);
				  /*
		          // Для вспомогательной системы имеем однородные граничные условия.
	              my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
				  my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1_old, MC, NC);
	              constrA0(Al, my_bound_coarse_Gpot, 1.0, xc, yc, MC, NC); // сборка матрицы.
	              for (int i=0; i<MC+2; i++) {
		               for (int j=0; j<NC+2; j++) {
						   // инициализация.
						   // Здесь просто инициализация нулём не надо ничего заполнять 
						   // всё будет заполнено внутри алгоритма Федоренко.
			               r_coarse[i][j]=0.0;
			               rthdsd_c[i][j]=0.0;
		               }
	              }
				  // По видимому эллиптическое уравнение для функции тока требуется решать достаточно точно и здесь необойтись без быстросходящегося алгоритма.
				  int iend=23000;
				  Real *residual_history=new Real[iend+1];
	for (int i=0; i<iend; i++) {
	   residual_history[i]=1.0; // инициализация.
	}
	int iend_it = 1;
	iend_it = itsolve_Fedor(potent, potent_old, r, rthdsd, M, N, v1, v1_old,  r_coarse, rthdsd_c, MC, NC,ialgGpot, A, Al, Gpot_drop_tolerance,residual_history);
	// нормированная октаэдрическая норма (сумма модулей).
	for (int i=1; i<iend_it; i++) {
	    residual_history[i]=residual_history[i]/residual_history[0];
	}
	residual_history[0]=1.0;

	for (int i=0; i<iend_it; i++) {
	    //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	}
	delete residual_history;
	       */       
		          // решение СЛАУ:
				  // Как альтернатив более медленно сходящийся солвер, он прост в использовании и на нём можно потренироваться.
		          //-->itsolve_naiv(potent, potent_old, r, rthdsd, M, N, ialgGpot, A,iendGpot);
		          
				  //R_Bellmanq(M, N, potent, rthdsd);
				  DFTq(M, N, potent, rthdsd);
				  
				  // 11. Вычисление градиентов величин.

		          for (int i=0; i<M+2; i++) {
		              for (int j=0; j<N+2; j++) {
				          //Gpot[i][j]=potent[i][j];
						  Gpot[i][j] += 0.25*(potent[i][j]-Gpot[i][j]);
			          }
		          }

				  calc_gradx(gradxFpot, Fpot, xf, yf, M, N);
				  calc_grady(gradyFpot, Fpot, xf, yf, M, N);

				  calc_gradx(gradxKpot, Kpot, xf, yf, M, N);

				  calc_gradx(gradxGpot, Gpot, xf, yf, M, N);
				  calc_grady(gradyGpot, Gpot, xf, yf, M, N);

				  calc_gradx(gradxxGpot, gradxGpot, xf, yf, M, N);
				  calc_grady(gradxyGpot, gradxGpot, xf, yf, M, N);

				  calc_grady(gradxyyGpot, gradxyGpot, xf, yf, M, N);
				  calc_gradx(gradxxyGpot, gradxyGpot, xf, yf, M, N);

		           // 12. Если сходимость недостигнута то возвращение к пункту 4.
		           //getchar();

				   //exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, u, v, xf, yf, M, N);
				   //getchar();
		
				   iter++;
	    } // стационарные итерации алгоритма.

		// Запоминаем вихрь с текущего временного слоя.
		for (int i=0; i<M+2; i++) {
		    for (int j=0; j<N+2; j++) {
				curl_old[i][j]=curl[i][j];
			}
		}

		// запоминаем температуру с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		    for (int j=0; j<N+2; j++) {
				temp_old[i][j]=temperature[i][j];
			}
		}
		

		// Контроль сходимости.

		pointxvel=u[ixpoint][iypoint];
	    pointyvel=v[ixpoint][iypoint];
	    pointcurl=curl[ixpoint][iypoint];
	    pointstreamfunc=stream_function[ixpoint][iypoint];
	    pointtemperature=temperature[ixpoint][iypoint];
		// печать осреднённых за период значений в контрольной точке.
		exportmonitorpointSZ(pointxvel, pointyvel, pointcurl, pointstreamfunc, pointtemperature, xpoint , ypoint, false);

	    exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, u, v, xf, yf, M, N);
		//exporttecplotNSRoacheFedushkinanimate(curl, stream_function, temperature, u, v, xf, yf, icadr++, M, N);
		if (btimedepend)  {
			printf("time\n");
		    printf("%e\n",time);
		}

		

	} // шаги по времени.

	if (btimedepend)  {
	    printf("time=%e\n",time);
	}


	calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");

	// экспорт в tecplot.
    
	getchar();

} // Simonenko_Zinkovskaya

// нормирует значения каждого графика от нуля до единицы.
/*
 * n1 - количество функций в групе.
 * n2 - число групп.
 * n3 - количество точек на графике M+2
 */
void renormreport(Real*** &report, int n1, int n2, int n3) {

 
	/*
	// исходный вариант.
	// инициализация repor`та:
	for (int i1=0; i1<M+2; i1++) {
		for (int i2=0; i2<5; i2++) {
			for (int i3=0; i3<iPr*iSc*iGr; i3++) {
				report[i1][i2][i3]=0.0; // инициализация нулём.
			}
		}
	}
	*/
	Real max, min; // минимальное и максимальное значения функии.

	for (int i1=0; i1<n1; i1++) {
		for (int i2=0; i2<n2; i2++) {
			max=FLT_MIN;
			min=FLT_MAX;
			for (int i3=0; i3<n3; i3++) {
				if (report[i3][i1][i2]>max) {
					max=report[i3][i1][i2];
				}
				if (report[i3][i1][i2]<min) {
					min=report[i3][i1][i2];
				}
			}
			for (int i3=0; i3<n3; i3++) {
				// теперь все функции изменяются от нуля до единицы.
				report[i3][i1][i2]=(report[i3][i1][i2]-min)/(max-min);
			}
		}
	}
} // renorm report.

// Нормирует значения Числа Нуссельта.
void renormNusseltreport(Real** &reportNusselt, int ny, int ngroup) {
	Real max, min; // минимальное и максимальное значения функии.

	for (int i1=0; i1<ngroup; i1++) {
			max=FLT_MIN;
			min=FLT_MAX;
			for (int i2=0; i2<ny; i2++) {
				if (reportNusselt[i2][i1]>max) {
					max=reportNusselt[i2][i1];
				}
				if (reportNusselt[i2][i1]<min) {
					min=reportNusselt[i2][i1];
				}
			}
			for (int i2=0; i2<ny; i2++) {
				// теперь все функции изменяются от нуля до единицы.
				reportNusselt[i2][i1]=(reportNusselt[i2][i1]-min)/(max-min);
			}
		
	}
}

// печать отчёта о вычислении в текстовый файл.
void printreport(Real* &x, Real*** &report, int nx, int ngraph, int ngroup) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "report_calc.txt", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		fprintf(fp,"x ");
		for (int i2=0; i2<ngroup; i2++) {
			fprintf(fp,"u v streamfunc dCdy dTdy dCdx dTdx");
		}
        fprintf(fp,"\n");

		for (int i3=0; i3<nx; i3++) {
			fprintf(fp,"%1.4e ",x[i3]);
		        for (int i2=0; i2<ngroup; i2++) {
					for (int i1=0; i1<ngraph; i1++) {
			
		                  fprintf(fp,"%1.4e ",report[i3][i1][i2]);
		            }
		        }
				fprintf(fp,"\n");
			}
		fclose(fp);
	}
} // printreport

// печать чисел Нуссельта в текстовый файл.
void printNusseltreport(Real* &y, Real** &reportNusselt, int ny, int ngroup) {
	FILE *fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s( &fp, "report_Nusselt_calc.txt", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		fprintf(fp,"y ");
		for (int i2=0; i2<ngroup; i2++) {
			fprintf(fp,"Nusselt ");
		}
        fprintf(fp,"\n");

		for (int i3=0; i3<ny; i3++) {
			fprintf(fp,"%1.4e ",y[i3]);
		        for (int i2=0; i2<ngroup; i2++) {
			
		                  fprintf(fp,"%1.4e ",reportNusselt[i3][i2]);
		        }
				fprintf(fp,"\n");
			}
		fclose(fp);
	}
} // printNusseltreport


// Алгоритм решения уравнений Навье-Стокса в приближении Обербека-Буссинеска 
// в прямоугольнике в переменных вихрь-функция тока.
// Для случая термоконцентрационной конвекции.
void Jul() {
	// Замер времени.
	unsigned int calculation_start_time; // начало счёта мс.
	unsigned int calculation_end_time; // окончание счёта мс.
	unsigned int calculation_seach_time; // время выполнения участка кода в мс.



	// Всюду нулевые граничные условия.
	Real bleft=0.0;
	Real bright=0.0;
	Real btop=0.0;
	Real bbottom=0.0;

	int icadr=0; // номер анимационного кадра.
	// Будем наблюдать в контрольной точке за поведением средних величин.
	// Контрольная точка (xpoint, ypoint);
	Real xpoint=0.5;
	Real ypoint=0.5;
	int ixpoint=0;
	int iypoint=0;
	Real avgpointmag=0.0;
	Real avgpointxvel=0.0;
	Real avgpointyvel=0.0;
	Real avgpointcurl=0.0;
	Real avgpointstreamfunc=0.0;
	Real avgpointtemperature=0.0;
	Real avgpointconc=0.0;
	// Осреднённые по последнему периоду полевые величины.
	Real** avgmag;
	Real** avgxvel;
	Real** avgyvel;
	Real** avgcurl;
	Real** avgsf;
	Real** avgtemp;
	Real** avgconc;
	// выделение памяти.
	my_alloc_universal(avgmag, M,N);
	my_alloc_universal(avgxvel, M,N);
	my_alloc_universal(avgyvel, M,N);
	my_alloc_universal(avgcurl, M,N);
	my_alloc_universal(avgsf, M,N);
	my_alloc_universal(avgtemp, M,N);
	my_alloc_universal(avgconc, M,N);
	// инициализация нулём.
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgmag, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgxvel, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgyvel, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgcurl, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgsf, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgtemp, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, avgconc, M, N);

    calculation_start_time=clock(); // момент начала счёта.

	

	// функции для решения Навье-Стокса.
	Real** curl; // вихрь;
	Real** curl_oldi; // вихрь с предыдущей внутренней итерации.
	Real** curl_old; // вихрь с предыдущего временного слоя.
	Real** temp_old; // температура с предыдущего временного слоя.
	Real** stream_function; // функция тока;
	Real** temperature; // температура;
	Real** u; // горизонтальная скорость;
	Real** v; // вертикальная скорость;
	Real** gradxtemperature; // градиент температуры по оси х.
	Real** conc_old; // концентрация с предыдущего временног слоя
	Real** concentration;  // концентрация
	Real** gradxconcentration; // градиент концентрации по оси х.
	Real** fbuf1; // вспомогательная функция номер 1.


	// функции для решения СЛАУ.
	Real** potent; // рассчитываемый потенциал.
    Real** potent_old; // потенциал с предыдущей итерации.
    Real** r; // невязка
	Real** rthdsd; // правая часть
	Real** rthdsd_internal; // внутренность : правая часть
	MATRNODE** A; // матрица СЛАУ

	// Данные связанные непосредственно с алгоритмом Федоренко.
    Real** v1;
    Real** v1_old;
    Real** r_coarse;
	Real** rthdsd_c; // на вспомогательной сетке правая часть обязательно присутствует.
	Real** ul;
	Real** vl;
	MATRNODE** Al; // матрица СЛАУ

	// Шаблоны для граничных условий.
	int itask=STUDENTA; // STUDENT DAVIS CHOHRAVLSKY BLASIUS RALEYBENAR STUDENTA

	// Граничные условия
	TBONCONDOMAIN my_bound_temp; 
	TBONCONDOMAIN my_bound_conc; 
	TBONCONDOMAIN my_bound_curl;
	TBONCONDOMAIN my_bound_psi;
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_temp, M,N);
	my_alloc_bound(my_bound_conc, M,N);
	my_alloc_bound(my_bound_curl, M,N);
	my_alloc_bound(my_bound_psi, M,N);
	my_alloc_universal(rthdsd_internal, M, N);

    // постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1=(Real)(lengthx/(M+1));
	Real h2=(Real)(lengthy/(N+1));

	int MC, NC; // C - coarse
	MC=(int)((M+1)/q)-1;
	NC=(int)((N+1)/q)-1;
	my_alloc(v1, v1_old, r_coarse, rthdsd_c, Al, MC, NC);
	// Выделение памяти под компоненты скорости на грубой сетке.
    my_alloc_vel_loc(ul, vl, MC, NC);

	// Граничные условия на грубой сетке.
	TBONCONDOMAIN my_bound_coarse_temp;
	TBONCONDOMAIN my_bound_coarse_conc;
	TBONCONDOMAIN my_bound_coarse_curl; 
	TBONCONDOMAIN my_bound_coarse_psi; 
	// Выделение памяти под граничные условия.
    my_alloc_bound(my_bound_coarse_temp, MC,NC);
	my_alloc_bound(my_bound_coarse_conc, MC,NC);
	my_alloc_bound(my_bound_coarse_curl, MC,NC);
	my_alloc_bound(my_bound_coarse_psi, MC,NC);


	Real* xf=new Real[M+2];
	for (int i=0; i<M+2; i++) {
		xf[i]=(Real)(i*h1);
	}
	Real* yf=new Real[N+2];
	for (int i=0; i<N+2; i++) {
		yf[i]=(Real)(i*h2);
	}

	// Определение контрольной точки.
	Real dist=FLT_MAX;
	for (int i=0; i<M+2; i++) {
		if (fabs(xf[i]-xpoint)<dist) {
			dist=fabs(xf[i]-xpoint);
			ixpoint=i;
		}
	}
	dist=FLT_MAX;
	for (int j=0; j<N+2; j++) {
		if (fabs(yf[j]-ypoint)<dist) {
			dist=fabs(yf[j]-ypoint);
			iypoint=j;
		}
	}
	// печать заголовка.
	exportmonitorpoint(0.0, 0.0, 0.0, 0.0, 0.0, xpoint , ypoint, true);

	// координаты на грубой сетке.
	Real* xc=new Real[MC+2];
	int ic=0;
	for (int i=0; i<M+2; i++) {
		if (i%q==0) {
		   xc[ic++]=xf[i];
		}
	}
	Real* yc=new Real[NC+2];
	ic=0;
	for (int i=0; i<N+2; i++) {
		if (i%q==0) {
			yc[ic++]=yf[i];
		}
	}

	int idim=DIMENSIONLESS; // безразмерные DIMENSIONLESS или размерные DIMENSIONAL
#if MY_FLOAT
	// Коэффициенты для воздуха.
	Real Cp=1006.0f;
	Real mu=17.2e-6f;
	Real rho=1.2041f;
	Real lambda=0.026f;
	Real betaT=3.665e-3f;
	Real betaC=0.02f;
	Real D=0.01f; // коэффициент диффузии.
	Real gy=0.0f; // 0.000556746; <-> 10^4
	// безразмерные числа подобия.
	Real Re=1.0f; // Ренольдс
	Real Sh=1.0f; // Число Струхаля.
	Real Pr=100.0f; // Прандтль
	Real Sc=1.0f;// Шмидт
    Real Gr=0.0f; // Грасгоф
	Real tau=0.01f; // шаг по времени.
#else
	// Коэффициенты для воздуха.
	Real Cp=1006.0;
	Real mu=17.2e-6;
	Real rho=1.2041;
	Real lambda=0.026;
	Real betaT=3.665e-3;
	Real betaC=0.02;
	Real D=0.01; // коэффициент диффузии.
	Real gy=0.0; // 0.000556746; <-> 10^4
	// безразмерные числа подобия.
	Real Re=1.0; // Ренольдс
	Real Sh=1.0; // Число Струхаля.
	Real Pr=100; // Прандтль
	Real Sc=1.0;// Шмидт
    Real Gr=0.0; // Грасгоф
	Real tau=0.01; // шаг по времени.
#endif
	
    printf(" Jul algorithm \n");

	// образец.
	/*
	Real* Prvar=new Real[5];
	Prvar[0]=0.01; Prvar[1]=0.1; Prvar[2]=1.0; Prvar[3]=10.0; Prvar[4]=100.0;
	int iPr=5;
	Real* Scvar=new Real[4];
	Scvar[0]=1; Scvar[1]=10.0; Scvar[2]=100.0; Scvar[3]=1000.0;
	int iSc=4;
	Real* Grvar_t=new Real[5];
	Grvar_t[0]=0.1; Grvar_t[1]=1.0; Grvar_t[2]=10.0; Grvar_t[3]=100.0; Grvar_t[4]=1000.0; 
	int iGr_t=5;
	Real* Grvar_c=new Real[5];
	Grvar_c[0]=0.1; Grvar_c[1]=1.0; Grvar_c[2]=10.0; Grvar_c[3]=100.0; Grvar_c[4]=1000.0; 
	int iGr_c=5;*/
	Real* Prvar=new Real[2];
	Prvar[0]=0.1; Prvar[1]=100;// Prvar[2]=1.0; Prvar[3]=10.0; Prvar[4]=100.0;
	int iPr=2;
	Real* Scvar=new Real[2];
	Scvar[0]=1; Scvar[1]=100.0; //Scvar[2]=100.0; Scvar[3]=1000.0;
	int iSc=2;
	Real* Grvar_t=new Real[4];
	Grvar_t[0]=1.0; Grvar_t[1]=10.0; Grvar_t[2]=100.0; Grvar_t[3]=1000.0; //Grvar_t[4]=1000.0; 
	int iGr_t=4;
	Real* Grvar_c=new Real[4];
	Grvar_c[0]=1; Grvar_c[1]=10.0; Grvar_c[2]=100.0; Grvar_c[3]=1000.0;// Grvar_c[4]=1000.0; 
	int iGr_c=4;
	
    /*
	Real* Prvar=new Real[1];
	Prvar[0]=1.0;
	int iPr=1;*//*
	Real* Scvar=new Real[1];
	Scvar[0]=1.0; 
	int iSc=1;*/
	//Real* Grvar=new Real[6];
	//Grvar[0]=0.1; Grvar[1]=1.0; Grvar[2]=10.0; Grvar[3]=100.0; Grvar[4]=1000.0; Grvar[5]=10000.0;
	//int iGr=6;
	/*
	Real* Grvar=new Real[10];
	Grvar[0]=0.1; Grvar[1]=1.0; Grvar[2]=10.0; Grvar[3]=100.0; Grvar[4]=1000.0; 
	Grvar[5]=2000.0; Grvar[6]=3000.0; Grvar[7]=5000.0; Grvar[8]=7000.0;
	Grvar[9]=10000.0;
	int iGr=10;
	*//*
	Real* Grvar=new Real[1];
	Grvar[0]=100.0;
	int iGr=1;
	*/

	// формирование отчёта результатов вычислений.
	// Мы построим в среднем горизонтальном сечении iypoint
	// следующие величины: компоненты скорости, функция тока, 
	// нормальные градиенты температуры и концентрации к центральной линии.
	Real ***report=new Real**[M+2];
	for (int i1=0; i1<M+2; i1++) {
		report[i1]=new Real*[7];
		for (int i2=0; i2<7; i2++) {
			report[i1][i2]=new Real[iPr*iSc*iGr_c*iGr_t];
		}
	}
	// инициализация repor`та:
	for (int i1=0; i1<M+2; i1++) {
		for (int i2=0; i2<7; i2++) {
			for (int i3=0; i3<iPr*iSc*iGr_c*iGr_t; i3++) {
				report[i1][i2][i3]=0.0; // инициализация нулём.
			}
		}
	}
	// Число Нуссельта на левой стенке.
	Real** reportNusselt=new Real*[N+2];
	for (int i1=0; i1<N+2; i1++) {
		reportNusselt[i1]=new Real[iPr*iSc*iGr_c*iGr_t];
	}
	// инициализация report`a
	for (int i1=0; i1<N+2; i1++) {
		for (int i2=0; i2<iPr*iSc*iGr_c*iGr_t; i2++) {
			reportNusselt[i1][i2]=0.0; // инициализация нулём.
		}
	}


	// Выделение памяти.
	my_alloc_Roach_Fedushkin(curl, stream_function, temperature, u, v, gradxtemperature, M, N);
	my_alloc(potent, potent_old, r, rthdsd, A, M, N);
	my_alloc_curl_old(curl_old, curl_oldi, M, N);
	my_alloc_temp_old(temp_old, M, N);
	my_alloc_temp_old(conc_old, M, N);
	my_alloc_temp_old( concentration, M, N);
	my_alloc_temp_old(gradxconcentration, M, N);
	my_alloc_temp_old(fbuf1, M, N); // выделение памяти под вспомогательную функцию.

	int ivariantcount=0;
	for (int i1=0; i1<iGr_t; i1++) for (int i2=0; i2<iSc; i2++) for (int i3=0; i3<iPr; i3++) for (int i4=0; i4<iGr_c; i4++){




	// Инициализация:
	if (itask==BLASIUS) {
		// линейное распределение функции тока.
		my_init_linear(stream_function, 'y', 0.0, lengthy, xf, yf, M, N); // линейное распределение температур.
	}
	else {
		my_init_zero(bleft, bright, bbottom, btop, 0.0, stream_function, M, N);
	}
	my_init_zero(bleft, bright, bbottom, btop, 0.0, curl, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, curl_old, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, curl_oldi, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, u, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, v, M, N);
	//my_init_zero(bleft, bright, bbottom, btop, 0.0, concentration, M, N);
	//my_init_zero(bleft, bright, bbottom, btop, 0.0, conc_old, M, N);
	my_init_zero(bleft, bright, bbottom, btop, 0.0, fbuf1, M, N);
	if (itask==BLASIUS)
	{
		my_init_zero(bleft, bright, bbottom, btop, 0.0, temperature, M, N);
	    my_init_zero(bleft, bright, bbottom, btop, 0.0, temp_old, M, N);
		my_init_zero(bleft, bright, bbottom, btop, 0.0, concentration, M, N);
	    my_init_zero(bleft, bright, bbottom, btop, 0.0, conc_old, M, N);
	}
	else
	{
		my_init_linear(temperature, 'x', 1.0, 0.0, xf, yf, M, N); // линейное распределение температур.
	    my_init_linear(temp_old, 'x', 1.0, 0.0, xf, yf, M, N); // линейное распределение температур.
		my_init_linear(concentration, 'x', 1.0, 0.0, xf, yf, M, N); // линейное распределение температур.
	    my_init_linear(conc_old, 'x', 1.0, 0.0, xf, yf, M, N); // линейное распределение температур.
	}


	exporttecplotJul(curl, stream_function, temperature, concentration, u, v, xf, yf, M, N);

	/* Алгоритм Роуча.
	* 1. Задание безразмерных критериев подобия.
	* 2. Инициализация : функции тока, вихря, граничных условий для вихря, компонент скорости.
	* 3. Инициализация температуры и концентрации.
	* 4. Вычисление градиента температуры и концентрации.
	* 5. Решение уравнения для завихрённости : сборка матрицы, правой части и решение СЛАУ.
	* 6. Решение уравнения для функции тока : сборка матрицы, вычисление правой части и решение СЛАУ.
	* 7. Вычисление компонент скорости.
	* 8. Рассчитываются новые граничные условия для вихря на твердой стенке по текущим значениям функции тока и вихря.
	* 9. Решение уравнения для температуры : сборка матрицы, нулевая правая часть, решение СЛАУ.
	* 10. Решение уравнения для концентрации : сборка матрицы, нулевая правая часть, решение СЛАУ.
	* 11. Если сходимость недостигнута то возвращение к пункту 4.
	*/

	/* Экспериментальным путём выяснено, что при полностью неявной схеме дискретизации на сетке 50x50
	* в процессе установления граничного условия для вихря полностью достаточно одной итерации алгоритма В.Г. Зверева,
	* А Зейделя достаточно не менее 7 итераций, это приводит на 3% большему количеству итераций в цикле установления граничных условий для вихря. 
	* При этом для функции тока использовался алгоритм Федоренко на базе LR делая 18 проходов в каждом проходе 4 сглаживающие итерации LR.
	* Замечание. наверно для задачи конвекции - диффузии лучше использовать LR так как у LR более сильное диагональное преобладание.
	*/
	/* Для температуры при Gr=10^5 сходится только LR и то если сделать одну итерацию. ZVER расходится и возможно это связано с тем что у него ослаблено
	* диагональное преобладание. У LR более сильное диагональное преобладание и поэтому он работает.
	*/


	Real dzeta1=1.0, dzeta2=1.0; // (1.0; 0.0 - направленные разности) 1.0; 1.0; - монотонная аппроксимация А.А.Самарского.
	int ialgcurl=STANDART; // STANDART SEIDEL LR SORDIRICHLET ZVER
	int ialgstreamfunc=LR; // STANDART SEIDEL LR SORDIRICHLET ZVER
	int ialgtemp=STANDART; // STANDART SEIDEL LR SORDIRICHLET ZVER
	int iendcurl=1;
	int iendstreamfunc=50;
	int iendtemp=1;
	int itimeapprox=BURAGO; // BURAGO EXPLICIT
	int ialgconc=LR;
	int iendconc=1;
	switch (itimeapprox) {
		   case EXPLICIT : ialgcurl=STANDART; ialgstreamfunc=SEIDEL; ialgtemp=STANDART; ialgconc=STANDART;
			               iendcurl=1; iendstreamfunc=100; iendtemp=1; iendconc=1;
			             break;
		   case BURAGO : //ialgcurl=SEIDEL; 
			             //iendcurl=8; 
						 ialgcurl=LR; 
			             iendcurl=1; 
						 ialgstreamfunc=LR; // LR 
						 iendstreamfunc=18; 
						 ialgtemp=LR;
						 iendtemp=1;
						 ialgconc=LR;
						 iendconc=1;
			             break;
	}
	int ischemeapprox=JENSEN; // условия ТОМА для вихря // TOMA WOODS JENSEN
#if MY_FLOAT
	Real epsilon_bon_curl=1.0e-4f; // точность опредеделения граничных условий для вихря.
	Real epsilon_temperature=5.0e-4f; // точность определения поля температуры на данной стационарной итерации. Рассогласование в каждой точке не более 5 сотых градуса.
	Real epsilon_conc=5.0e-4f; 
	Real stream_function_drop_tolerance=1.0e-6f; // точность с которой решается уравнение для функции тока.
	Real bweshouldbecontinue=true;
	Real vorticity_boundary_conditions; // точность выполнения граничных условий для завихрённости.
	int iconstrA=PATANKAR; // алгоритм сборки матрицы PATANKAR SAMARSKII (монотонная аппроксимация Самарского работает только для равномерной сетки).
	Real alpha=0.7f; // параметр нижней релаксации для вихря.
	bool bweshouldbecontinuetemp=true;
	

	Real time=0.0f;
	Real dtime=tau;
#else
	Real epsilon_bon_curl=1e-4; // точность опредеделения граничных условий для вихря.
	Real epsilon_temperature=0.0005; // точность определения поля температуры на данной стационарной итерации. Рассогласование в каждой точке не более 5 сотых градуса.
	Real epsilon_conc=0.0005; 
	Real stream_function_drop_tolerance=1e-6; // точность с которой решается уравнение для функции тока.
	Real bweshouldbecontinue=true;
	Real vorticity_boundary_conditions; // точность выполнения граничных условий для завихрённости.
	int iconstrA=PATANKAR; // алгоритм сборки матрицы PATANKAR SAMARSKII (монотонная аппроксимация Самарского работает только для равномерной сетки).
	Real alpha=0.7; // параметр нижней релаксации для вихря.
	bool bweshouldbecontinuetemp=true;
	

	Real time=0.0;
	Real dtime=tau;
#endif
	

	bool btimedepend=true; // false == стационарный солвер.
	int iendtimestep=20000; // 200 периодов.
	int ienditer=100; // количество стационарных итераций.
	if (!btimedepend) {
		iendtimestep=1; // стационарный солвер.
	}
	int ic1=0;

	for (int inumbertimestep=0; inumbertimestep<iendtimestep; inumbertimestep++) {
		// самый внешний цикл шаги по времени.

		time+=tau;

		switch (itimeapprox) {
		   case EXPLICIT : tau=minf(time_limiter_all_explicit(rho/mu, u, v, xf, yf, M, N), dtime);  break;
		   case BURAGO : //tau=minf(time_limiter_Burago(rho/mu, u, v, M, N), dtime); 
			             break;
		}


		bweshouldbecontinuetemp=true;
		int iter=0;
		while (bweshouldbecontinuetemp&&(iter<ienditer)) {
             // итерации стационарного солвера.
		

		     // 4.1 Вычисление градиента температуры.
		     calc_gradx(gradxtemperature, temperature, xf, yf, M, N);
			 // 4.2 Вычисление градиента концентрации.
		     calc_gradx(gradxconcentration, concentration, xf, yf, M, N);

		     // цикл в котором вычисляются текущие граничные условия для вихря.
			 bweshouldbecontinue=true;

		     int iteri=0;

		     while (bweshouldbecontinue) {

		          // 5. Решение уравнения для завихрённости : сборка матрицы, правой части и решение СЛАУ.

				 load_my_bound_curl(my_bound_curl, itask, curl, stream_function, u, v, ischemeapprox, alpha, time, xf, yf, M, N);

			      switch(iconstrA) {
			           case SAMARSKII :   
						   
						             if (idim==DIMENSIONLESS) {
										 // безразмерные
										 constrASamarskii(A, my_bound_curl, u, v, 1.0/Re, dzeta1, dzeta2, xf, yf, M, N); // сборка матрицы.
									 }
									 else if (idim==DIMENSIONAL) {
										 // размерные
						                 constrASamarskii(A, my_bound_curl, u, v, mu/rho, dzeta1, dzeta2, xf, yf, M, N); // сборка матрицы.
									 }
			
		                              for (int i=0; i<M+2; i++) {
		                                   for (int j=0; j<N+2; j++) {
				                               // инициализация рассчитываемых величин.
				                               potent[i][j]=curl[i][j];
				                               potent_old[i][j]=curl[i][j];
		                                   }
	                                  }
							          for (int i=1; i<M+1; i++) {
		                                  for (int j=1; j<N+1; j++) {
				                              // правая часть :
											  if (idim==DIMENSIONLESS) {
										          // безразмерные
												  rthdsd_internal[i][j]=(1.0/(Re*Re))*(Grvar_t[i1]*gradxtemperature[i][j]+Grvar_c[i4]*gradxconcentration[i][j]);
											  }
											  else if (idim==DIMENSIONAL) {
										         // размерные
			                                     rthdsd_internal[i][j]=gy*(betaT*gradxtemperature[i][j]+betaC*gradxconcentration[i][j]);
											  }
									      }
								      }
									  if (btimedepend) {
										  // нестационарный солвер.
		                                 for (int i=1; i<M+1; i++) {
		                                     for (int j=1; j<N+1; j++) {
				                                 A[i][j].ap=1.0+tau*A[i][j].ap;
				                                 A[i][j].ae*=tau;
				                                 A[i][j].an*=tau;
				                                 A[i][j].as*=tau;
				                                 A[i][j].aw*=tau;
				                                 rthdsd_internal[i][j]+=curl_old[i][j];
			                                 }
		                                 }
									  }

								      // нижняя релаксация для вихря.
						              for (int i=1; i<M+1; i++) {
		                                  for (int j=1; j<N+1; j++) {
				                              A[i][j].ap/=alpha;				                        
				                              rthdsd_internal[i][j]+=A[i][j].ap*(1.0-alpha)*curl_oldi[i][j];
			                              }
		                              }

								   break;
			           case PATANKAR :	
						   
						            if (idim==DIMENSIONLESS) {
										 // безразмерные
#if MY_FLOAT
										constrAPatankar(A, my_bound_curl, u, v, 1.0f, 1.0f/Re, xf, yf, M, N);
#else
                                        constrAPatankar(A, my_bound_curl, u, v, 1.0, 1.0/Re, xf, yf, M, N);
#endif
										 
									}
									else if (idim==DIMENSIONAL) {
										 // размерные
						                 constrAPatankar(A, my_bound_curl, u, v, rho, mu, xf, yf, M, N);
									}

				                   for (int i=0; i<M+2; i++) {
		                                for (int j=0; j<N+2; j++) {
				                             // инициализация рассчитываемых величин.
				                             potent[i][j]=curl[i][j];
				                             potent_old[i][j]=curl[i][j];
		                                }
	                                }

						            for (int i=1; i<M+1; i++) {
		                                for (int j=1; j<N+1; j++) {
				                            // правая часть :
											 if (idim==DIMENSIONLESS) {
										         // безразмерные
												 rthdsd_internal[i][j]=(1.0/(Re*Re))*(Grvar_t[i1]*gradxtemperature[i][j]+Grvar_c[i4]*gradxconcentration[i][j])*h1*h2;
											 }
											 else if (idim==DIMENSIONAL) {
										         // размерные
			                                     rthdsd_internal[i][j]=rho*gy*(betaT*gradxtemperature[i][j]+betaC*gradxconcentration[i][j])*h1*h2;
											 }
									    }
						            }
									if (btimedepend) {
										  // нестационарный солвер.
						  				  for (int i=1; i<M+1; i++) {
		                                      for (int j=1; j<N+1; j++) {
				                                   A[i][j].ap+=rho*h1*h2/tau;				                        
				                                   rthdsd_internal[i][j]+=rho*h1*h2*curl_old[i][j]/tau;
			                                  }
		                                  }
									}

						            // нижняя релаксация для вихря.
						            for (int i=1; i<M+1; i++) {
		                                for (int j=1; j<N+1; j++) {
				                            A[i][j].ap/=alpha;				                        
				                            rthdsd_internal[i][j]+=A[i][j].ap*(1.0-alpha)*curl_oldi[i][j];
			                            }
		                            }
				                   break;
			      }

				  constrrthdsd0(rthdsd, rthdsd_internal, my_bound_curl, xf, yf, M, N); // правая часть.

		          // невязка :
		          residual(r, potent_old, rthdsd,  A, M, N);
				  //printf("%e\n",normar(r, M, N));
				  //getchar();

		          // решение СЛАУ:

		          itsolve_naiv(potent, potent_old, r, rthdsd, M, N, ialgcurl, A, iendcurl); // полностью явная схема при iendcurl==1 и ialgcurl==STANDART.
				  // Явная схема обладает очень жёстким ограничением на шаг по времени. В тоже время одна итерация полинейного метода вполне достаточна для 
				  // сходимости и не имеет ограничений на шаг по времени. Но на самом деле любой segregate имеет ограничение на шаг по времени.
				  // В общем было выяснено что увеличение количества итераций полинейного метода в данном месте не оказывает влияния на скорость выполнения
				  // точного граничного условия для вихря. Т.е. алгоритм Федоренко здесь по видимому не нужен. Многое зависит от возможности расчёта на неравномерной сетке.


		          /*
		          // Для вспомогательной системы имеем однородные граничные условия.
	              my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
	              //constrA0(Al, 1.0, MC, NC); // сборка матрицы.
		          // передача компонент скорости на грубую сетку.
		          my_restriction1(u, ul, M, N);
		          my_restriction1(v, vl, M, N);
		          constrASamarskii(Al, ul, vl, 1.0/Re, dzeta1, dzeta2, MC, NC); // сборка матрицы.
	              for (int i=0; i<MC+2; i++) {
		              for (int j=0; j<NC+2; j++) {
			              r_coarse[i][j]=0.0;
			              rthdsd_c[i][j]=0.0;
		              }
	              }
	              itsolve_Fedor(potent, potent_old, r, rthdsd, M, N, v1, v1_old,  r_coarse, rthdsd_c, MC, NC,ialgstreamfunc, A, Al);
		          //*/

		          // 6. Решение уравнения для функции тока : сборка матрицы, вычисление правой части и решение СЛАУ.

				  // Граничные условия для функции тока.
                  load_my_bound_stream_function(my_bound_psi, itask, time, xf, yf, M , N);

		          constrA0(A, my_bound_psi, 1.0, xf, yf, M, N); // сборка матрицы.
		          for (int i=0; i<M+2; i++) {
		              for (int j=0; j<N+2; j++) {
				          // правая часть :
				          curl[i][j]=potent[i][j]; // запоминаем рассчитанный вихрь.
				          // инициализация рассчитываемых величин.
				          potent[i][j]=stream_function[i][j];
				          potent_old[i][j]=stream_function[i][j];
		              }
	              }
			      for (int i=1; i<M+1; i++) {
		              for (int j=1; j<N+1; j++) {
				          // правая часть :
					      //rthdsd_internal[i][j]=-curl[i][j]*h1*h2; // правая часть в уравнении для функции тока.
						  rthdsd_internal[i][j]=-curl[i][j]; // для метода конечных разностей.
						  // так как теперь уравнение чистой дифузии собирается по способу контрольного объёма, то правую часть
						  // источниковый член теперь надо умножать на объём контрольного объёма.
						  // на объём контрольного объёма умножать ненужно если сборка осуществляется по способу конечных разностей.
				      }
			      }

				  constrrthdsd0(rthdsd, rthdsd_internal, my_bound_psi, xf, yf, M, N); // правая часть.

		          // невязка :
		          residual(r, potent_old, rthdsd,  A, M, N);
		          
				  // Граничные условия для функции тока
				  // на грубой сетке.
                  load_my_bound_stream_function(my_bound_coarse_psi, itask, time, xc, yc, MC , NC);

		          // Для вспомогательной системы имеем однородные граничные условия.
	              my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
	              constrA0(Al, my_bound_coarse_psi, 1.0, xc, yc, MC, NC); // сборка матрицы.
	              for (int i=0; i<MC+2; i++) {
		               for (int j=0; j<NC+2; j++) {
						   // инициализация.
						   // Здесь просто инициализация нулём не надо ничего заполнять 
						   // всё будет заполнено внутри алгоритма Федоренко.
			               r_coarse[i][j]=0.0;
			               rthdsd_c[i][j]=0.0;
		               }
	              }
				  // По видимому эллиптическое уравнение для функции тока требуется решать достаточно точно и здесь необойтись без быстросходящегося алгоритма.
				  int iend=300;
				  Real *residual_history=new Real[iend+1];
	              for (int i=0; i<iend; i++) {
	                  residual_history[i]=1.0; // инициализация.
	              }
	              itsolve_Fedor(potent, potent_old, r, rthdsd, M, N, v1, v1_old,  r_coarse, rthdsd_c, MC, NC,ialgstreamfunc, A, Al,stream_function_drop_tolerance,residual_history);
	              // нормированная октаэдрическая норма (сумма модулей).
	              for (int i=1; i<iend; i++) {
	                  residual_history[i]=residual_history[i]/residual_history[0];
	              }
	              residual_history[0]=1.0;

	              for (int i=0; i<iend; i++) {
	                   //printf("  %d   %1.4e  \n",i+1,residual_history[i]);
	              }
	              delete residual_history;
	              
		          // решение СЛАУ:
				  // Как альтернатив более медленно сходящийся солвер, он прост в использовании и на нём можно потренироваться.
		          //-->//itsolve_naiv(potent, potent_old, r, rthdsd, M, N, ialgstreamfunc, A,iendstreamfunc);
		          // 7. Вычисление компонент скорости.

		          for (int i=0; i<M+2; i++) {
		              for (int j=0; j<N+2; j++) {
				          stream_function[i][j]=potent[i][j];
			          }
		          }

				  // Данные параметры настроены на задачу Блазиуса.
				  if (itask==BLASIUS)
	              {
#if MY_FLOAT
					   stream_function[0][0]=0.0f;
	                   stream_function[M+1][0]=amplitude0*(lengthx/9.0f)*sin(Omega*time);
#else
                      stream_function[0][0]=0.0;
	                  stream_function[M+1][0]=amplitude0*(lengthx/9.0)*sin(Omega*time);
#endif
				     
	                  stream_function[0][N+1]=lengthy; // 1.0 безразмерная область
	                  stream_function[M+1][N+1]=lengthy; // 1.0 безразмерная область
				  }

		          // Экономично находит компоненты скорости по рассчитанной функции тока.
                  //calcvelocity1(stream_function, u, v,  M, N);
				  calcvelocity1(stream_function, u, v, xf, yf, M, N);
		          // 8. Рассчитываются новые граничные условия для вихря на твердой стенке по текущим значениям функции тока и вихря.
				  // Здесь введена нижняя релаксация см. Полежаев Пасконов Чудов.
		          //----->//curlbound(curl, stream_function, ischemeapprox, M, N, alpha);
				  // Здесь также нужно сделать обновление всех гидродинамических 
				  // граничных условий для всех величин смотри например задачу Блазиуса. 

			      bweshouldbecontinue=bfinish(curl, curl_oldi, epsilon_bon_curl, vorticity_boundary_conditions, M, N);
			      for (int i=0; i<M+2; i++) {
		              for (int j=0; j<N+2; j++) {
					      curl_oldi[i][j]=curl[i][j];
				      }
		          }

			      if (ic1%10==0) {
				      printf("vorticity_boundary_conditions\n");
			      }
				  ic1++;
			      printf("%d %1.4e\n",ic1, vorticity_boundary_conditions);

			      iteri++;
				  //getchar();
		     } // конец определения граничных условий для вихря.

		

		     // 9. Решение уравнения для температуры : сборка матрицы, нулевая правая часть, решение СЛАУ.
			 load_my_bound_temp(my_bound_temp, itask, xf, yf, M,N);

		     switch(iconstrA) {
			      case SAMARSKII : 
					                if (idim==DIMENSIONLESS) {
										 // безразмерные
 #if MY_FLOAT
#else
#endif
										 constrASamarskii(A, my_bound_temp, u, v, 1.0/(Re*Prvar[i3]), dzeta1, dzeta2, xf, yf, M, N);  // сборка матрицы.
									 }
									 else if (idim==DIMENSIONAL) {
										 // размерные
						                 constrASamarskii(A, my_bound_temp, u, v, lambda/(rho*Cp), dzeta1, dzeta2, xf, yf, M, N); // сборка матрицы.
									 }

		                      
		                     for (int i=0; i<M+2; i++) {
		                         for (int j=0; j<N+2; j++) {
				                    // инициализация рассчитываемых величин.
				                    potent[i][j]=temperature[i][j];
				                    potent_old[i][j]=temperature[i][j];
		                         }
	                         }

							 for (int i=1; i<M+1; i++) {
		                         for (int j=1; j<N+1; j++) {
				                    // правая часть :
			                        rthdsd_internal[i][j]=0.0;
								 }
							 }

							 if (btimedepend) {
									// нестационарный солвер.
		                            for (int i=1; i<M+1; i++) {
		                                for (int j=1; j<N+1; j++) {
#if MY_FLOAT
											 A[i][j].ap=1.0f+tau*A[i][j].ap;
#else
                                             A[i][j].ap=1.0+tau*A[i][j].ap;
#endif
			                    	       
				                            A[i][j].ae*=tau;
				                            A[i][j].an*=tau;
				                            A[i][j].as*=tau;
				                            A[i][j].aw*=tau;
				                            rthdsd_internal[i][j]+=temp_old[i][j];
			                            }
		                            }
							 }
		                     break;
			      case PATANKAR :	if (idim==DIMENSIONLESS) {
										 // безразмерные
 #if MY_FLOAT
					   constrAPatankar(A, my_bound_temp, u, v, 1.0f, 1.0f/(Re*Prvar[i3]), xf, yf, M, N);
#else
					   constrAPatankar(A, my_bound_temp, u, v, 1.0, 1.0/(Re*Prvar[i3]), xf, yf, M, N);
#endif
					                    
					                 }
									 else if (idim==DIMENSIONAL) {
										 // размерные
					                     constrAPatankar(A, my_bound_temp, u, v, rho*Cp, lambda, xf, yf, M, N);
									 }

				                    for (int i=0; i<M+2; i++) {
		                                 for (int j=0; j<N+2; j++) {
				                             // инициализация рассчитываемых величин.
				                             potent[i][j]=temperature[i][j];
				                             potent_old[i][j]=temperature[i][j];
		                                 }
	                                }

						            for (int i=1; i<M+1; i++) {
		                                 for (int j=1; j<N+1; j++) {
				                             // правая часть :
#if MY_FLOAT
											 rthdsd_internal[i][j]=0.0f*h1*h2;
#else
											 rthdsd_internal[i][j]=0.0*h1*h2;
#endif
			                                 
									     }
						            }
						  
						            if (btimedepend) {
									    // нестационарный солвер.
						                for (int i=1; i<M+1; i++) {
		                                    for (int j=1; j<N+1; j++) {
												if (idim==DIMENSIONLESS) {
										           // безразмерные
                                                   A[i][j].ap+=Sh*h1*h2/tau;				                        
				                                   rthdsd_internal[i][j]=Sh*h1*h2*temp_old[i][j]/tau;
												}
												else if (idim==DIMENSIONAL) {
										            // размерные
				                                    A[i][j].ap+=rho*Cp*h1*h2/tau;				                        
				                                    rthdsd_internal[i][j]=rho*Cp*h1*h2*temp_old[i][j]/tau;
												}
			                                }
		                                }
									}
								
				             break;
			       }

			       constrrthdsd0(rthdsd, rthdsd_internal, my_bound_temp, xf, yf, M, N); // правая часть.

		           // невязка :
		           residual(r, potent_old, rthdsd,  A, M, N);
				   //exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, temp_old, gradxtemperature, xf, yf, M, N);
				   //printf("%e %e %e %e %e\n",A[5][5].ae,A[5][5].an,A[5][5].as,A[5][5].aw,A[5][5].ap);
				   //printf("start");
				   //getchar();

				   //bflag=true;
		           // решение СЛАУ:
		           itsolve_naiv(potent, potent_old, r, rthdsd, M, N, ialgtemp, A, iendtemp); // полностью явная схема при iendtemp==1 && ialgtemp==STANDART
				   // Дело в том что явная схема очень ограничительна в плане шага по времени поэтому здесь нужно использовать неявную схему которая не имеет ограничения
				   // на шаг по времени. Для этих целей вполне достаточно одной итерации полинейного метода.
				   // Вычисление на данном итерационном цикле нужно продолжать до тех пор пока поле температур не перестанет изменяться от итерации к итерации.
		
				   /*
		           // Для вспомогательной системы имеем однородные граничные условия.
	               my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
		           // передача компонент скорости на грубую сетку.
		           my_restriction1(u, ul, M, N);
		           my_restriction1(v, vl, M, N);
		           constrASamarskii(Al, ul, vl, 1.0/Pr, dzeta1, dzeta2, MC, NC); // сборка матрицы.
	               for (int i=0; i<MC+2; i++) {
		               for (int j=0; j<NC+2; j++) {
			               r_coarse[i][j]=0.0;
			               rthdsd_c[i][j]=0.0;
		               }
	               }
	               itsolve_Fedor(potent, potent_old, r, rthdsd, M, N, v1, v1_old,  r_coarse, rthdsd_c, MC, NC,ialgstreamfunc, A, Al);
		           */

				   Real temperature_mismatch;
				   bweshouldbecontinuetemp=bfinish_temp(potent, temperature, epsilon_temperature, temperature_mismatch, M, N);
				   printf("temperature mismatch is equal=%1.4e\n",temperature_mismatch);
				   //getchar();

		           for (int i=0; i<M+2; i++) {
		               for (int j=0; j<N+2; j++) {
				           temperature[i][j]=potent[i][j];
			           }
		           }

				   // 10. Решение уравнения для концентрации : сборка матрицы, нулевая правая часть, решение СЛАУ.
			       load_my_bound_conc(my_bound_conc, itask, xf, yf, M,N);

		            switch(iconstrA) {
			            case SAMARSKII : 
					                if (idim==DIMENSIONLESS) {
										 // безразмерные
#if MY_FLOAT
										constrASamarskii(A, my_bound_conc, u, v, 1.0f/(Re*Scvar[i2]), dzeta1, dzeta2, xf, yf, M, N);  // сборка матрицы.

#else
                                         constrASamarskii(A, my_bound_conc, u, v, 1.0/(Re*Scvar[i2]), dzeta1, dzeta2, xf, yf, M, N);  // сборка матрицы.
#endif
										 
									 }
									 else if (idim==DIMENSIONAL) {
										 // размерные
						                 constrASamarskii(A, my_bound_conc, u, v, D/(rho), dzeta1, dzeta2, xf, yf, M, N); // сборка матрицы.
									 }

		                      
		                     for (int i=0; i<M+2; i++) {
		                         for (int j=0; j<N+2; j++) {
				                    // инициализация рассчитываемых величин.
				                    potent[i][j]=concentration[i][j];
				                    potent_old[i][j]=concentration[i][j];
		                         }
	                         }


							 if (sizeof(Real)==8) {
							 for (int i=1; i<M+1; i++) {
		                         for (int j=1; j<N+1; j++) {
				                    // правая часть :
			                        rthdsd_internal[i][j]=0.0;
								 }
							 }

							 if (btimedepend) {
									// нестационарный солвер.
		                            for (int i=1; i<M+1; i++) {
		                                for (int j=1; j<N+1; j++) {
#if MY_FLOAT
											A[i][j].ap=1.0f+tau*A[i][j].ap;
#else
											A[i][j].ap=1.0+tau*A[i][j].ap;
#endif
			                    	        
				                            A[i][j].ae*=tau;
				                            A[i][j].an*=tau;
				                            A[i][j].as*=tau;
				                            A[i][j].aw*=tau;
				                            rthdsd_internal[i][j]+=conc_old[i][j];
			                            }
		                            }
							 }
							 }
							  if (sizeof(Real)==4) {
							 for (int i=1; i<M+1; i++) {
		                         for (int j=1; j<N+1; j++) {
				                    // правая часть :
			                        rthdsd_internal[i][j]=0.0f;
								 }
							 }

							 if (btimedepend) {
									// нестационарный солвер.
		                            for (int i=1; i<M+1; i++) {
		                                for (int j=1; j<N+1; j++) {
			                    	        A[i][j].ap=1.0f+tau*A[i][j].ap;
				                            A[i][j].ae*=tau;
				                            A[i][j].an*=tau;
				                            A[i][j].as*=tau;
				                            A[i][j].aw*=tau;
				                            rthdsd_internal[i][j]+=conc_old[i][j];
			                            }
		                            }
							 }
							 }

		                     break;
			      case PATANKAR :	if (idim==DIMENSIONLESS) {
										 // безразмерные
#if MY_FLOAT
					    constrAPatankar(A, my_bound_conc, u, v, 1.0f, 1.0f/(Re*Scvar[i2]), xf, yf, M, N);
#else
                        constrAPatankar(A, my_bound_conc, u, v, 1.0, 1.0/(Re*Scvar[i2]), xf, yf, M, N);
#endif
					                  
					                 }
									 else if (idim==DIMENSIONAL) {
										 // размерные
					                     constrAPatankar(A, my_bound_conc, u, v, rho, D, xf, yf, M, N);
									 }

				                    for (int i=0; i<M+2; i++) {
		                                 for (int j=0; j<N+2; j++) {
				                             // инициализация рассчитываемых величин.
				                             potent[i][j]=concentration[i][j];
				                             potent_old[i][j]=concentration[i][j];
		                                 }
	                                }

#if MY_FLOAT
									 for (int i=1; i<M+1; i++) {
		                                 for (int j=1; j<N+1; j++) {
				                             // правая часть :
			                                 rthdsd_internal[i][j]=0.0f*h1*h2;
									     }
						            }
#else
                                    for (int i=1; i<M+1; i++) {
		                                 for (int j=1; j<N+1; j++) {
				                             // правая часть :
			                                 rthdsd_internal[i][j]=0.0*h1*h2;
									     }
						            }
#endif
									
									

						  
						            if (btimedepend) {
									    // нестационарный солвер.
						                for (int i=1; i<M+1; i++) {
		                                    for (int j=1; j<N+1; j++) {
												if (idim==DIMENSIONLESS) {
										           // безразмерные
                                                   A[i][j].ap+=Sh*h1*h2/tau;				                        
				                                   rthdsd_internal[i][j]=Sh*h1*h2*conc_old[i][j]/tau;
												}
												else if (idim==DIMENSIONAL) {
													// размерные
				                                    A[i][j].ap+=rho*h1*h2/tau;				                        
				                                    rthdsd_internal[i][j]=rho*h1*h2*conc_old[i][j]/tau;
												}
			                                }
		                                }
									}
								
				             break;
			       }

			       constrrthdsd0(rthdsd, rthdsd_internal, my_bound_conc, xf, yf, M, N); // правая часть.

		           // невязка :
		           residual(r, potent_old, rthdsd,  A, M, N);
				   //exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, temp_old, gradxtemperature, xf, yf, M, N);
				   //printf("%e %e %e %e %e\n",A[5][5].ae,A[5][5].an,A[5][5].as,A[5][5].aw,A[5][5].ap);
				   //printf("start");
				   //getchar();

				   //bflag=true;
		           // решение СЛАУ:
		           itsolve_naiv(potent, potent_old, r, rthdsd, M, N, ialgconc, A, iendconc); // полностью явная схема при iendconc==1 && ialgconc==STANDART
				   // Дело в том что явная схема очень ограничительна в плане шага по времени поэтому здесь нужно использовать неявную схему которая не имеет ограничения
				   // на шаг по времени. Для этих целей вполне достаточно одной итерации полинейного метода.
				   // Вычисление на данном итерационном цикле нужно продолжать до тех пор пока поле температур не перестанет изменяться от итерации к итерации.
		
				   /*
		           // Для вспомогательной системы имеем однородные граничные условия.
	               my_init_zero(0.0, 0.0, 0.0, 0.0, 0.0, v1, MC, NC);
		           // передача компонент скорости на грубую сетку.
		           my_restriction1(u, ul, M, N);
		           my_restriction1(v, vl, M, N);
		           constrASamarskii(Al, ul, vl, 1.0/Scvar[i2], dzeta1, dzeta2, MC, NC); // сборка матрицы.
	               for (int i=0; i<MC+2; i++) {
		               for (int j=0; j<NC+2; j++) {
			               r_coarse[i][j]=0.0;
			               rthdsd_c[i][j]=0.0;
		               }
	               }
	               itsolve_Fedor(potent, potent_old, r, rthdsd, M, N, v1, v1_old,  r_coarse, rthdsd_c, MC, NC,ialgconc, A, Al);
		           */

				   
				   Real conc_mismatch;
				   bweshouldbecontinuetemp=(bweshouldbecontinuetemp||bfinish_temp(potent, concentration, epsilon_conc, conc_mismatch, M, N));
				   printf("concentration mismatch is equal=%1.4e\n",conc_mismatch);
				   
				   //getchar();

		           for (int i=0; i<M+2; i++) {
		               for (int j=0; j<N+2; j++) {
				           concentration[i][j]=potent[i][j];
			           }
		           }
		           // 11. Если сходимость недостигнута то возвращение к пункту 4.
		           //getchar();

				   //exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, u, v, xf, yf, M, N);
		
				   iter++;
	    } // стационарные итерации алгоритма.

		// Запоминаем вихрь с текущего временного слоя.
		for (int i=0; i<M+2; i++) {
		    for (int j=0; j<N+2; j++) {
				curl_old[i][j]=curl[i][j];
			}
		}

		// запоминаем температуру и конценрацию с предыдущего временного слоя.
		for (int i=0; i<M+2; i++) {
		    for (int j=0; j<N+2; j++) {
				temp_old[i][j]=temperature[i][j];
				conc_old[i][j]=concentration[i][j];
			}
		}

		avgpointxvel+=u[ixpoint][iypoint];
		avgpointyvel+=v[ixpoint][iypoint];
	    avgpointcurl+=curl[ixpoint][iypoint];
		avgpointstreamfunc+=stream_function[ixpoint][iypoint];
		avgpointtemperature+=temperature[ixpoint][iypoint];
		avgpointconc+=concentration[ixpoint][iypoint];
		for (int i=0; i<M+2; i++) {
			for (int j=0; j<N+2; j++) {
				avgmag[i][j]+=sqrt(u[i][j]*u[i][j]+v[i][j]*v[i][j]);
				avgxvel[i][j]+=u[i][j];
				avgyvel[i][j]+=v[i][j];
				avgcurl[i][j]+=curl[i][j];
				avgsf[i][j]+=stream_function[i][j];
				avgtemp[i][j]+=temperature[i][j];
				avgconc[i][j]+=concentration[i][j];
			}
		}


		if (inumbertimestep%100==0) {
			avgpointxvel/=100.0;
			avgpointyvel/=100.0;
			avgpointcurl/=100.0;
			avgpointstreamfunc/=100.0;
			avgpointtemperature/=100.0;
			avgpointconc/=100.0;
			// печать осреднённых за период значений в контрольной точке.
			exportmonitorpoint(avgpointxvel, avgpointyvel, avgpointcurl, avgpointstreamfunc, avgpointtemperature, xpoint , ypoint, false);
			// сброс.
			avgpointxvel=0.0;
			avgpointyvel=0.0;
			avgpointcurl=0.0;
			avgpointstreamfunc=0.0;
			avgpointtemperature=0.0;
			avgpointconc=0.0;

			for (int i=0; i<M+2; i++) {
			   for (int j=0; j<N+2; j++) {
			      avgmag[i][j]/=100.0;
			      avgxvel[i][j]/=100.0;
			      avgyvel[i][j]/=100.0;
			      avgcurl[i][j]/=100.0;
			      avgsf[i][j]/=100.0;
			      avgtemp[i][j]/=100.0;
				  avgconc[i][j]/=100.0;
				}
		    }
			exporttecplotNSRoacheFedushkin(avgcurl, avgsf, avgtemp, avgxvel, avgyvel, xf, yf, M, N);
			// инициализация нулём.
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgmag, M, N);
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgxvel, M, N);
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgyvel, M, N);
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgcurl, M, N);
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgsf, M, N);
	        my_init_zero(bleft, bright, bbottom, btop, 0.0, avgtemp, M, N);
			my_init_zero(bleft, bright, bbottom, btop, 0.0, avgconc, M, N);
		}

	    //exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, u, v, xf, yf, M, N);
		//exporttecplotNSRoacheFedushkinanimate(curl, stream_function, temperature, u, v, xf, yf, icadr++, M, N);
		if (btimedepend)  {
			printf("time\n");
		    printf("%e\n",time);
		}

		

	} // шаги по времени.

	

	     if (btimedepend)  {
	         printf("time=%e\n",time);
	     }

		 // формируем отчёт многопараметрического вычисления.

		 for (int i11=0; i11<M+2; i11++) {
			 report[i11][0][ivariantcount]=u[i11][iypoint]; // горизонтальная скорость.
			 report[i11][1][ivariantcount]=v[i11][iypoint]; // вертикальная скорость.
			 report[i11][2][ivariantcount]=stream_function[i11][iypoint]; // функция тока.
		 }

		 // 12.1 Вычисление градиента концентрации по игрик.
		 calc_grady(fbuf1, concentration, xf, yf, M, N);
		  for (int i11=0; i11<M+2; i11++) {
			 report[i11][3][ivariantcount]=fbuf1[i11][iypoint]; // вертикальная производная от концентрации.
		 }
		 // 12.2 Вычисление градиента температуры по игрик.
		 calc_grady(fbuf1, temperature, xf, yf, M, N);
		  for (int i11=0; i11<M+2; i11++) {
			 report[i11][4][ivariantcount]=fbuf1[i11][iypoint]; // вертикальная производная от температуры.
		 }
		  // 12.3 Вычисление градиента концентрации по икс.
		  calc_gradx(fbuf1, concentration, xf, yf, M, N);
		  for (int i11=0; i11<M+2; i11++) {
			 report[i11][5][ivariantcount]=fbuf1[i11][iypoint]; // вертикальная производная от концентрации.
		 }
         // 12.4 Вычисление градиента температуры по икс.
		 calc_gradx(fbuf1, temperature, xf, yf, M, N);
		  for (int i11=0; i11<M+2; i11++) {
			 report[i11][6][ivariantcount]=fbuf1[i11][iypoint]; // вертикальная производная от температуры.
		 }


		 for (int i11=0; i11<N+2; i11++) {
			 // Число Нуссельта на левой стенке.
			  if (idim==DIMENSIONLESS) {
					// безразмерные
			        reportNusselt[i11][ivariantcount]=Prvar[i3]*u[1][i11]*temperature[1][i11]/fabs(temperature[1][i11]-temperature[0][i11]);
			  }
			  else if (idim==DIMENSIONAL) {
				    // размерные
				  reportNusselt[i11][ivariantcount]=rho*Cp*u[1][i11]*temperature[1][i11]/(lambda*fabs(temperature[1][i11]-temperature[0][i11]));
			  }
		 }

	     ivariantcount++; // переходим к следующему набору определяющих параметров.

		// getchar();

	} // конец варьирования параметров.
	 
	// нормирует значения каждого графика от нуля до единицы.
    /*
     * n1 - количество функций в групе.
     * n2 - число групп.
     * n3 - количество точек на графике M+2
     */
	renormreport(report, 5, iPr*iSc*iGr_c*iGr_t, M+2); // нормировка.
	// экспорт отчёта о вычислении в текстовый файл.
	printreport(xf, report, M+2, 7, iPr*iSc*iGr_c*iGr_t);
	// нормировка.
	renormNusseltreport(reportNusselt, N+2, iPr*iSc*iGr_c*iGr_t);
	// экспорт чисел Нуссельта в текстовый файл.
	printNusseltreport(yf, reportNusselt, N+2,  iPr*iSc*iGr_c*iGr_t);


	// печать в файл рассчитанной температуры перпендикуляно пластине
    // в точке проходящей через её центр.
    //exportgradtemp(avgtemp, yf, ixpoint, M, N);

	// уничтожение памяти.
	my_free_universal(avgmag, M,N);
	my_free_universal(avgxvel, M,N);
	my_free_universal(avgyvel, M,N);
	my_free_universal(avgcurl, M,N);
	my_free_universal(avgsf, M,N);
	my_free_universal(avgtemp, M,N);

	my_free_universal(conc_old, M,N);
	my_free_universal(concentration, M,N);
	my_free_universal(fbuf1, M,N);

	// освобождение памяти из под отчёта.
	for (int i11=0; i11<M+2; i11++) {
		for (int i12=0; i12<5; i12++) {
			delete report[i11][i12];
		}
	}
	for (int i11=0; i11<M+2; i11++) {
		delete report[i11];
	}
	delete report;
	for (int i1=0; i1<N+2; i1++) {
		delete reportNusselt[i1];
	}
	delete reportNusselt;

    calculation_end_time=clock();
	calculation_seach_time=calculation_end_time-calculation_start_time;
	int im=0, is=0, ims=0;
	im=(int)(calculation_seach_time/60000); // минуты
	is=(int)((calculation_seach_time-60000*im)/1000); // секунды
    ims=(int)((calculation_seach_time-60000*im-1000*is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");

	// экспорт результата вычисления в программу tecplot.
    //exporttecplotNSRoacheFedushkin(curl, stream_function, temperature, u, v, xf, yf, M, N);
	exporttecplotJul(curl, stream_function, temperature, concentration, u, v, xf, yf, M, N);
	getchar();

} // Jul


void startMESFET() {

	const bool banded_matrix_method=false;//false; // переключатель на прямой и абсолютно точный решатель.

	FILE *fp;
	errno_t err1;
	
	if ((err1=fopen_s(&fp,"task.txt","r"))!=0) {
		printf("Not Found and open file task.txt\n");
		// Vd and Vg останутся заданными как выше.
	}
	else {
		int din;
		fscanf_s(fp, "%d", &din);
		// 0 Si
		// 1 VAX Si
		// 2 GaAs
		// 3 VAX GaAs
		if (din==0) {
			// одна точка ВАХ для кремния 
			if (!banded_matrix_method) {
			   startMESFETSi();
			}
			else {
			   startMESFETSi_Gauss();
			}
		}
		if (din==1) {
			// одна ветка ВАХ для кремния 
			if (!banded_matrix_method) {
			   startMESFETSi_VAX();
			}
			else {
			   startMESFETSi_Gauss_VAX();
			}
		}
		
		if (din==4) {
			// Одна точка ВАХ для Арсенида Галлия.
			if (!banded_matrix_method) {
			    startMESFETGaAs();
			}
			else {
			    startMESFETGaAs_Gauss();
			}
		}
		if (din==5) {
			// Одна ветка ВАХ для Арсенида Галлия.
			if (!banded_matrix_method) {
			   startMESFETGaAs_VAX();
			}
			else {
				// на основе прямого метода исключения неизвестных.
			   startMESFETGaAs_Gauss_VAX();
			}
		}
		
		if  (din==12) {
			// одна точка ВАХ для нитрида Галлия
			if (!banded_matrix_method) {
		        startMESFETGaN();
			}
			else {
			    startMESFETGaN_Gauss();
			}
		}
		if  (din==13) {
			// одна ветка ВАХ для нитрида Галлия
			if (!banded_matrix_method) {
		        startMESFETGaN_VAX();
			}
			else {
				// основано на методе Гаусса.
				startMESFETGaN_Gauss_VAX();
			}
		}		
		fclose(fp);
	}
}


void alloc_u3D(Real*** &u, int m, int n, int l) {
	u = new Real**[m + 2];
	for (int i = 0; i <= m + 1; i++) {
		u[i] = new Real*[n + 2];
		for (int j = 0; j <= n + 1; j++) {
			u[i][j] = new Real[l + 2];
		}
	}
}

void free_u3D(Real***& u, int m, int n, int l) {
	for (int i = 0; i <= m + 1; i++) {
		for (int j = 0; j <= n + 1; j++) {
			delete[] u[i][j];
		}
	}
	for (int i = 0; i <= m + 1; i++) {
		delete[] u[i];
	}
	delete[] u;
}

void init_u3D(Real***& u, int m, int n, int l, Real initVal) {

#pragma omp parallel for
	for (int i = 0; i < m + 2; i++) {
		for (int j = 0; j < n + 2; j++) {
			for (int k = 0; k < l + 2; k++) {
				u[i][j][k] = initVal;
			}
		}
	}
}

// Начало 18.05.2021
void DFTsolver3D() {

	// Замер времени.
	unsigned int calculation_start_time = 0; // начало счёта мс.
	unsigned int calculation_end_time = 0; // окончание счёта мс.
	unsigned int calculation_seach_time = 0; // время выполнения участка кода в мс.

	calculation_start_time = clock();

	Real*** u, ***source; // рассчитываемый потенциал и тепловая мощность.

	Real ***a, ***b; // Коэффициенты разложения в дискретный ряд Фурье.


	lengthx = 420.0e-6;
	lengthy = 420.0e-6;

	M = 199;
	N = 199;

	Real Tamb = 22.0;

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1 = (Real)(lengthx / (M + 1));
	Real h2 = (Real)(lengthy / (N + 1));

	Real* xf = new Real[M + 2];
	for (int i = 0; i < M + 2; i++) {
		xf[i] = (Real)(i * h1);
	}
	Real* yf = new Real[N + 2];
	for (int i = 0; i < N + 2; i++) {
		yf[i] = (Real)(i * h2);
	}

	Real lengthz = 200e-6;
	int izstop = 10;
	int L = 19;
	Real hz = (Real)(lengthz / (L + 1));
	Real* zf = new Real[L + 2];
	Real* lambda= new Real[L + 2];// Теплопроводность.
	for (int i = 0; i < L + 2; i++) {
		zf[i] = (Real)(i * hz);
		if (i > izstop) {
			lambda[i] = 0.026; // air
		}
		else {
			lambda[i] = 370.0; // SiC
		}
	}

	int Nx = M + 1; // < M+2
	int Ny = N + 1; // < N+2
	int Nz = L + 1;

	

	alloc_u3D(source, M, N, L);	
	alloc_u3D(b, M, N, L);

	// инициализация.
	init_u3D(b, M, N, L, 0.0);
	init_u3D(source, M, N, L, 0.0);

	

	// Задаём тепловую мощность тепловыделения.
	for (int i = M / 2 - 6; i < M / 2 + 7; i++) {
		for (int j = N / 2 - 6; j < N / 2 + 7; j++) {
			source[i][j][izstop] = 1.0/(13*13*h1*h2*hz);
		}
	}

	
	Real Ad = (2.0 / Nx) * (2.0 / Ny);

	// Преобразование правой части.
#pragma omp parallel for
	for (int k = 1; k < Nz - 1; k++) {

		for (int i = 1; i < Nx - 1; i++) {
			for (int j = 1; j < Ny - 1; j++) {
				b[i][j][k] = 0.0;

				for (int i1 = 1; i1 < Nx - 1; i1++) {
					Real d = Ad*sin(M_PI * i * i1 / Nx);
					Real dk = M_PI * j / Ny;

					for (int j1 = 1; j1 < Ny - 1; j1++) {
						b[i][j][k] += source[i1][j1][k]* d * sin(dk * j1);
					}
				}
			}
		}
	}

	std::cout << "1" << std::endl;

	free_u3D(source, M, N, L);
	alloc_u3D(a, M, N, L);	
	init_u3D(a, M, N, L, 0.0);	

	// Ядро солвера.
#pragma omp parallel for
	for (int i = 1; i < Nx - 1; i++) {
		for (int j = 1; j < Ny - 1; j++) {

			double* P = new double[Nz + 1];
			double* Q = new double[Nz + 1];

			double beta = (h1 / hz), beta2 = beta * beta;

			// Для фиксированного k решение системы  с трёх диагональной матрицей:
			double b1 = beta2;
			double a1 = 4.0 + 2.0 * beta2 - 2.0 * cos(M_PI * i / Nx) - 2.0* cos(M_PI * j / Ny);
			P[1] = b1 / a1;
			double d1 = -h1 * h1 * b[i][j][1]/ lambda[1];
			Q[1] = d1 / a1;

			for (int k = 2; k <= Nz; k++) {
				double bk = beta2;
				double ck = beta2;
				double ak = 4.0 + 2.0 * beta2 - 2.0 * cos(M_PI * i / Nx) - 2.0 * cos(M_PI * j / Ny);
				double dk = -h1 * h1 * b[i][j][k] / lambda[k];

				P[k] = bk / (ak - ck * P[k - 1]);
				Q[k] = (dk + ck * Q[k - 1]) / (ak - ck * P[k - 1]);
			}
			a[i][j][Nz] = Q[Nz];

			for (int k = Nz - 1; k >= 1; k--) {
				a[i][j][k] = P[k] * a[i][j][k + 1] + Q[k];
			}

			delete[] P;
			delete[] Q;
		}
	}

	std::cout << "2" << std::endl;

	free_u3D(b, M, N, L);
	alloc_u3D(u, M, N, L);
	init_u3D(u, M, N, L, Tamb);

	/*
	// Находим искомую функцию.
#pragma omp parallel for
	for (int k = 1; k < Nz - 1; k++) {
		for (int i = 1; i < Nx - 1; i++) {
			for (int j = 1; j < Ny - 1; j++) {

				u[i][j][k] = 0.0;

				for (int i1 = 1; i1 < Nx - 1; i1++) {
					for (int j1 = 1; j1 < Ny - 1; j1++) {
						u[i][j][k] -=  a[i1][j1][k] * sin(M_PI * i * i1 / Nx) * sin(M_PI * j * j1 / Ny);
					}
				}
			}
		}
	}
	*/
	// Находим искомую функцию.
#pragma omp parallel for
	for (int k = 1; k < Nz - 1; k++) {
		for (int i = 1; i < Nx - 1; i++) {
			for (int j = 1; j < Ny - 1; j++) {

				//u[i][j][k] = 0.0;

				for (int i1 = 1; i1 < Nx - 1; i1++) {
					Real d = sin(M_PI * i * i1 / Nx);
					Real dk = M_PI * j / Ny;

					for (int j1 = 1; j1 < Ny - 1; j1++) {
						u[i][j][k] -= a[i1][j1][k] * d * sin(dk * j1);
					}
				}
			}
		}
	}


	std::cout << "3" << std::endl;

	free_u3D(a, M, N, L);	

	// экспорт 3D полевой величины u в программу tecplot 360.
	exporttecplot3D(u, xf, yf, zf, M, N, izstop-1);

	free_u3D(u, M, N, L);	

	delete[] xf;
	delete[] yf;
	delete[] zf;

	calculation_end_time = clock();
	calculation_seach_time = calculation_end_time - calculation_start_time;
	int im = 0, is = 0, ims = 0;
	im = (int)(calculation_seach_time / 60000); // минуты
	is = (int)((calculation_seach_time - 60000 * im) / 1000); // секунды
	ims = (int)((calculation_seach_time - 60000 * im - 1000 * is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");

} // DFTsolver3D();


void IDFTxold(Real***& u, Real***& f, int m, int n, int l) {

	int Nx = m + 1; // < M+2
	int Ny = n + 1; // < N+2
	int Nz = l + 1;


	Real Ad = (2.0 / Nx);

	// Преобразование правой части.
#pragma omp parallel for
	for (int k = 1; k < Nz - 1; k++) {
		for (int j = 1; j < Ny - 1; j++) {

		for (int i = 1; i < Nx - 1; i++) {
			
				u[i][j][k] = 0.0;

				for (int i1 = 1; i1 < Nx - 1; i1++) {
					
						u[i][j][k] += Ad*f[i1][j][k] * sin(M_PI * i * i1 / Nx);
					
				}
			}
		}
	}
}

void IDFTyold(Real***& u, Real***& f, int m, int n, int l) {

	int Nx = m + 1; // < M+2
	int Ny = n + 1; // < N+2
	int Nz = l + 1;


	Real Ad = (2.0 / Ny);

	// Преобразование правой части.
#pragma omp parallel for
	for (int k = 1; k < Nz - 1; k++) {
		for (int i = 1; i < Nx - 1; i++) {



		for (int j = 1; j < Ny - 1; j++) {			

				u[i][j][k] = 0.0;

				for (int j1 = 1; j1 < Ny - 1; j1++) {

					u[i][j][k] += Ad * f[i][j1][k] * sin(M_PI * j * j1 / Ny);

				}
			}
		}
	}
}

void DFTx1(Real***& u, Real***& a, int m, int n, int l) {

	int Nx = m + 1; // < M+2
	int Ny = n + 1; // < N+2
	int Nz = l + 1;

	// Находим искомую функцию.
#pragma omp parallel for
	for (int k = 1; k < Nz - 1; k++) {
		for (int j = 1; j < Ny - 1; j++) {


			for (int i = 1; i < Nx - 1; i++) {
				u[i][j][k] = 0.0;

				for (int i1 = 1; i1 < Nx - 1; i1++) {
					u[i][j][k] -= a[i1][j][k] * sin(M_PI * i * i1 / Nx);
				}
			}
		}
	}

}


void fft_real(Real*& a, int n, bool invert) {

	if (n == 1) return;

	double* a0 = new double[n / 2];
	double* a1 = new double[n / 2];

	for (int i = 0, j = 0; i < n; i += 2, ++j) {
		a0[j] = a[i];
		a1[j] = a[i + 1];
	}
	fft_real(a0, n / 2, invert);
	fft_real(a1, n / 2, invert);

	double w = 1.0;
	double ang = M_PI / n * (invert ? -1 : 1);
	for (int i = 0; i < n / 2; ++i) {
		a[i] = a0[i] + w * a1[i];
		a[i + n / 2] = a0[i] - w * a1[i];

		if (invert) {
			a[i] /= 2;
			a[i + n / 2] /= 2;
		}

		w *= cos(ang);
	}


	delete[] a0;
	delete[] a1;
}



#include <iostream>
#include <iomanip>
#include <complex>
#include <cmath>
typedef std::complex<double> base;

void fft(base* &a, int n, bool invert) {

	if (n == 1) return;

	base* a0 = new base[n / 2];
	base* a1 = new base[n / 2];

	for (int i = 0, j = 0; i < n; i += 2, ++j) {
		a0[j] = a[i];
		a1[j] = a[i + 1];
	}
	fft(a0, n/2, invert);
	fft(a1, n/2, invert);

	base w  (1,0);
	double ang = 2.0*M_PI / n * (invert ? -1 : 1);
	base wn(cos(ang), sin(ang));
	for (int i = 0; i < n / 2; ++i) {
		a[i] = a0[i] + w * a1[i];
		a[i + n / 2] = a0[i] - w * a1[i];
		
		if (invert) {
			a[i] /= 2;
			a[i + n / 2] /= 2;
		}

		w *= wn;
	}

	delete[] a0;
	delete[] a1;
}

void DFTx(Real***& u, Real***& a, int m, int n, int l) {

	int Nx = m + 1; // < M+2
	int Ny = n + 1; // < N+2
	int Nz = l + 1;	

	// Находим искомую функцию.

#pragma omp parallel for
	for (int k = 1; k < Nz - 1; k++) {

		base* a1 = new base[Nx];

		for (int j = 0; j <= Ny - 1; j++) {			

			a1[0]= (0.0, 0.0);
			for (int i = 1; i < Nx - 1; i++) {
				a1[i-1] = (0.0,a[i][j][k]);
			}
			fft(a1, Nx-2,false);
			for (int i = 1; i < Nx - 1; i++) {
				u[i][j][k] = -a1[i-1]._Val[0];
			}			
		}

		delete[] a1;
	}
	
}

void DFTy(Real***& u, Real***& a, int m, int n, int l) {

	int Nx = m + 1; // < M+2
	int Ny = n + 1; // < N+2
	int Nz = l + 1;	

	// Находим искомую функцию.
#pragma omp parallel for
	for (int k = 1; k < Nz - 1; k++) {

		base* a1 = new base[Ny];

		for (int i = 0; i <= Nx - 1; i++) {
			
			for (int j = 1; j < Ny - 1; j++) {
				a1[j-1] = (0.0,a[i][j][k]);
			}
			fft(a1, Ny-2, false);
			for (int j = 1; j < Ny - 1; j++) {
				u[i][j][k] = -a1[j-1]._Val[0];
			}
		}	

		delete[] a1;
	}	
}


void IDFTx(Real***& u, Real***& f, int m, int n, int l) {

	int Nx = m + 1; // < M+2
	int Ny = n + 1; // < N+2
	int Nz = l + 1;

	// Преобразование правой части.
#pragma omp parallel for
	for (int k = 1; k < Nz - 1; k++) {


		base* a1 = new base[Nx];

		for (int j = 0; j <= Ny - 1; j++) {

			for (int i = 1; i < Nx - 1; i++) {

				a1[i-1] = (0.0,f[i][j][k]);
			}
			
			fft(a1, Nx-2,true);
			for (int i = 1; i < Nx - 1; i++) {		

				u[i][j][k] = a1[i-1]._Val[0];			
			}
		}

		delete[] a1;
	}
}

void IDFTy(Real***& u, Real***& f, int m, int n, int l) {

	int Nx = m + 1; // < M+2
	int Ny = n + 1; // < N+2
	int Nz = l + 1;
	
	// Преобразование правой части.
#pragma omp parallel for
	for (int k = 1; k < Nz - 1; k++) {


		base* a1 = new base[Ny];

		for (int i = 0; i <= Nx - 1; i++) {
			
			for (int j = 1; j < Ny - 1; j++) {
				a1[j-1] = (0.0,f[i][j][k]);
			}
			fft(a1, Ny-2, true);
			for (int j = 1; j < Ny - 1; j++) {
				u[i][j][k] = a1[j-1]._Val[0];
			}
		}

		delete[] a1;
	}	
}


void copy3D(Real***& source, Real***& b, int m, int n, int l, bool plus, bool scal, Real val) {

	int Nx = m + 1; // < M+2
	int Ny = n + 1; // < N+2
	int Nz = l + 1;

	if (scal) {
		// добавляем скаляр.
#pragma omp parallel for
		for (int i = 0; i <= Nx; i++) {
			for (int j = 0; j <= Ny; j++) {
				for (int k = 0; k <= Nz; k++) {

					source[i][j][k] += val;
				}
			}
		}
	}
	else {

		if (plus) {

#pragma omp parallel for
			for (int i = 0; i <= Nx; i++) {
				for (int j = 0; j <= Ny; j++) {
					for (int k = 0; k <= Nz; k++) {

						source[i][j][k] = b[i][j][k];
					}
				}
			}

		}
		else {

#pragma omp parallel for
			for (int i = 0; i <= Nx; i++) {
				for (int j = 0; j <= Ny; j++) {
					for (int k = 0; k <= Nz; k++) {

						source[i][j][k] = -b[i][j][k];
					}
				}
			}
		}
	}
} // copy3D

// Начало 18.05.2021
void DFTsolver3Dq_old() {

	// Замер времени.
	unsigned int calculation_start_time = 0; // начало счёта мс.
	unsigned int calculation_end_time = 0; // окончание счёта мс.
	unsigned int calculation_seach_time = 0; // время выполнения участка кода в мс.

	calculation_start_time = clock();

	Real*** u, *** source; // рассчитываемый потенциал и тепловая мощность.

	Real*** a, *** b; // Коэффициенты разложения в дискретный ряд Фурье.


	lengthx = 420.0e-6;
	lengthy = 420.0e-6;

	M = 33;//511;
	N = 33;// 511;

	Real Tamb = 22.0;

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1 = (Real)(lengthx / (M + 1));
	Real h2 = (Real)(lengthy / (N + 1));

	Real* xf = new Real[M + 2];
	for (int i = 0; i < M + 2; i++) {
		xf[i] = (Real)(i * h1);
	}
	Real* yf = new Real[N + 2];
	for (int i = 0; i < N + 2; i++) {
		yf[i] = (Real)(i * h2);
	}

	Real lengthz = 200e-6;
	int izstop = 10;
	int L = 19;
	Real hz = (Real)(lengthz / (L + 1));
	Real* zf = new Real[L + 2];
	Real* lambda = new Real[L + 2];// Теплопроводность.
	for (int i = 0; i < L + 2; i++) {
		zf[i] = (Real)(i * hz);
		if (i > izstop) {
			lambda[i] = 0.026; // air
		}
		else {
			lambda[i] = 370.0; // SiC
		}
	}

	int Nx = M + 1; // < M+2
	int Ny = N + 1; // < N+2
	int Nz = L + 1;


	alloc_u3D(source, M, N, L);
	alloc_u3D(b, M, N, L);

	// инициализация.
	init_u3D(b, M, N, L, 0.0);
	init_u3D(source, M, N, L, 0.0);



	// Задаём тепловую мощность тепловыделения.
	for (int i = M / 2 - 6; i < M / 2 + 7; i++) {
		for (int j = N / 2 - 6; j < N / 2 + 7; j++) {
			source[i][j][izstop] = 1.0 / (13 * 13 * h1 * h2 * hz);

			//printf("source=%e\n", source[i][j][izstop]);
			//getchar();
		}
	}

	
	IDFTx(b, source, M, N, L);

	copy3D(source, b, M, N, L, true, false, 0.0);

	IDFTy(b, source, M, N, L);	

	std::cout << "1" << std::endl;

	free_u3D(source, M, N, L);
	alloc_u3D(a, M, N, L);
	init_u3D(a, M, N, L, 0.0);

	// Ядро солвера.
#pragma omp parallel for
	for (int i = 1; i < Nx - 1; i++) {
		for (int j = 1; j < Ny - 1; j++) {

			double* P = new double[Nz + 1];
			double* Q = new double[Nz + 1];

			double beta = (h1 / hz), beta2 = beta * beta;

			// Для фиксированного k решение системы  с трёх диагональной матрицей:
			double b1 = beta2;
			double a1 = 4.0 + 2.0 * beta2 - 2.0 * cos(2.0*M_PI * i / Nx) - 2.0 * cos(2.0*M_PI * j / Ny);
			P[1] = b1 / a1;
			double d1 = -h1 * h1 * b[i][j][1] / lambda[1];
			Q[1] = d1 / a1;

			for (int k = 1; k <= Nz; k++) {
				double bk = beta2;
				double ck = beta2;
				double ak = 4.0 + 2.0 * beta2 - 2.0 * cos(2.0*M_PI * i / Nx) - 2.0 * cos(2.0*M_PI * j / Ny);
				double dk = -h1 * h1 * b[i][j][k] / lambda[k];

				P[k] = bk / (ak - ck * P[k - 1]);
				Q[k] = (dk + ck * Q[k - 1]) / (ak - ck * P[k - 1]);
			}
			a[i][j][Nz] = Q[Nz];

			for (int k = Nz - 1; k >= 1; k--) {
				a[i][j][k] = P[k] * a[i][j][k + 1] + Q[k];
			}

			delete[] P;
			delete[] Q;
		}
	}

	std::cout << "2" << std::endl;

	free_u3D(b, M, N, L);
	alloc_u3D(u, M, N, L);
	init_u3D(u, M, N, L, 0.0);

	DFTx(u, a, M, N, L);

	copy3D(a, u, M, N, L, false, false, 0.0);

	DFTy(u, a, M, N, L);

	copy3D(u, u, M, N, L, false, true, Tamb);

	std::cout << "3" << std::endl;

	free_u3D(a, M, N, L);

	// экспорт 3D полевой величины u в программу tecplot 360.
	//exporttecplot3D(u, xf, yf, zf, M, N, izstop - 1);
	exporttecplot3D_fft(u, xf, yf, zf, M, N, izstop - 1);

	free_u3D(u, M, N, L);

	delete[] xf;
	delete[] yf;
	delete[] zf;

	calculation_end_time = clock();
	calculation_seach_time = calculation_end_time - calculation_start_time;
	int im = 0, is = 0, ims = 0;
	im = (int)(calculation_seach_time / 60000); // минуты
	is = (int)((calculation_seach_time - 60000 * im) / 1000); // секунды
	ims = (int)((calculation_seach_time - 60000 * im - 1000 * is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");

} // DFTsolver3Dq_old();

typedef struct T_STACK_LAYERS {
	Real chikness; // Толщина в м.
	Real lambda; // теплопроводность, Вт/(м*К).
	int idiv_layer; // Количество ячеек в слое по толщине.
} STACK_LAYERS;

// экспорт 3D полевой величины u в программу tecplot 360.
void exporttecplot3D22D(Real***& u, Real*& x, Real*& y, Real*& z, int m, int n, int l) {
	FILE* fp;
	errno_t err;
	// создание файла для записи.
	if ((err = fopen_s(&fp, "fedorenko1.PLT", "w")) != 0) {
		printf("Create File Error\n");
	}
	else {

		// запись имён переменных
		fprintf(fp, "VARIABLES = x y u\n");
		fprintf(fp, "zone\n");
		fprintf(fp, "I=%d, J=%d, K=1, F=POINT\n", m + 2, n + 2);
		for (int j = 0; j < n + 2; j++) for (int i = 0; i < m + 2; i++)   fprintf(fp, "%e %e %e\n", x[i], y[j], u[i][j][l + 1]);
		fclose(fp);

		WinExec("C:\\Program\ Files\ (x86)\\Tecplot\\Tec360\ 2008\\bin\\tec360.exe fedorenko1.PLT", SW_NORMAL);
	}

	//getchar();

} // exporttecplot3D


// Начало 18.05.2021
void DFTsolver3Dq() {

	// Замер времени.
	unsigned int calculation_start_time = 0; // начало счёта мс.
	unsigned int calculation_end_time = 0; // окончание счёта мс.
	unsigned int calculation_seach_time = 0; // время выполнения участка кода в мс.

	calculation_start_time = clock();

	Real*** u, *** source; // рассчитываемый потенциал и тепловая мощность.

	Real*** a, *** b; // Коэффициенты разложения в дискретный ряд Фурье.

	Real Pdiss = 0.0;

	lengthx = 4098.0e-6;// 2050.0e-6;
	lengthy = 1625.0e-6;

	M = 4097; // 2049;//511;
	N = 129;// 511;

	/*lengthx = lengthy = 1.0;
	M = 32;
	N = 159;*/

	Real Tamb = 22.0;

	//Tamb = 0.0;

	// постоянные шаги сетки h1 по оси x и h2 по оси y.
	Real h1 = (Real)(lengthx / (M + 1));
	Real h2 = (Real)(lengthy / (N + 1));

	Real* xf = new Real[M + 2];
	for (int i = 0; i < M + 2; i++) {
		xf[i] = (Real)(i * h1);
	}
	Real* yf = new Real[N + 2];
	for (int i = 0; i < N + 2; i++) {
		yf[i] = (Real)(i * h2);
	}

	const int ilayer_count = 8;
	//const int idiv_layer = 4;
	STACK_LAYERS* stack_layer = new STACK_LAYERS[ilayer_count];
	stack_layer[0].chikness = 250.0e-6;// 1.6e-3;
	stack_layer[0].lambda = 210.0; // МД40
	stack_layer[0].idiv_layer = 7;
	stack_layer[1].chikness = 25.0e-6;
	stack_layer[1].lambda = 57.0; // AuSn
	stack_layer[1].idiv_layer = 4;
	stack_layer[2].chikness = 250.0e-6;
	stack_layer[2].lambda = 390.0; // Cu
	stack_layer[2].idiv_layer = 7;
	stack_layer[3].chikness = 25.0e-6;
	stack_layer[3].lambda = 57.0; // AuSn
	stack_layer[3].idiv_layer = 4;
	stack_layer[4].chikness = 100.0e-6;
	stack_layer[4].lambda = 370.0; // SiC
	stack_layer[4].idiv_layer = 7;
	stack_layer[5].chikness = 3.0e-6;
	stack_layer[5].lambda = 130.0;// 130.0; // GaN
	stack_layer[5].idiv_layer = 1;
	stack_layer[6].chikness = 5.0e-6;
	stack_layer[6].lambda = 317.0;// 317.0; // gold
	stack_layer[6].idiv_layer = 1;
	stack_layer[7].chikness = 250.0e-6;
	stack_layer[7].lambda = 1.0;// 0.026; // air
	stack_layer[7].idiv_layer = 7;

	Real lengthz = 0.0;
	int inodes = 0;
	//lengthz = 1.0;
	for (int i = 0; i < ilayer_count; i++) {
		lengthz += stack_layer[i].chikness;
		inodes += stack_layer[i].idiv_layer;
	}
	int izstop = inodes - stack_layer[ilayer_count - 1].idiv_layer + 1;
	int L = inodes + 1;

	//int izstop = 63;
	//int L = izstop=63;
	//Real hzc = (Real)(lengthz / (L + 1));
	Real* hz = new Real[L + 2];
	Real* zf = new Real[L + 2];
	Real* lambda = new Real[L + 2];// Теплопроводность.
	/*for (int i = 0; i < L + 2; i++) {
		zf[i] = (Real)(i * hzc);
		hz[i] = hzc;
		if (i > izstop) {
			lambda[i] = 1.0; // air
		}
		else {
			lambda[i] = 1.0; // SiC
		}
	}
	*/
	// 19.05.2021
	zf[0] = 0.0;
	hz[0] = stack_layer[0].chikness / stack_layer[0].idiv_layer;
	int ic = 1;
	lambda[0] = stack_layer[0].lambda;
	for (int i = 0; i < ilayer_count; i++) {
		for (int j = 0; j < stack_layer[i].idiv_layer; j++) {
			hz[ic] = stack_layer[i].chikness / stack_layer[i].idiv_layer;
			lambda[ic] = stack_layer[i].lambda;
			zf[1 + ic] = zf[ic] + hz[ic];
			ic++;
		}
	}
	zf[1 + ic] = zf[ic] + stack_layer[ilayer_count - 1].chikness / stack_layer[ilayer_count - 1].idiv_layer;
	hz[ic] = stack_layer[ilayer_count - 1].chikness / stack_layer[ilayer_count - 1].idiv_layer;
	lambda[ic] = stack_layer[ilayer_count - 1].lambda;
	hz[ic + 1] = stack_layer[ilayer_count - 1].chikness / stack_layer[ilayer_count - 1].idiv_layer;
	lambda[ic + 1] = stack_layer[ilayer_count - 1].lambda;


	int Nx = M + 1; // < M+2
	int Ny = N + 1; // < N+2
	int Nz = L + 1;

	for (int k = 1; k <= Nz; k++) {

		printf("%d %d lam=%e %e\n", k, izstop - 1, lambda[k], hz[k]);
	}
	//getchar();

	alloc_u3D(source, M, N, L);
	alloc_u3D(b, M, N, L);

	// инициализация.
	init_u3D(b, M, N, L, 0.0);
	init_u3D(source, M, N, L, 0.0);

	const Real power_1_polosok = 0.675;

	// Задаём тепловую мощность тепловыделения.
	//for (int i = M / 2 - 117; i < M / 2 + 124; i += 26) {// ПТБШ 1,25мм 2s 204Mb
	//for (int i = M / 2 - 234; i < M / 2 + 240; i += 26) {// ПТБШ 2,5мм 2s 204Mb
	//for (int i = M / 2 - 468; i < M / 2 + 480; i += 26) { // ПТБШ 5мм 2s 204Mb
		//for (int i = M / 2 - 936; i < M / 2 + 946; i += 26) { // ПТБШ 10мм 4s 420Mb
	for (int i = M / 2 - 1872; i < M / 2 + 1888; i += 26) { // ПТБШ 20мм 4s 420Mb
		//for (int j = N / 2 - 2; j < N / 2 + 3; j++) {
		for (int j = N / 2 - 5; j < N / 2 + 5; j++) {
			//if ((i - (M / 2 - 117)) % 26 == 0)
			{


				//source[i][j][izstop] = 0.675 / (5*h1*h2*hz[izstop-1]);
				double Ssource = 2.0 * 125e-12;
				double Vol_source = Ssource * hz[izstop - 1];
				source[i + 1][j][izstop - 1] = source[i][j][izstop - 1] = power_1_polosok / (Vol_source);

				
			}
		}
		Pdiss += power_1_polosok;
	}
	
	IDFTx(b, source, M, N, L);	

	copy3D(source, b, M, N, L, true, false, 0.0);

	IDFTy(b, source, M, N, L);

	std::cout << "1" << std::endl;

	free_u3D(source, M, N, L);
	alloc_u3D(a, M, N, L);
	init_u3D(a, M, N, L, 0.0);

	// Ядро солвера.
#pragma omp parallel for
	for (int i = 1; i < Nx - 1; i++) {
		for (int j = 1; j < Ny - 1; j++) {

			double* P = new double[Nz + 1];
			double* Q = new double[Nz + 1];

			double Rj1 = (2.0 * lambda[0] * lambda[1] / (lambda[0] + lambda[1])) * (2.0 / (hz[1] * (hz[1] + hz[0])));
			double Rjm1 = (2.0 * lambda[0] * lambda[1] / (lambda[0] + lambda[1])) * (2.0 / (hz[0] * (hz[1] + hz[0])));			

			// Для фиксированного k решение системы  с трёх диагональной матрицей:
			double b1 = Rj1;
			double a1 = 2.0 * lambda[1] / (h1 * h1) + 2.0 * lambda[1] / (h2 * h2) + (Rj1 + Rjm1) - 2.0 * cos(2.0*M_PI * i / Nx) * lambda[1] / (h1 * h1) - 2.0 * cos(2.0*M_PI * j / Ny) * lambda[1] / (h2 * h2);
			P[1] = b1 / a1;
			double d1 = -b[i][j][1];
			Q[1] = d1 / a1;

			for (int k = 2; k <= Nz; k++) {

				Real lmax = lambda[k];
				if (k != Nz) {
					lmax = lambda[k + 1];
				}
				double Rj = (2.0 * lambda[k] * lmax / (lambda[k] + lmax)) * (2.0 / (hz[k] * (hz[k] + hz[k - 1])));
				double Rjm1 = (2.0 * lambda[k - 1] * lambda[k] / (lambda[k - 1] + lambda[k])) * (2.0 / (hz[k - 1] * (hz[k] + hz[k - 1])));				

				// bk -> k+1
				// ck -> k-1
				double bk = Rj;
				double ck = Rjm1;
				double ak = (2.0 / (h1 * h1) + 2.0 / (h2 * h2)) * lambda[k] + (Rj + Rjm1) - 2.0 * cos(2.0*M_PI * i / Nx) * lambda[k] / (h1 * h1) - 2.0 * cos(2.0*M_PI * j / Ny) * lambda[k] / (h2 * h2);
				double dk = -b[i][j][k];

				P[k] = bk / (ak - ck * P[k - 1]);
				Q[k] = (dk + ck * Q[k - 1]) / (ak - ck * P[k - 1]);
			}
			a[i][j][Nz] = Q[Nz];

			for (int k = Nz - 1; k >= 1; k--) {
				a[i][j][k] = P[k] * a[i][j][k + 1] + Q[k];
			}

			delete[] P;
			delete[] Q;
		}
	}

	std::cout << "2" << std::endl;

	free_u3D(b, M, N, L);
	alloc_u3D(u, M, N, L);
	init_u3D(u, M, N, L, 0.0);	

	DFTx(u, a, M, N, L);
	
	copy3D(a, u, M, N, L, false, false, 0.0);

	DFTy(u, a, M, N, L);

	copy3D(u, u, M, N, L, true, true, Tamb);

	std::cout << "3" << std::endl;

	free_u3D(a, M, N, L);

	double tmax = -1.0e30;

	for (int i = 0; i < M + 2; i++) {
		for (int j = 0; j < N + 2; j++) {
			if (u[i][j][izstop - 1] > tmax) {
				tmax = u[i][j][izstop - 1];
			}
		}
	}

	printf("ambient temperature %2.1f C\n", Tamb);
	printf("maximum temperature %2.1f C\n", tmax);
	printf("thermal resistance %2.2f C/W\n",(tmax-Tamb)/ Pdiss);


	// экспорт 3D полевой величины u в программу tecplot 360.
	//exporttecplot3D(u, xf, yf, zf, M, N, izstop - 1);
	//exporttecplot3D_fft(u, xf, yf, zf, M, N, izstop - 1);
	exporttecplot3D22D(u, xf, yf, zf, M, N, izstop - 1);


	free_u3D(u, M, N, L);

	delete[] xf;
	delete[] yf;
	delete[] zf;

	calculation_end_time = clock();
	calculation_seach_time = calculation_end_time - calculation_start_time;
	int im = 0, is = 0, ims = 0;
	im = (int)(calculation_seach_time / 60000); // минуты
	is = (int)((calculation_seach_time - 60000 * im) / 1000); // секунды
	ims = (int)((calculation_seach_time - 60000 * im - 1000 * is)); // /10 миллисекунды делённые на 10
	printf(" %1d:%2d:%3d \n", im, is, ims);

	printf("calculation complete...\n");
	printf("please, press any key to continue...\n");

} // DFTsolver3Dq();

int _tmain(int argc, _TCHAR* argv[])
	//main(void)
{ 
	//start1(); 
	//start2();
	//startMESFETonlypotencial(); // отдельное нахождение распределения электрического потенциала.
	//start3(); // уравнение конвекции-диффузии.
	//startMESFETSi();
	//startMESFETSi();
	//startMESFETGaAs();
	//startMESFETGaN();
	// Многофункциональный запуск для моделирования ПТШ.
    //startMESFET();
	//startMESFETGaN_obkladkaA();
	//startMESFETGaN_obkladkaAquick(); // версия подверженная оптимизирующим быстродействие изменениям.
	//-->startMESFETAlGaNGaN();

	//getchar();

	//test_grad();
    //startMESFETSiPARIS2(); // ИДДМ для кремния
	//startMESFETGaAsPARIS2(); // ИДДМ для Арсенида Галлия.
	//startMESFETGaNPARIS2(); // ИДДМ для нитрида Галлия. amg

	/*
    Real E,mulow,Tamb=300.0;
	for (int i=0; i<10000; i++) {
		printf("E=\n");
		scanf("%f",&E);
		//cin >> E;
		printf("mulow=\n");
		scanf("%f",&mulow);
		//cin >> Nd;
		//printf("Tamb=\n");
		//scanf_s("%lf",&Tamb);
		printf("result input E=%e, mulow=%e, Tamb=%e\n",E,mulow,Tamb);
		printf("mobility = %e\n",GaAsDriftVel(E, mulow, Tamb));
	}
	*/
    /*
	Real E,mulow,Tamb=300.0;
	for (int i=0; i<10000; i++) {
		printf("E=\n");
		scanf("%f",&E);
		//cin >> E;
		printf("mulow=\n");
		scanf("%f",&mulow);
		//cin >> Nd;
		//printf("Tamb=\n");
		//scanf_s("%lf",&Tamb);
		printf("result input E=%e, mulow=%e, Tamb=%e\n",E,mulow,Tamb);
		printf("mobility = %e\n",GaNDriftVel(E, mulow, Tamb));
	}
	*/

	/*
	Real E,mulow,Tamb=300.0;
	for (int i=0; i<10000; i++) {
		printf("E=\n");
		scanf("%f",&E);
		//cin >> E;
		printf("mulow=\n");
		scanf("%f",&mulow);
		//cin >> Nd;
		//printf("Tamb=\n");
		//scanf_s("%lf",&Tamb);
		printf("result input E=%e mulow=%e Tamb=%e\n",E,mulow,Tamb);
		printf("dreif velocity = %e\n",Field_velocity_magAlGaNGaN(E,mulow,Tamb));
		//printf("mobility mu=%e\n",electron_mobility_GaN(Tamb,Nd));
	}
	*/
	
	
	//Roache_Fedushkin_Fedorenko(); // Алгоритм Роуча и Федюшкина и Фелоренко.
	//Simonenko_Zinkovskaya();
	//Jul(); // термоконцентрационная конвекция.

	//DFTsolver3Dq_old();
	DFTsolver3Dq();

	// Освобождение оперативной памяти.
	if (ARq!=nullptr) {
		for (int i = 0; i < N + 2; i++) {
			for (int j = 0; j < M + 2; j++) delete[] ARq[i][j];
		}
		for (int i = 0; i < N + 2; i++) delete[] ARq[i];
		delete[] ARq;
	}

	getchar();
	return 0;
}

